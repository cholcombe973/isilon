/* 
 * Isilon SDK
 *
 * Isilon SDK - Language bindings for the OneFS API
 *
 * OpenAPI spec version: 5
 * Contact: sdk@isilon.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

use std::rc::Rc;
use std::borrow::Borrow;

use hyper;
use serde_json;
use futures;
use futures::{Future, Stream};

use super::{Error, configuration};

pub struct QuotaApiClient<C: hyper::client::Connect> {
    configuration: Rc<configuration::Configuration<C>>,
}

impl<C: hyper::client::Connect> QuotaApiClient<C> {
    pub fn new(configuration: Rc<configuration::Configuration<C>>) -> QuotaApiClient<C> {
        QuotaApiClient {
            configuration: configuration,
        }
    }
}

pub trait QuotaApi {
    fn create_quota_quota(&self, quota_quota: ::models::QuotaQuotaCreateParams, zone: &str) -> Box<Future<Item = ::models::CreateResponse, Error = Error>>;
    fn create_quota_report(&self, quota_report: ::models::Empty) -> Box<Future<Item = ::models::CreateQuotaReportResponse, Error = Error>>;
    fn create_settings_mapping(&self, settings_mapping: ::models::SettingsMappingExtendedExtended) -> Box<Future<Item = ::models::CreateResponse, Error = Error>>;
    fn create_settings_notification(&self, settings_notification: ::models::QuotaNotificationCreateParams) -> Box<Future<Item = ::models::CreateResponse, Error = Error>>;
    fn delete_quota_quota(&self, quota_quota_id: &str) -> Box<Future<Item = (), Error = Error>>;
    fn delete_quota_quotas(&self, enforced: bool, include_snapshots: bool, zone: &str, recurse_path_children: bool, recurse_path_parents: bool, persona: &str, path: &str, _type: &str) -> Box<Future<Item = (), Error = Error>>;
    fn delete_quota_report(&self, quota_report_id: &str) -> Box<Future<Item = (), Error = Error>>;
    fn delete_settings_mapping(&self, settings_mapping_id: &str) -> Box<Future<Item = (), Error = Error>>;
    fn delete_settings_mappings(&self, ) -> Box<Future<Item = (), Error = Error>>;
    fn delete_settings_notification(&self, settings_notification_id: &str) -> Box<Future<Item = (), Error = Error>>;
    fn delete_settings_notifications(&self, ) -> Box<Future<Item = (), Error = Error>>;
    fn get_quota_license(&self, ) -> Box<Future<Item = ::models::LicenseLicense, Error = Error>>;
    fn get_quota_quota(&self, quota_quota_id: &str, resolve_names: bool, zone: &str) -> Box<Future<Item = ::models::QuotaQuotas, Error = Error>>;
    fn get_quota_quotas_summary(&self, ) -> Box<Future<Item = ::models::QuotaQuotasSummary, Error = Error>>;
    fn get_quota_report(&self, quota_report_id: &str, contents: bool) -> Box<Future<Item = ::models::ReportAbout, Error = Error>>;
    fn get_settings_mapping(&self, settings_mapping_id: &str) -> Box<Future<Item = ::models::SettingsMappings, Error = Error>>;
    fn get_settings_notification(&self, settings_notification_id: &str) -> Box<Future<Item = ::models::QuotaNotifications, Error = Error>>;
    fn get_settings_reports(&self, ) -> Box<Future<Item = ::models::SettingsReports, Error = Error>>;
    fn list_quota_quotas(&self, enforced: bool, include_snapshots: bool, zone: &str, resume: &str, recurse_path_children: bool, resolve_names: bool, recurse_path_parents: bool, persona: &str, limit: i32, exceeded: bool, path: &str, _type: &str, report_id: &str) -> Box<Future<Item = ::models::QuotaQuotasExtended, Error = Error>>;
    fn list_quota_reports(&self, sort: &str, resume: &str, generated: &str, limit: i32, _type: &str, dir: &str) -> Box<Future<Item = ::models::QuotaReports, Error = Error>>;
    fn list_settings_mappings(&self, ) -> Box<Future<Item = ::models::SettingsMappings, Error = Error>>;
    fn list_settings_notifications(&self, ) -> Box<Future<Item = ::models::QuotaNotificationsExtended, Error = Error>>;
    fn update_quota_quota(&self, quota_quota: ::models::QuotaQuota, quota_quota_id: &str) -> Box<Future<Item = (), Error = Error>>;
    fn update_settings_mapping(&self, settings_mapping: ::models::SettingsMappingExtended, settings_mapping_id: &str) -> Box<Future<Item = (), Error = Error>>;
    fn update_settings_notification(&self, settings_notification: ::models::QuotaNotification, settings_notification_id: &str) -> Box<Future<Item = (), Error = Error>>;
    fn update_settings_reports(&self, settings_reports: ::models::SettingsReportsExtended) -> Box<Future<Item = (), Error = Error>>;
}


impl<C: hyper::client::Connect>QuotaApi for QuotaApiClient<C> {
    fn create_quota_quota(&self, quota_quota: ::models::QuotaQuotaCreateParams, zone: &str) -> Box<Future<Item = ::models::CreateResponse, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Post;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("zone", &zone.to_string())
            .finish();
        let uri_str = format!("{}/platform/1/quota/quotas{}", configuration.base_path, query);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());


        let serialized = serde_json::to_string(&quota_quota).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::CreateResponse, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn create_quota_report(&self, quota_report: ::models::Empty) -> Box<Future<Item = ::models::CreateQuotaReportResponse, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Post;

        let uri_str = format!("{}/platform/1/quota/reports", configuration.base_path);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());


        let serialized = serde_json::to_string(&quota_report).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::CreateQuotaReportResponse, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn create_settings_mapping(&self, settings_mapping: ::models::SettingsMappingExtendedExtended) -> Box<Future<Item = ::models::CreateResponse, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Post;

        let uri_str = format!("{}/platform/1/quota/settings/mappings", configuration.base_path);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());


        let serialized = serde_json::to_string(&settings_mapping).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::CreateResponse, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn create_settings_notification(&self, settings_notification: ::models::QuotaNotificationCreateParams) -> Box<Future<Item = ::models::CreateResponse, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Post;

        let uri_str = format!("{}/platform/1/quota/settings/notifications", configuration.base_path);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());


        let serialized = serde_json::to_string(&settings_notification).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::CreateResponse, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn delete_quota_quota(&self, quota_quota_id: &str) -> Box<Future<Item = (), Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Delete;

        let uri_str = format!("{}/platform/1/quota/quotas/{QuotaQuotaId}", configuration.base_path, QuotaQuotaId=quota_quota_id);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|_| futures::future::ok(()))
        )
    }

    fn delete_quota_quotas(&self, enforced: bool, include_snapshots: bool, zone: &str, recurse_path_children: bool, recurse_path_parents: bool, persona: &str, path: &str, _type: &str) -> Box<Future<Item = (), Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Delete;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("enforced", &enforced.to_string())
            .append_pair("include_snapshots", &include_snapshots.to_string())
            .append_pair("zone", &zone.to_string())
            .append_pair("recurse_path_children", &recurse_path_children.to_string())
            .append_pair("recurse_path_parents", &recurse_path_parents.to_string())
            .append_pair("persona", &persona.to_string())
            .append_pair("path", &path.to_string())
            .append_pair("type", &_type.to_string())
            .finish();
        let uri_str = format!("{}/platform/1/quota/quotas{}", configuration.base_path, query);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|_| futures::future::ok(()))
        )
    }

    fn delete_quota_report(&self, quota_report_id: &str) -> Box<Future<Item = (), Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Delete;

        let uri_str = format!("{}/platform/1/quota/reports/{QuotaReportId}", configuration.base_path, QuotaReportId=quota_report_id);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|_| futures::future::ok(()))
        )
    }

    fn delete_settings_mapping(&self, settings_mapping_id: &str) -> Box<Future<Item = (), Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Delete;

        let uri_str = format!("{}/platform/1/quota/settings/mappings/{SettingsMappingId}", configuration.base_path, SettingsMappingId=settings_mapping_id);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|_| futures::future::ok(()))
        )
    }

    fn delete_settings_mappings(&self, ) -> Box<Future<Item = (), Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Delete;

        let uri_str = format!("{}/platform/1/quota/settings/mappings", configuration.base_path);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|_| futures::future::ok(()))
        )
    }

    fn delete_settings_notification(&self, settings_notification_id: &str) -> Box<Future<Item = (), Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Delete;

        let uri_str = format!("{}/platform/1/quota/settings/notifications/{SettingsNotificationId}", configuration.base_path, SettingsNotificationId=settings_notification_id);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|_| futures::future::ok(()))
        )
    }

    fn delete_settings_notifications(&self, ) -> Box<Future<Item = (), Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Delete;

        let uri_str = format!("{}/platform/1/quota/settings/notifications", configuration.base_path);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|_| futures::future::ok(()))
        )
    }

    fn get_quota_license(&self, ) -> Box<Future<Item = ::models::LicenseLicense, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let uri_str = format!("{}/platform/5/quota/license", configuration.base_path);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::LicenseLicense, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn get_quota_quota(&self, quota_quota_id: &str, resolve_names: bool, zone: &str) -> Box<Future<Item = ::models::QuotaQuotas, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("resolve_names", &resolve_names.to_string())
            .append_pair("zone", &zone.to_string())
            .finish();
        let uri_str = format!("{}/platform/1/quota/quotas/{QuotaQuotaId}{}", configuration.base_path, query, QuotaQuotaId=quota_quota_id);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::QuotaQuotas, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn get_quota_quotas_summary(&self, ) -> Box<Future<Item = ::models::QuotaQuotasSummary, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let uri_str = format!("{}/platform/1/quota/quotas-summary", configuration.base_path);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::QuotaQuotasSummary, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn get_quota_report(&self, quota_report_id: &str, contents: bool) -> Box<Future<Item = ::models::ReportAbout, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("contents", &contents.to_string())
            .finish();
        let uri_str = format!("{}/platform/1/quota/reports/{QuotaReportId}{}", configuration.base_path, query, QuotaReportId=quota_report_id);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::ReportAbout, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn get_settings_mapping(&self, settings_mapping_id: &str) -> Box<Future<Item = ::models::SettingsMappings, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let uri_str = format!("{}/platform/1/quota/settings/mappings/{SettingsMappingId}", configuration.base_path, SettingsMappingId=settings_mapping_id);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::SettingsMappings, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn get_settings_notification(&self, settings_notification_id: &str) -> Box<Future<Item = ::models::QuotaNotifications, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let uri_str = format!("{}/platform/1/quota/settings/notifications/{SettingsNotificationId}", configuration.base_path, SettingsNotificationId=settings_notification_id);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::QuotaNotifications, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn get_settings_reports(&self, ) -> Box<Future<Item = ::models::SettingsReports, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let uri_str = format!("{}/platform/1/quota/settings/reports", configuration.base_path);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::SettingsReports, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn list_quota_quotas(&self, enforced: bool, include_snapshots: bool, zone: &str, resume: &str, recurse_path_children: bool, resolve_names: bool, recurse_path_parents: bool, persona: &str, limit: i32, exceeded: bool, path: &str, _type: &str, report_id: &str) -> Box<Future<Item = ::models::QuotaQuotasExtended, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("enforced", &enforced.to_string())
            .append_pair("include_snapshots", &include_snapshots.to_string())
            .append_pair("zone", &zone.to_string())
            .append_pair("resume", &resume.to_string())
            .append_pair("recurse_path_children", &recurse_path_children.to_string())
            .append_pair("resolve_names", &resolve_names.to_string())
            .append_pair("recurse_path_parents", &recurse_path_parents.to_string())
            .append_pair("persona", &persona.to_string())
            .append_pair("limit", &limit.to_string())
            .append_pair("exceeded", &exceeded.to_string())
            .append_pair("path", &path.to_string())
            .append_pair("type", &_type.to_string())
            .append_pair("report_id", &report_id.to_string())
            .finish();
        let uri_str = format!("{}/platform/1/quota/quotas{}", configuration.base_path, query);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::QuotaQuotasExtended, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn list_quota_reports(&self, sort: &str, resume: &str, generated: &str, limit: i32, _type: &str, dir: &str) -> Box<Future<Item = ::models::QuotaReports, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("sort", &sort.to_string())
            .append_pair("resume", &resume.to_string())
            .append_pair("generated", &generated.to_string())
            .append_pair("limit", &limit.to_string())
            .append_pair("type", &_type.to_string())
            .append_pair("dir", &dir.to_string())
            .finish();
        let uri_str = format!("{}/platform/1/quota/reports{}", configuration.base_path, query);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::QuotaReports, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn list_settings_mappings(&self, ) -> Box<Future<Item = ::models::SettingsMappings, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let uri_str = format!("{}/platform/1/quota/settings/mappings", configuration.base_path);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::SettingsMappings, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn list_settings_notifications(&self, ) -> Box<Future<Item = ::models::QuotaNotificationsExtended, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let uri_str = format!("{}/platform/1/quota/settings/notifications", configuration.base_path);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());



        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|body| {
                let parsed: Result<::models::QuotaNotificationsExtended, _> = serde_json::from_slice(&body);
                parsed.map_err(|e| Error::from(e))
            }).map_err(|e| Error::from(e))
        )
    }

    fn update_quota_quota(&self, quota_quota: ::models::QuotaQuota, quota_quota_id: &str) -> Box<Future<Item = (), Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Put;

        let uri_str = format!("{}/platform/1/quota/quotas/{QuotaQuotaId}", configuration.base_path, QuotaQuotaId=quota_quota_id);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());


        let serialized = serde_json::to_string(&quota_quota).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|_| futures::future::ok(()))
        )
    }

    fn update_settings_mapping(&self, settings_mapping: ::models::SettingsMappingExtended, settings_mapping_id: &str) -> Box<Future<Item = (), Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Put;

        let uri_str = format!("{}/platform/1/quota/settings/mappings/{SettingsMappingId}", configuration.base_path, SettingsMappingId=settings_mapping_id);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());


        let serialized = serde_json::to_string(&settings_mapping).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|_| futures::future::ok(()))
        )
    }

    fn update_settings_notification(&self, settings_notification: ::models::QuotaNotification, settings_notification_id: &str) -> Box<Future<Item = (), Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Put;

        let uri_str = format!("{}/platform/1/quota/settings/notifications/{SettingsNotificationId}", configuration.base_path, SettingsNotificationId=settings_notification_id);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());


        let serialized = serde_json::to_string(&settings_notification).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|_| futures::future::ok(()))
        )
    }

    fn update_settings_reports(&self, settings_reports: ::models::SettingsReportsExtended) -> Box<Future<Item = (), Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Put;

        let uri_str = format!("{}/platform/1/quota/settings/reports", configuration.base_path);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());


        let serialized = serde_json::to_string(&settings_reports).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut().set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
            configuration.client.request(req).and_then(|res| { res.body().concat2() })
            .map_err(|e| Error::from(e))
            .and_then(|_| futures::future::ok(()))
        )
    }

}
