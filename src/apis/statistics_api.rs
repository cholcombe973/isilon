/*
 * Isilon SDK
 *
 * Isilon SDK - Language bindings for the OneFS API
 *
 * OpenAPI spec version: 5
 * Contact: sdk@isilon.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

use std::borrow::Borrow;
use std::rc::Rc;

use futures;
use futures::{Future, Stream};
use hyper;
use serde_json;

use super::{configuration, Error};

pub struct StatisticsApiClient<C: hyper::client::Connect> {
    configuration: Rc<configuration::Configuration<C>>,
}

impl<C: hyper::client::Connect> StatisticsApiClient<C> {
    pub fn new(configuration: Rc<configuration::Configuration<C>>) -> StatisticsApiClient<C> {
        StatisticsApiClient {
            configuration: configuration,
        }
    }
}

pub trait StatisticsApi {
    fn get_statistics_current(
        &self,
        timeout: i32,
        show_nodes: bool,
        keys: Vec<String>,
        devid: Vec<String>,
        substr: bool,
        stale: bool,
        type_info: bool,
        raw: bool,
        key: Vec<String>,
        degraded: bool,
        nodes: Vec<String>,
    ) -> Box<Future<Item = ::models::StatisticsCurrent, Error = Error>>;
    fn get_statistics_history(
        &self,
        begin: i32,
        interval: i32,
        end: i32,
        timeout: i32,
        raw: bool,
        keys: Vec<String>,
        devid: Vec<String>,
        substr: bool,
        stale: bool,
        type_info: bool,
        memory_only: bool,
        key: Vec<String>,
        degraded: bool,
        show_nodes: bool,
        resolution: i32,
        nodes: Vec<String>,
    ) -> Box<Future<Item = ::models::StatisticsHistory, Error = Error>>;
    fn get_statistics_key(
        &self,
        statistics_key_id: &str,
    ) -> Box<Future<Item = ::models::StatisticsKeys, Error = Error>>;
    fn get_statistics_keys(
        &self,
        count: bool,
        limit: i32,
        queryable: bool,
        resume: &str,
    ) -> Box<Future<Item = ::models::StatisticsKeysExtended, Error = Error>>;
    fn get_statistics_operations(
        &self,
        protocols: Vec<String>,
    ) -> Box<Future<Item = ::models::StatisticsOperations, Error = Error>>;
    fn get_statistics_protocols(
        &self,
        _type: &str,
    ) -> Box<Future<Item = ::models::StatisticsProtocols, Error = Error>>;
    fn get_summary_client(
        &self,
        sort: &str,
        totalby: &str,
        user_names: &str,
        remote_addresses: &str,
        numeric: bool,
        local_names: &str,
        user_ids: &str,
        classes: &str,
        timeout: i32,
        local_addresses: &str,
        degraded: bool,
        remote_names: &str,
        nodes: &str,
        protocols: &str,
    ) -> Box<Future<Item = ::models::SummaryClient, Error = Error>>;
    fn get_summary_drive(
        &self,
        sort: &str,
        degraded: bool,
        _type: &str,
        nodes: &str,
        timeout: i32,
    ) -> Box<Future<Item = ::models::SummaryDrive, Error = Error>>;
    fn get_summary_heat(
        &self,
        sort: &str,
        convertlin: bool,
        totalby: &str,
        pathdepth: i32,
        numeric: bool,
        events: &str,
        maxpath: i32,
        classes: &str,
        timeout: i32,
        nodes: &str,
        degraded: bool,
    ) -> Box<Future<Item = ::models::SummaryHeat, Error = Error>>;
    fn get_summary_protocol(
        &self,
        operations: &str,
        sort: &str,
        totalby: &str,
        zero: bool,
        classes: &str,
        timeout: i32,
        degraded: bool,
        nodes: &str,
        protocols: &str,
    ) -> Box<Future<Item = ::models::SummaryProtocol, Error = Error>>;
    fn get_summary_protocol_stats(
        &self,
        degraded: bool,
        protocol: Option<&str>,
        nodes: Option<&str>,
        timeout: i32,
    ) -> Box<Future<Item = ::models::SummaryProtocolStats, Error = Error>>;
    fn get_summary_system(
        &self,
        sort: &str,
        oprates: bool,
        degraded: bool,
        nodes: &str,
        timeout: i32,
    ) -> Box<Future<Item = ::models::SummarySystem, Error = Error>>;
    fn get_summary_workload(
        &self,
        sort: &str,
        job_types: Vec<String>,
        totalby: &str,
        timeout: i32,
        degraded: bool,
        nodes: &str,
        system_names: &str,
    ) -> Box<Future<Item = ::models::SummaryWorkload, Error = Error>>;
}

impl<C: hyper::client::Connect> StatisticsApi for StatisticsApiClient<C> {
    fn get_statistics_current(
        &self,
        timeout: i32,
        show_nodes: bool,
        keys: Vec<String>,
        devid: Vec<String>,
        substr: bool,
        stale: bool,
        type_info: bool,
        raw: bool,
        key: Vec<String>,
        degraded: bool,
        nodes: Vec<String>,
    ) -> Box<Future<Item = ::models::StatisticsCurrent, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("timeout", &timeout.to_string())
            .append_pair("show_nodes", &show_nodes.to_string())
            .append_pair("keys", &keys.join(",").to_string())
            .append_pair("devid", &devid.join(",").to_string())
            .append_pair("substr", &substr.to_string())
            .append_pair("stale", &stale.to_string())
            .append_pair("type_info", &type_info.to_string())
            .append_pair("raw", &raw.to_string())
            .append_pair("key", &key.join(",").to_string())
            .append_pair("degraded", &degraded.to_string())
            .append_pair("nodes", &nodes.join(",").to_string())
            .finish();
        let uri_str = format!(
            "{}/platform/1/statistics/current?{}",
            configuration.base_path, query
        );

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());
        configuration.set_session(&mut req).unwrap();

        // send request
        Box::new(
            configuration
                .client
                .request(req)
                .and_then(|res| res.body().concat2())
                .map_err(|e| Error::from(e))
                .and_then(|body| {
                    let parsed: Result<::models::StatisticsCurrent, _> =
                        serde_json::from_slice(&body);
                    parsed.map_err(|e| Error::from(e))
                })
                .map_err(|e| Error::from(e)),
        )
    }

    fn get_statistics_history(
        &self,
        begin: i32,
        interval: i32,
        end: i32,
        timeout: i32,
        raw: bool,
        keys: Vec<String>,
        devid: Vec<String>,
        substr: bool,
        stale: bool,
        type_info: bool,
        memory_only: bool,
        key: Vec<String>,
        degraded: bool,
        show_nodes: bool,
        resolution: i32,
        nodes: Vec<String>,
    ) -> Box<Future<Item = ::models::StatisticsHistory, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("begin", &begin.to_string())
            .append_pair("interval", &interval.to_string())
            .append_pair("end", &end.to_string())
            .append_pair("timeout", &timeout.to_string())
            .append_pair("raw", &raw.to_string())
            .append_pair("keys", &keys.join(",").to_string())
            .append_pair("devid", &devid.join(",").to_string())
            .append_pair("substr", &substr.to_string())
            .append_pair("stale", &stale.to_string())
            .append_pair("type_info", &type_info.to_string())
            .append_pair("memory_only", &memory_only.to_string())
            .append_pair("key", &key.join(",").to_string())
            .append_pair("degraded", &degraded.to_string())
            .append_pair("show_nodes", &show_nodes.to_string())
            .append_pair("resolution", &resolution.to_string())
            .append_pair("nodes", &nodes.join(",").to_string())
            .finish();
        let uri_str = format!(
            "{}/platform/1/statistics/history?{}",
            configuration.base_path, query
        );

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());
        configuration.set_session(&mut req).unwrap();

        // send request
        Box::new(
            configuration
                .client
                .request(req)
                .and_then(|res| res.body().concat2())
                .map_err(|e| Error::from(e))
                .and_then(|body| {
                    let parsed: Result<::models::StatisticsHistory, _> =
                        serde_json::from_slice(&body);
                    parsed.map_err(|e| Error::from(e))
                })
                .map_err(|e| Error::from(e)),
        )
    }

    fn get_statistics_key(
        &self,
        statistics_key_id: &str,
    ) -> Box<Future<Item = ::models::StatisticsKeys, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let uri_str = format!(
            "{}/platform/1/statistics/keys/{StatisticsKeyId}",
            configuration.base_path,
            StatisticsKeyId = statistics_key_id
        );

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());
        configuration.set_session(&mut req).unwrap();

        // send request
        Box::new(
            configuration
                .client
                .request(req)
                .and_then(|res| res.body().concat2())
                .map_err(|e| Error::from(e))
                .and_then(|body| {
                    let parsed: Result<::models::StatisticsKeys, _> = serde_json::from_slice(&body);
                    parsed.map_err(|e| Error::from(e))
                })
                .map_err(|e| Error::from(e)),
        )
    }

    fn get_statistics_keys(
        &self,
        count: bool,
        limit: i32,
        queryable: bool,
        resume: &str,
    ) -> Box<Future<Item = ::models::StatisticsKeysExtended, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("count", &count.to_string())
            .append_pair("limit", &limit.to_string())
            .append_pair("queryable", &queryable.to_string())
            .append_pair("resume", &resume.to_string())
            .finish();
        let uri_str = format!(
            "{}/platform/1/statistics/keys?{}",
            configuration.base_path, query
        );

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());
        configuration.set_session(&mut req).unwrap();

        // send request
        Box::new(
            configuration
                .client
                .request(req)
                .and_then(|res| res.body().concat2())
                .map_err(|e| Error::from(e))
                .and_then(|body| {
                    let parsed: Result<::models::StatisticsKeysExtended, _> =
                        serde_json::from_slice(&body);
                    parsed.map_err(|e| Error::from(e))
                })
                .map_err(|e| Error::from(e)),
        )
    }

    fn get_statistics_operations(
        &self,
        protocols: Vec<String>,
    ) -> Box<Future<Item = ::models::StatisticsOperations, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("protocols", &protocols.join(",").to_string())
            .finish();
        let uri_str = format!(
            "{}/platform/3/statistics/operations?{}",
            configuration.base_path, query
        );

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());
        configuration.set_session(&mut req).unwrap();

        // send request
        Box::new(
            configuration
                .client
                .request(req)
                .and_then(|res| res.body().concat2())
                .map_err(|e| Error::from(e))
                .and_then(|body| {
                    let parsed: Result<::models::StatisticsOperations, _> =
                        serde_json::from_slice(&body);
                    parsed.map_err(|e| Error::from(e))
                })
                .map_err(|e| Error::from(e)),
        )
    }

    fn get_statistics_protocols(
        &self,
        _type: &str,
    ) -> Box<Future<Item = ::models::StatisticsProtocols, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("type", &_type.to_string())
            .finish();
        let uri_str = format!(
            "{}/platform/1/statistics/protocols?{}",
            configuration.base_path, query
        );

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());
        configuration.set_session(&mut req).unwrap();

        // send request
        Box::new(
            configuration
                .client
                .request(req)
                .and_then(|res| res.body().concat2())
                .map_err(|e| Error::from(e))
                .and_then(|body| {
                    let parsed: Result<::models::StatisticsProtocols, _> =
                        serde_json::from_slice(&body);
                    parsed.map_err(|e| Error::from(e))
                })
                .map_err(|e| Error::from(e)),
        )
    }

    fn get_summary_client(
        &self,
        sort: &str,
        totalby: &str,
        user_names: &str,
        remote_addresses: &str,
        numeric: bool,
        local_names: &str,
        user_ids: &str,
        classes: &str,
        timeout: i32,
        local_addresses: &str,
        degraded: bool,
        remote_names: &str,
        nodes: &str,
        protocols: &str,
    ) -> Box<Future<Item = ::models::SummaryClient, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("sort", &sort.to_string())
            .append_pair("totalby", &totalby.to_string())
            .append_pair("user_names", &user_names.to_string())
            .append_pair("remote_addresses", &remote_addresses.to_string())
            .append_pair("numeric", &numeric.to_string())
            .append_pair("local_names", &local_names.to_string())
            .append_pair("user_ids", &user_ids.to_string())
            .append_pair("classes", &classes.to_string())
            .append_pair("timeout", &timeout.to_string())
            .append_pair("local_addresses", &local_addresses.to_string())
            .append_pair("degraded", &degraded.to_string())
            .append_pair("remote_names", &remote_names.to_string())
            .append_pair("nodes", &nodes.to_string())
            .append_pair("protocols", &protocols.to_string())
            .finish();
        let uri_str = format!(
            "{}/platform/3/statistics/summary/client?{}",
            configuration.base_path, query
        );

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());
        configuration.set_session(&mut req).unwrap();

        // send request
        Box::new(
            configuration
                .client
                .request(req)
                .and_then(|res| res.body().concat2())
                .map_err(|e| Error::from(e))
                .and_then(|body| {
                    let parsed: Result<::models::SummaryClient, _> = serde_json::from_slice(&body);
                    parsed.map_err(|e| Error::from(e))
                })
                .map_err(|e| Error::from(e)),
        )
    }

    fn get_summary_drive(
        &self,
        sort: &str,
        degraded: bool,
        _type: &str,
        nodes: &str,
        timeout: i32,
    ) -> Box<Future<Item = ::models::SummaryDrive, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("sort", &sort.to_string())
            .append_pair("degraded", &degraded.to_string())
            .append_pair("type", &_type.to_string())
            .append_pair("nodes", &nodes.to_string())
            .append_pair("timeout", &timeout.to_string())
            .finish();
        let uri_str = format!(
            "{}/platform/3/statistics/summary/drive?{}",
            configuration.base_path, query
        );

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());
        configuration.set_session(&mut req).unwrap();

        // send request
        Box::new(
            configuration
                .client
                .request(req)
                .and_then(|res| res.body().concat2())
                .map_err(|e| Error::from(e))
                .and_then(|body| {
                    let parsed: Result<::models::SummaryDrive, _> = serde_json::from_slice(&body);
                    parsed.map_err(|e| Error::from(e))
                })
                .map_err(|e| Error::from(e)),
        )
    }

    fn get_summary_heat(
        &self,
        sort: &str,
        convertlin: bool,
        totalby: &str,
        pathdepth: i32,
        numeric: bool,
        events: &str,
        maxpath: i32,
        classes: &str,
        timeout: i32,
        nodes: &str,
        degraded: bool,
    ) -> Box<Future<Item = ::models::SummaryHeat, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("sort", &sort.to_string())
            .append_pair("convertlin", &convertlin.to_string())
            .append_pair("totalby", &totalby.to_string())
            .append_pair("pathdepth", &pathdepth.to_string())
            .append_pair("numeric", &numeric.to_string())
            .append_pair("events", &events.to_string())
            .append_pair("maxpath", &maxpath.to_string())
            .append_pair("classes", &classes.to_string())
            .append_pair("timeout", &timeout.to_string())
            .append_pair("nodes", &nodes.to_string())
            .append_pair("degraded", &degraded.to_string())
            .finish();
        let uri_str = format!(
            "{}/platform/3/statistics/summary/heat?{}",
            configuration.base_path, query
        );

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());
        configuration.set_session(&mut req).unwrap();

        // send request
        Box::new(
            configuration
                .client
                .request(req)
                .and_then(|res| res.body().concat2())
                .map_err(|e| Error::from(e))
                .and_then(|body| {
                    let parsed: Result<::models::SummaryHeat, _> = serde_json::from_slice(&body);
                    parsed.map_err(|e| Error::from(e))
                })
                .map_err(|e| Error::from(e)),
        )
    }

    fn get_summary_protocol(
        &self,
        operations: &str,
        sort: &str,
        totalby: &str,
        zero: bool,
        classes: &str,
        timeout: i32,
        degraded: bool,
        nodes: &str,
        protocols: &str,
    ) -> Box<Future<Item = ::models::SummaryProtocol, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("operations", &operations.to_string())
            .append_pair("sort", &sort.to_string())
            .append_pair("totalby", &totalby.to_string())
            .append_pair("zero", &zero.to_string())
            .append_pair("classes", &classes.to_string())
            .append_pair("timeout", &timeout.to_string())
            .append_pair("degraded", &degraded.to_string())
            .append_pair("nodes", &nodes.to_string())
            .append_pair("protocols", &protocols.to_string())
            .finish();
        let uri_str = format!(
            "{}/platform/3/statistics/summary/protocol?{}",
            configuration.base_path, query
        );

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());
        configuration.set_session(&mut req).unwrap();

        // send request
        Box::new(
            configuration
                .client
                .request(req)
                .and_then(|res| res.body().concat2())
                .map_err(|e| Error::from(e))
                .and_then(|body| {
                    let parsed: Result<::models::SummaryProtocol, _> =
                        serde_json::from_slice(&body);
                    parsed.map_err(|e| Error::from(e))
                })
                .map_err(|e| Error::from(e)),
        )
    }

    fn get_summary_protocol_stats(
        &self,
        degraded: bool,
        protocol: Option<&str>,
        nodes: Option<&str>,
        timeout: i32,
    ) -> Box<Future<Item = ::models::SummaryProtocolStats, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let mut buff = String::new();
        let mut query = ::url::form_urlencoded::Serializer::new(buff);
        query.append_pair("degraded", &degraded.to_string());
        query.append_pair("timeout", &timeout.to_string());
        if let Some(protocol) = protocol {
            query.append_pair("protocol", &protocol.to_string());
        }
        if let Some(nodes) = nodes {
            query.append_pair("nodes", &nodes.to_string());
        }
        let query = query.finish();

        let uri_str = format!(
            "{}/platform/3/statistics/summary/protocol-stats?{}",
            configuration.base_path, query
        );
        debug!("summary_protocol uri_str: {}", uri_str);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());
        configuration.set_session(&mut req).unwrap();

        // send request
        Box::new(
            configuration
                .client
                .request(req)
                .and_then(|res| res.body().concat2())
                .map_err(|e| Error::from(e))
                .and_then(|body| {
                    let parsed: Result<::models::SummaryProtocolStats, _> =
                        serde_json::from_slice(&body);
                    parsed.map_err(|e| Error::from(e))
                })
                .map_err(|e| Error::from(e)),
        )
    }

    fn get_summary_system(
        &self,
        sort: &str,
        oprates: bool,
        degraded: bool,
        nodes: &str,
        timeout: i32,
    ) -> Box<Future<Item = ::models::SummarySystem, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("sort", &sort.to_string())
            .append_pair("oprates", &oprates.to_string())
            .append_pair("degraded", &degraded.to_string())
            .append_pair("nodes", &nodes.to_string())
            .append_pair("timeout", &timeout.to_string())
            .finish();
        let uri_str = format!(
            "{}/platform/3/statistics/summary/system?{}",
            configuration.base_path, query
        );

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());
        configuration.set_session(&mut req).unwrap();

        // send request
        Box::new(
            configuration
                .client
                .request(req)
                .and_then(|res| res.body().concat2())
                .map_err(|e| Error::from(e))
                .and_then(|body| {
                    let parsed: Result<::models::SummarySystem, _> = serde_json::from_slice(&body);
                    parsed.map_err(|e| Error::from(e))
                })
                .map_err(|e| Error::from(e)),
        )
    }

    fn get_summary_workload(
        &self,
        sort: &str,
        job_types: Vec<String>,
        totalby: &str,
        timeout: i32,
        degraded: bool,
        nodes: &str,
        system_names: &str,
    ) -> Box<Future<Item = ::models::SummaryWorkload, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("sort", &sort.to_string())
            .append_pair("job_types", &job_types.join(",").to_string())
            .append_pair("totalby", &totalby.to_string())
            .append_pair("timeout", &timeout.to_string())
            .append_pair("degraded", &degraded.to_string())
            .append_pair("nodes", &nodes.to_string())
            .append_pair("system_names", &system_names.to_string())
            .finish();
        let uri_str = format!(
            "{}/platform/4/statistics/summary/workload?{}",
            configuration.base_path, query
        );

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());
        configuration.set_session(&mut req).unwrap();

        // send request
        Box::new(
            configuration
                .client
                .request(req)
                .and_then(|res| res.body().concat2())
                .map_err(|e| Error::from(e))
                .and_then(|body| {
                    let parsed: Result<::models::SummaryWorkload, _> =
                        serde_json::from_slice(&body);
                    parsed.map_err(|e| Error::from(e))
                })
                .map_err(|e| Error::from(e)),
        )
    }
}
