/*
 * Isilon SDK
 *
 * Isilon SDK - Language bindings for the OneFS API
 *
 * OpenAPI spec version: 5
 * Contact: sdk@isilon.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

use std::borrow::Borrow;
use std::rc::Rc;

use futures;
use futures::Future;
use hyper;

use super::{configuration, put, query, Error};

pub struct ProtocolsApiClient<C: hyper::client::connect::Connect> {
    configuration: Rc<configuration::Configuration<C>>,
}

impl<C: hyper::client::connect::Connect> ProtocolsApiClient<C> {
    pub fn new(configuration: Rc<configuration::Configuration<C>>) -> ProtocolsApiClient<C> {
        ProtocolsApiClient {
            configuration: configuration,
        }
    }
}

pub trait ProtocolsApi {
    fn create_hdfs_proxyuser(
        &self,
        hdfs_proxyuser: crate::models::HdfsProxyuserCreateParams,
        zone: &str,
    ) -> Box<dyn Future<Item = crate::models::CreateResponse, Error = Error>>;
    fn create_hdfs_rack(
        &self,
        hdfs_rack: crate::models::HdfsRackCreateParams,
        zone: &str,
    ) -> Box<dyn Future<Item = crate::models::CreateResponse, Error = Error>>;
    fn create_ndmp_settings_preferred_ip(
        &self,
        ndmp_settings_preferred_ip: crate::models::NdmpSettingsPreferredIpCreateParams,
    ) -> Box<dyn Future<Item = crate::models::Empty, Error = Error>>;
    fn create_ndmp_settings_variable(
        &self,
        ndmp_settings_variable: crate::models::NdmpSettingsVariableCreateParams,
        ndmp_settings_variable_id: &str,
    ) -> Box<dyn Future<Item = crate::models::Empty, Error = Error>>;
    fn create_ndmp_user(
        &self,
        ndmp_user: crate::models::NdmpUserCreateParams,
    ) -> Box<dyn Future<Item = crate::models::Empty, Error = Error>>;
    fn create_nfs_alias(
        &self,
        nfs_alias: crate::models::NfsAliasCreateParams,
        zone: &str,
    ) -> Box<dyn Future<Item = crate::models::CreateNfsAliasResponse, Error = Error>>;
    fn create_nfs_export(
        &self,
        nfs_export: crate::models::NfsExportCreateParams,
        force: bool,
        ignore_unresolvable_hosts: bool,
        zone: &str,
        ignore_conflicts: bool,
        ignore_bad_paths: bool,
        ignore_bad_auth: bool,
    ) -> Box<dyn Future<Item = crate::models::CreateQuotaReportResponse, Error = Error>>;
    fn create_nfs_netgroup_check_item(
        &self,
        nfs_netgroup_check_item: crate::models::Empty,
        host: &str,
    ) -> Box<dyn Future<Item = crate::models::Empty, Error = Error>>;
    fn create_nfs_netgroup_flush_item(
        &self,
        nfs_netgroup_flush_item: crate::models::Empty,
        host: &str,
    ) -> Box<dyn Future<Item = crate::models::Empty, Error = Error>>;
    fn create_nfs_nlm_sessions_check_item(
        &self,
        nfs_nlm_sessions_check_item: crate::models::Empty,
        cluster_ip: &str,
        zone: &str,
    ) -> Box<dyn Future<Item = crate::models::CreateNfsNlmSessionsCheckItemResponse, Error = Error>>;
    fn create_nfs_reload_item(
        &self,
        nfs_reload_item: crate::models::Empty,
        zone: &str,
    ) -> Box<dyn Future<Item = crate::models::Empty, Error = Error>>;
    fn create_ntp_server(
        &self,
        ntp_server: crate::models::NtpServerCreateParams,
    ) -> Box<dyn Future<Item = crate::models::Empty, Error = Error>>;
    fn create_smb_log_level_filter(
        &self,
        smb_log_level_filter: crate::models::SmbLogLevelFilter,
    ) -> Box<dyn Future<Item = crate::models::CreateAuthRefreshItemResponse, Error = Error>>;
    fn create_smb_share(
        &self,
        smb_share: crate::models::SmbShareCreateParams,
        zone: &str,
    ) -> Box<dyn Future<Item = crate::models::CreateResponse, Error = Error>>;
    fn create_swift_account(
        &self,
        swift_account: crate::models::SwiftAccount,
        zone: &str,
    ) -> Box<dyn Future<Item = crate::models::Empty, Error = Error>>;
    fn delete_hdfs_proxyuser(
        &self,
        hdfs_proxyuser_id: &str,
        zone: &str,
    ) -> Box<dyn Future<Item = (), Error = Error>>;
    fn delete_hdfs_rack(
        &self,
        hdfs_rack_id: &str,
        zone: &str,
    ) -> Box<dyn Future<Item = (), Error = Error>>;
    fn delete_ndmp_contexts_backup_by_id(
        &self,
        ndmp_contexts_backup_id: &str,
    ) -> Box<dyn Future<Item = (), Error = Error>>;
    fn delete_ndmp_contexts_bre_by_id(
        &self,
        ndmp_contexts_bre_id: &str,
    ) -> Box<dyn Future<Item = (), Error = Error>>;
    fn delete_ndmp_contexts_restore_by_id(
        &self,
        ndmp_contexts_restore_id: &str,
    ) -> Box<dyn Future<Item = (), Error = Error>>;
    fn delete_ndmp_dumpdate(
        &self,
        ndmp_dumpdate_id: &str,
        level: i32,
    ) -> Box<dyn Future<Item = (), Error = Error>>;
    fn delete_ndmp_session(
        &self,
        ndmp_session_id: &str,
        lnn: &str,
    ) -> Box<dyn Future<Item = (), Error = Error>>;
    fn delete_ndmp_settings_preferred_ip(
        &self,
        ndmp_settings_preferred_ip_id: &str,
    ) -> Box<dyn Future<Item = (), Error = Error>>;
    fn delete_ndmp_settings_variable(
        &self,
        ndmp_settings_variable_id: &str,
        name: &str,
    ) -> Box<dyn Future<Item = (), Error = Error>>;
    fn delete_ndmp_user(&self, ndmp_user_id: &str) -> Box<dyn Future<Item = (), Error = Error>>;
    fn delete_nfs_alias(
        &self,
        nfs_alias_id: &str,
        zone: &str,
    ) -> Box<dyn Future<Item = (), Error = Error>>;
    fn delete_nfs_export(
        &self,
        nfs_export_id: &str,
        zone: &str,
    ) -> Box<dyn Future<Item = (), Error = Error>>;
    fn delete_nfs_nlm_session(
        &self,
        nfs_nlm_session_id: &str,
        cluster_ip: &str,
        zone: &str,
        refresh: bool,
    ) -> Box<dyn Future<Item = (), Error = Error>>;
    fn delete_ntp_server(&self, ntp_server_id: &str) -> Box<dyn Future<Item = (), Error = Error>>;
    fn delete_ntp_servers(&self) -> Box<dyn Future<Item = (), Error = Error>>;
    fn delete_smb_log_level_filter(
        &self,
        smb_log_level_filter_id: &str,
    ) -> Box<dyn Future<Item = (), Error = Error>>;
    fn delete_smb_log_level_filters(
        &self,
        level: &str,
    ) -> Box<dyn Future<Item = (), Error = Error>>;
    fn delete_smb_openfile(
        &self,
        smb_openfile_id: &str,
    ) -> Box<dyn Future<Item = (), Error = Error>>;
    fn delete_smb_session(&self, smb_session_id: &str)
        -> Box<dyn Future<Item = (), Error = Error>>;
    fn delete_smb_sessions_computer_user(
        &self,
        smb_sessions_computer_user: &str,
        computer: &str,
    ) -> Box<dyn Future<Item = (), Error = Error>>;
    fn delete_smb_share(
        &self,
        smb_share_id: &str,
        zone: &str,
    ) -> Box<dyn Future<Item = (), Error = Error>>;
    fn delete_smb_shares(&self) -> Box<dyn Future<Item = (), Error = Error>>;
    fn delete_swift_account(
        &self,
        swift_account_id: &str,
        zone: &str,
    ) -> Box<dyn Future<Item = (), Error = Error>>;
    fn get_ftp_settings(&self)
        -> Box<dyn Future<Item = crate::models::FtpSettings, Error = Error>>;
    fn get_hdfs_log_level(
        &self,
    ) -> Box<dyn Future<Item = crate::models::HdfsLogLevel, Error = Error>>;
    fn get_hdfs_proxyuser(
        &self,
        hdfs_proxyuser_id: &str,
        zone: &str,
    ) -> Box<dyn Future<Item = crate::models::HdfsProxyusers, Error = Error>>;
    fn get_hdfs_rack(
        &self,
        hdfs_rack_id: &str,
        zone: &str,
    ) -> Box<dyn Future<Item = crate::models::HdfsRacks, Error = Error>>;
    fn get_hdfs_ranger_plugin_settings(
        &self,
        zone: &str,
    ) -> Box<dyn Future<Item = crate::models::HdfsRangerPluginSettings, Error = Error>>;
    fn get_hdfs_settings(
        &self,
        zone: &str,
    ) -> Box<dyn Future<Item = crate::models::HdfsSettings, Error = Error>>;
    fn get_http_settings(
        &self,
    ) -> Box<dyn Future<Item = crate::models::HttpSettings, Error = Error>>;
    fn get_ndmp_contexts_backup(
        &self,
        limit: i32,
        resume: &str,
    ) -> Box<dyn Future<Item = crate::models::NdmpContextsBackupExtended, Error = Error>>;
    fn get_ndmp_contexts_backup_by_id(
        &self,
        ndmp_contexts_backup_id: &str,
    ) -> Box<dyn Future<Item = crate::models::NdmpContextsBackup, Error = Error>>;
    fn get_ndmp_contexts_bre(
        &self,
        limit: i32,
        resume: &str,
    ) -> Box<dyn Future<Item = crate::models::NdmpContextsBreExtended, Error = Error>>;
    fn get_ndmp_contexts_bre_by_id(
        &self,
        ndmp_contexts_bre_id: &str,
    ) -> Box<dyn Future<Item = crate::models::NdmpContextsBre, Error = Error>>;
    fn get_ndmp_contexts_restore(
        &self,
        limit: i32,
        resume: &str,
    ) -> Box<dyn Future<Item = crate::models::NdmpContextsBackupExtended, Error = Error>>;
    fn get_ndmp_contexts_restore_by_id(
        &self,
        ndmp_contexts_restore_id: &str,
    ) -> Box<dyn Future<Item = crate::models::NdmpContextsBackup, Error = Error>>;
    fn get_ndmp_diagnostics(
        &self,
    ) -> Box<dyn Future<Item = crate::models::NdmpDiagnostics, Error = Error>>;
    fn get_ndmp_dumpdate(
        &self,
        ndmp_dumpdate_id: &str,
        sort: &str,
        resume: &str,
        level: i32,
        limit: i32,
        path: &str,
        dir: &str,
    ) -> Box<dyn Future<Item = crate::models::NdmpDumpdates, Error = Error>>;
    fn get_ndmp_logs(
        &self,
        lnn: &str,
        page: i32,
        pagesize: i32,
    ) -> Box<dyn Future<Item = crate::models::NdmpLogs, Error = Error>>;
    fn get_ndmp_session(
        &self,
        ndmp_session_id: &str,
        lnn: &str,
    ) -> Box<dyn Future<Item = crate::models::NdmpSessions, Error = Error>>;
    fn get_ndmp_sessions(
        &self,
        consolidate: bool,
        node: &str,
        session: &str,
        limit: i32,
        resume: &str,
    ) -> Box<dyn Future<Item = crate::models::NdmpSessionsExtended, Error = Error>>;
    fn get_ndmp_settings_dmas(
        &self,
    ) -> Box<dyn Future<Item = crate::models::NdmpSettingsDmas, Error = Error>>;
    fn get_ndmp_settings_global(
        &self,
    ) -> Box<dyn Future<Item = crate::models::NdmpSettingsGlobal, Error = Error>>;
    fn get_ndmp_settings_preferred_ip(
        &self,
        ndmp_settings_preferred_ip_id: &str,
    ) -> Box<dyn Future<Item = crate::models::NdmpSettingsPreferredIps, Error = Error>>;
    fn get_ndmp_settings_variable(
        &self,
        ndmp_settings_variable_id: &str,
        path: &str,
        limit: i32,
        resume: &str,
    ) -> Box<dyn Future<Item = crate::models::NdmpSettingsVariables, Error = Error>>;
    fn get_ndmp_user(
        &self,
        ndmp_user_id: &str,
    ) -> Box<dyn Future<Item = crate::models::NdmpUsers, Error = Error>>;
    fn get_nfs_alias(
        &self,
        nfs_alias_id: &str,
        scope: &str,
        check: bool,
        zone: &str,
    ) -> Box<dyn Future<Item = crate::models::NfsAliases, Error = Error>>;
    fn get_nfs_check(
        &self,
        ignore_bad_paths: bool,
        ignore_bad_auth: bool,
        zone: &str,
        ignore_unresolvable_hosts: bool,
    ) -> Box<dyn Future<Item = crate::models::NfsCheckExtended, Error = Error>>;
    fn get_nfs_export(
        &self,
        nfs_export_id: &str,
        scope: &str,
        zone: &str,
    ) -> Box<dyn Future<Item = crate::models::NfsExports, Error = Error>>;
    fn get_nfs_exports_summary(
        &self,
        zone: &str,
    ) -> Box<dyn Future<Item = crate::models::NfsExportsSummary, Error = Error>>;
    fn get_nfs_log_level(
        &self,
    ) -> Box<dyn Future<Item = crate::models::NfsLogLevel, Error = Error>>;
    fn get_nfs_netgroup(
        &self,
        host: &str,
    ) -> Box<dyn Future<Item = crate::models::NfsNetgroup, Error = Error>>;
    fn get_nfs_nlm_locks(
        &self,
        sort: &str,
        created: &str,
        lin: &str,
        resume: &str,
        client: &str,
        limit: i32,
        client_id: &str,
        path: &str,
        dir: &str,
    ) -> Box<dyn Future<Item = crate::models::NfsNlmLocks, Error = Error>>;
    fn get_nfs_nlm_session(
        &self,
        nfs_nlm_session_id: &str,
        cluster_ip: &str,
        zone: &str,
    ) -> Box<dyn Future<Item = crate::models::NfsNlmSessions, Error = Error>>;
    fn get_nfs_nlm_sessions(
        &self,
        sort: &str,
        ip: &str,
        limit: i32,
        zone: &str,
        dir: &str,
    ) -> Box<dyn Future<Item = crate::models::NfsNlmSessionsExtended, Error = Error>>;
    fn get_nfs_nlm_waiters(
        &self,
        sort: &str,
        limit: i32,
        dir: &str,
        resume: &str,
    ) -> Box<dyn Future<Item = crate::models::NfsNlmWaiters, Error = Error>>;
    fn get_nfs_settings_export(
        &self,
        scope: &str,
        zone: &str,
    ) -> Box<dyn Future<Item = crate::models::NfsSettingsExport, Error = Error>>;
    fn get_nfs_settings_global(
        &self,
        scope: &str,
    ) -> Box<dyn Future<Item = crate::models::NfsSettingsGlobal, Error = Error>>;
    fn get_nfs_settings_zone(
        &self,
        zone: &str,
    ) -> Box<dyn Future<Item = crate::models::NfsSettingsZone, Error = Error>>;
    fn get_ntp_server(
        &self,
        ntp_server_id: &str,
    ) -> Box<dyn Future<Item = crate::models::NtpServers, Error = Error>>;
    fn get_ntp_settings(&self)
        -> Box<dyn Future<Item = crate::models::NtpSettings, Error = Error>>;
    fn get_smb_log_level(
        &self,
    ) -> Box<dyn Future<Item = crate::models::SmbLogLevel, Error = Error>>;
    fn get_smb_log_level_filter(
        &self,
        smb_log_level_filter_id: &str,
    ) -> Box<dyn Future<Item = crate::models::SmbLogLevelFilters, Error = Error>>;
    fn get_smb_openfiles(
        &self,
        sort: &str,
        limit: i32,
        dir: &str,
        resume: &str,
    ) -> Box<dyn Future<Item = crate::models::SmbOpenfiles, Error = Error>>;
    fn get_smb_sessions(
        &self,
        sort: &str,
        limit: i32,
        dir: &str,
        resume: &str,
    ) -> Box<dyn Future<Item = crate::models::SmbSessions, Error = Error>>;
    fn get_smb_settings_global(
        &self,
        scope: &str,
    ) -> Box<dyn Future<Item = crate::models::SmbSettingsGlobal, Error = Error>>;
    fn get_smb_settings_share(
        &self,
        scope: &str,
        zone: &str,
    ) -> Box<dyn Future<Item = crate::models::SmbSettingsShare, Error = Error>>;
    fn get_smb_share(
        &self,
        smb_share_id: &str,
        scope: &str,
        resolve_names: bool,
        zone: &str,
    ) -> Box<dyn Future<Item = crate::models::SmbShares, Error = Error>>;
    fn get_smb_shares_summary(
        &self,
        zone: &str,
    ) -> Box<dyn Future<Item = crate::models::SmbSharesSummary, Error = Error>>;
    fn get_snmp_settings(
        &self,
    ) -> Box<dyn Future<Item = crate::models::SnmpSettings, Error = Error>>;
    fn get_swift_account(
        &self,
        swift_account_id: &str,
        zone: &str,
    ) -> Box<dyn Future<Item = crate::models::SwiftAccounts, Error = Error>>;
    fn list_hdfs_proxyusers(
        &self,
        zone: &str,
    ) -> Box<dyn Future<Item = crate::models::HdfsProxyusers, Error = Error>>;
    fn list_hdfs_racks(
        &self,
        zone: &str,
    ) -> Box<dyn Future<Item = crate::models::HdfsRacksExtended, Error = Error>>;
    fn list_ndmp_settings_preferred_ips(
        &self,
        limit: i32,
        resume: &str,
    ) -> Box<dyn Future<Item = crate::models::NdmpSettingsPreferredIps, Error = Error>>;
    fn list_ndmp_users(
        &self,
    ) -> Box<dyn Future<Item = crate::models::NdmpUsersExtended, Error = Error>>;
    fn list_nfs_aliases(
        &self,
        sort: &str,
        zone: &str,
        resume: &str,
        limit: i32,
        check: bool,
        dir: &str,
    ) -> Box<dyn Future<Item = crate::models::NfsAliasesExtended, Error = Error>>;
    fn list_nfs_exports(
        &self,
        sort: &str,
        zone: &str,
        resume: &str,
        scope: &str,
        limit: i32,
        offset: i32,
        path: &str,
        check: bool,
        dir: &str,
    ) -> Box<dyn Future<Item = crate::models::NfsExportsExtended, Error = Error>>;
    fn list_ntp_servers(
        &self,
        sort: &str,
        limit: i32,
        dir: &str,
        resume: &str,
    ) -> Box<dyn Future<Item = crate::models::NtpServersExtended, Error = Error>>;
    fn list_smb_log_level_filters(
        &self,
        sort: &str,
        dir: &str,
        level: &str,
    ) -> Box<dyn Future<Item = crate::models::SmbLogLevelFilters, Error = Error>>;
    fn list_smb_shares(
        &self,
        sort: &str,
        zone: &str,
        resume: &str,
        resolve_names: bool,
        limit: i32,
        offset: i32,
        scope: &str,
        dir: &str,
    ) -> Box<dyn Future<Item = crate::models::SmbSharesExtended, Error = Error>>;
    fn list_swift_accounts(
        &self,
        zone: &str,
    ) -> Box<dyn Future<Item = crate::models::SwiftAccountsExtended, Error = Error>>;
    fn update_ftp_settings(
        &self,
        ftp_settings: crate::models::FtpSettingsExtended,
    ) -> Box<dyn Future<Item = (), Error = Error>>;
    fn update_hdfs_log_level(
        &self,
        hdfs_log_level: crate::models::HdfsLogLevel,
    ) -> Box<dyn Future<Item = (), Error = Error>>;
    fn update_hdfs_proxyuser(
        &self,
        hdfs_proxyuser: crate::models::Empty,
        hdfs_proxyuser_id: &str,
        zone: &str,
    ) -> Box<dyn Future<Item = (), Error = Error>>;
    fn update_hdfs_rack(
        &self,
        hdfs_rack: crate::models::HdfsRack,
        hdfs_rack_id: &str,
        zone: &str,
    ) -> Box<dyn Future<Item = (), Error = Error>>;
    fn update_hdfs_ranger_plugin_settings(
        &self,
        hdfs_ranger_plugin_settings: crate::models::HdfsRangerPluginSettingsSettings,
        zone: &str,
    ) -> Box<dyn Future<Item = (), Error = Error>>;
    fn update_hdfs_settings(
        &self,
        hdfs_settings: crate::models::HdfsSettingsSettings,
        zone: &str,
    ) -> Box<dyn Future<Item = (), Error = Error>>;
    fn update_http_settings(
        &self,
        http_settings: crate::models::HttpSettingsSettings,
    ) -> Box<dyn Future<Item = (), Error = Error>>;
    fn update_ndmp_diagnostics(
        &self,
        ndmp_diagnostics: crate::models::NdmpDiagnosticsDiagnostics,
    ) -> Box<dyn Future<Item = (), Error = Error>>;
    fn update_ndmp_settings_global(
        &self,
        ndmp_settings_global: crate::models::NdmpSettingsGlobalGlobal,
    ) -> Box<dyn Future<Item = (), Error = Error>>;
    fn update_ndmp_settings_preferred_ip(
        &self,
        ndmp_settings_preferred_ip: crate::models::NdmpSettingsPreferredIp,
        ndmp_settings_preferred_ip_id: &str,
    ) -> Box<dyn Future<Item = (), Error = Error>>;
    fn update_ndmp_settings_variable(
        &self,
        ndmp_settings_variable: crate::models::NdmpSettingsVariable,
        ndmp_settings_variable_id: &str,
        name: &str,
    ) -> Box<dyn Future<Item = (), Error = Error>>;
    fn update_ndmp_user(
        &self,
        ndmp_user: crate::models::NdmpUser,
        ndmp_user_id: &str,
    ) -> Box<dyn Future<Item = (), Error = Error>>;
    fn update_nfs_alias(
        &self,
        nfs_alias: crate::models::NfsAlias,
        nfs_alias_id: &str,
        zone: &str,
    ) -> Box<dyn Future<Item = (), Error = Error>>;
    fn update_nfs_export(
        &self,
        nfs_export: crate::models::NfsExport,
        nfs_export_id: &str,
        force: bool,
        ignore_unresolvable_hosts: bool,
        zone: &str,
        ignore_conflicts: bool,
        ignore_bad_paths: bool,
        ignore_bad_auth: bool,
    ) -> Box<dyn Future<Item = (), Error = Error>>;
    fn update_nfs_log_level(
        &self,
        nfs_log_level: crate::models::NfsLogLevel,
    ) -> Box<dyn Future<Item = (), Error = Error>>;
    fn update_nfs_netgroup(
        &self,
        nfs_netgroup: crate::models::NfsNetgroup,
        host: &str,
    ) -> Box<dyn Future<Item = (), Error = Error>>;
    fn update_nfs_settings_export(
        &self,
        nfs_settings_export: crate::models::NfsSettingsExportSettings,
        zone: &str,
    ) -> Box<dyn Future<Item = (), Error = Error>>;
    fn update_nfs_settings_global(
        &self,
        nfs_settings_global: crate::models::NfsSettingsGlobalSettings,
        scope: &str,
    ) -> Box<dyn Future<Item = (), Error = Error>>;
    fn update_nfs_settings_zone(
        &self,
        nfs_settings_zone: crate::models::NfsSettingsZoneSettings,
        zone: &str,
    ) -> Box<dyn Future<Item = (), Error = Error>>;
    fn update_ntp_server(
        &self,
        ntp_server: crate::models::NtpServer,
        ntp_server_id: &str,
    ) -> Box<dyn Future<Item = (), Error = Error>>;
    fn update_ntp_settings(
        &self,
        ntp_settings: crate::models::NtpSettingsSettings,
    ) -> Box<dyn Future<Item = (), Error = Error>>;
    fn update_smb_log_level(
        &self,
        smb_log_level: crate::models::SmbLogLevel,
    ) -> Box<dyn Future<Item = (), Error = Error>>;
    fn update_smb_settings_global(
        &self,
        smb_settings_global: crate::models::SmbSettingsGlobalExtended,
    ) -> Box<dyn Future<Item = (), Error = Error>>;
    fn update_smb_settings_share(
        &self,
        smb_settings_share: crate::models::SmbSettingsShareExtended,
        zone: &str,
    ) -> Box<dyn Future<Item = (), Error = Error>>;
    fn update_smb_share(
        &self,
        smb_share: crate::models::SmbShare,
        smb_share_id: &str,
        zone: &str,
    ) -> Box<dyn Future<Item = (), Error = Error>>;
    fn update_snmp_settings(
        &self,
        snmp_settings: crate::models::SnmpSettingsExtended,
    ) -> Box<dyn Future<Item = (), Error = Error>>;
    fn update_swift_account(
        &self,
        swift_account: crate::models::SwiftAccount,
        swift_account_id: &str,
        zone: &str,
    ) -> Box<dyn Future<Item = (), Error = Error>>;
}

impl<C: hyper::client::connect::Connect + 'static> ProtocolsApi for ProtocolsApiClient<C> {
    fn create_hdfs_proxyuser(
        &self,
        hdfs_proxyuser: crate::models::HdfsProxyuserCreateParams,
        zone: &str,
    ) -> Box<dyn Future<Item = crate::models::CreateResponse, Error = Error>> {
        let q = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("zone", &zone.to_string())
            .finish();
        let uri_str = format!(
            "{}/platform/1/protocols/hdfs/proxyusers?{}",
            self.configuration.base_path, q
        );

        query(
            self.configuration.borrow(),
            &uri_str,
            &hdfs_proxyuser,
            hyper::Method::POST,
        )
    }

    fn create_hdfs_rack(
        &self,
        hdfs_rack: crate::models::HdfsRackCreateParams,
        zone: &str,
    ) -> Box<dyn Future<Item = crate::models::CreateResponse, Error = Error>> {
        let q = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("zone", &zone.to_string())
            .finish();
        let uri_str = format!(
            "{}/platform/1/protocols/hdfs/racks?{}",
            self.configuration.base_path, q
        );

        query(
            self.configuration.borrow(),
            &uri_str,
            &hdfs_rack,
            hyper::Method::POST,
        )
    }

    fn create_ndmp_settings_preferred_ip(
        &self,
        ndmp_settings_preferred_ip: crate::models::NdmpSettingsPreferredIpCreateParams,
    ) -> Box<dyn Future<Item = crate::models::Empty, Error = Error>> {
        let uri_str = format!(
            "{}/platform/4/protocols/ndmp/settings/preferred-ips",
            self.configuration.base_path
        );

        query(
            self.configuration.borrow(),
            &uri_str,
            &ndmp_settings_preferred_ip,
            hyper::Method::POST,
        )
    }

    fn create_ndmp_settings_variable(
        &self,
        ndmp_settings_variable: crate::models::NdmpSettingsVariableCreateParams,
        ndmp_settings_variable_id: &str,
    ) -> Box<dyn Future<Item = crate::models::Empty, Error = Error>> {
        let uri_str = format!(
            "{}/platform/3/protocols/ndmp/settings/variables/{NdmpSettingsVariableId}",
            self.configuration.base_path,
            NdmpSettingsVariableId = ndmp_settings_variable_id
        );

        query(
            self.configuration.borrow(),
            &uri_str,
            &ndmp_settings_variable,
            hyper::Method::POST,
        )
    }

    fn create_ndmp_user(
        &self,
        ndmp_user: crate::models::NdmpUserCreateParams,
    ) -> Box<dyn Future<Item = crate::models::Empty, Error = Error>> {
        let uri_str = format!(
            "{}/platform/3/protocols/ndmp/users",
            self.configuration.base_path
        );

        query(
            self.configuration.borrow(),
            &uri_str,
            &ndmp_user,
            hyper::Method::POST,
        )
    }

    fn create_nfs_alias(
        &self,
        nfs_alias: crate::models::NfsAliasCreateParams,
        zone: &str,
    ) -> Box<dyn Future<Item = crate::models::CreateNfsAliasResponse, Error = Error>> {
        let q = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("zone", &zone.to_string())
            .finish();
        let uri_str = format!(
            "{}/platform/2/protocols/nfs/aliases?{}",
            self.configuration.base_path, q
        );

        query(
            self.configuration.borrow(),
            &uri_str,
            &nfs_alias,
            hyper::Method::POST,
        )
    }

    fn create_nfs_export(
        &self,
        nfs_export: crate::models::NfsExportCreateParams,
        force: bool,
        ignore_unresolvable_hosts: bool,
        zone: &str,
        ignore_conflicts: bool,
        ignore_bad_paths: bool,
        ignore_bad_auth: bool,
    ) -> Box<dyn Future<Item = crate::models::CreateQuotaReportResponse, Error = Error>> {
        let q = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("force", &force.to_string())
            .append_pair(
                "ignore_unresolvable_hosts",
                &ignore_unresolvable_hosts.to_string(),
            )
            .append_pair("zone", &zone.to_string())
            .append_pair("ignore_conflicts", &ignore_conflicts.to_string())
            .append_pair("ignore_bad_paths", &ignore_bad_paths.to_string())
            .append_pair("ignore_bad_auth", &ignore_bad_auth.to_string())
            .finish();
        let uri_str = format!(
            "{}/platform/4/protocols/nfs/exports?{}",
            self.configuration.base_path, q
        );

        query(
            self.configuration.borrow(),
            &uri_str,
            &nfs_export,
            hyper::Method::POST,
        )
    }

    fn create_nfs_netgroup_check_item(
        &self,
        nfs_netgroup_check_item: crate::models::Empty,
        host: &str,
    ) -> Box<dyn Future<Item = crate::models::Empty, Error = Error>> {
        let q = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("host", &host.to_string())
            .finish();
        let uri_str = format!(
            "{}/platform/3/protocols/nfs/netgroup/check?{}",
            self.configuration.base_path, q
        );

        query(
            self.configuration.borrow(),
            &uri_str,
            &nfs_netgroup_check_item,
            hyper::Method::POST,
        )
    }

    fn create_nfs_netgroup_flush_item(
        &self,
        nfs_netgroup_flush_item: crate::models::Empty,
        host: &str,
    ) -> Box<dyn Future<Item = crate::models::Empty, Error = Error>> {
        let q = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("host", &host.to_string())
            .finish();
        let uri_str = format!(
            "{}/platform/3/protocols/nfs/netgroup/flush?{}",
            self.configuration.base_path, q
        );

        query(
            self.configuration.borrow(),
            &uri_str,
            &nfs_netgroup_flush_item,
            hyper::Method::POST,
        )
    }

    fn create_nfs_nlm_sessions_check_item(
        &self,
        nfs_nlm_sessions_check_item: crate::models::Empty,
        cluster_ip: &str,
        zone: &str,
    ) -> Box<dyn Future<Item = crate::models::CreateNfsNlmSessionsCheckItemResponse, Error = Error>>
    {
        let q = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("cluster_ip", &cluster_ip.to_string())
            .append_pair("zone", &zone.to_string())
            .finish();
        let uri_str = format!(
            "{}/platform/3/protocols/nfs/nlm/sessions-check?{}",
            self.configuration.base_path, q
        );

        query(
            self.configuration.borrow(),
            &uri_str,
            &nfs_nlm_sessions_check_item,
            hyper::Method::POST,
        )
    }

    fn create_nfs_reload_item(
        &self,
        nfs_reload_item: crate::models::Empty,
        zone: &str,
    ) -> Box<dyn Future<Item = crate::models::Empty, Error = Error>> {
        let q = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("zone", &zone.to_string())
            .finish();
        let uri_str = format!(
            "{}/platform/3/protocols/nfs/reload?{}",
            self.configuration.base_path, q
        );

        query(
            self.configuration.borrow(),
            &uri_str,
            &nfs_reload_item,
            hyper::Method::POST,
        )
    }

    fn create_ntp_server(
        &self,
        ntp_server: crate::models::NtpServerCreateParams,
    ) -> Box<dyn Future<Item = crate::models::Empty, Error = Error>> {
        let uri_str = format!(
            "{}/platform/3/protocols/ntp/servers",
            self.configuration.base_path
        );

        query(
            self.configuration.borrow(),
            &uri_str,
            &ntp_server,
            hyper::Method::POST,
        )
    }

    fn create_smb_log_level_filter(
        &self,
        smb_log_level_filter: crate::models::SmbLogLevelFilter,
    ) -> Box<dyn Future<Item = crate::models::CreateAuthRefreshItemResponse, Error = Error>> {
        let uri_str = format!(
            "{}/platform/3/protocols/smb/log-level/filters",
            self.configuration.base_path
        );

        query(
            self.configuration.borrow(),
            &uri_str,
            &smb_log_level_filter,
            hyper::Method::POST,
        )
    }

    fn create_smb_share(
        &self,
        smb_share: crate::models::SmbShareCreateParams,
        zone: &str,
    ) -> Box<dyn Future<Item = crate::models::CreateResponse, Error = Error>> {
        let q = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("zone", &zone.to_string())
            .finish();
        let uri_str = format!(
            "{}/platform/4/protocols/smb/shares?{}",
            self.configuration.base_path, q
        );

        query(
            self.configuration.borrow(),
            &uri_str,
            &smb_share,
            hyper::Method::POST,
        )
    }

    fn create_swift_account(
        &self,
        swift_account: crate::models::SwiftAccount,
        zone: &str,
    ) -> Box<dyn Future<Item = crate::models::Empty, Error = Error>> {
        let q = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("zone", &zone.to_string())
            .finish();
        let uri_str = format!(
            "{}/platform/3/protocols/swift/accounts?{}",
            self.configuration.base_path, q
        );

        query(
            self.configuration.borrow(),
            &uri_str,
            &swift_account,
            hyper::Method::POST,
        )
    }

    fn delete_hdfs_proxyuser(
        &self,
        hdfs_proxyuser_id: &str,
        zone: &str,
    ) -> Box<dyn Future<Item = (), Error = Error>> {
        let q = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("zone", &zone.to_string())
            .finish();
        let uri_str = format!(
            "{}/platform/1/protocols/hdfs/proxyusers/{HdfsProxyuserId}?{}",
            self.configuration.base_path,
            q,
            HdfsProxyuserId = hdfs_proxyuser_id
        );
        query(
            self.configuration.borrow(),
            &uri_str,
            &"",
            hyper::Method::DELETE,
        )
    }

    fn delete_hdfs_rack(
        &self,
        hdfs_rack_id: &str,
        zone: &str,
    ) -> Box<dyn Future<Item = (), Error = Error>> {
        let q = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("zone", &zone.to_string())
            .finish();
        let uri_str = format!(
            "{}/platform/1/protocols/hdfs/racks/{HdfsRackId}?{}",
            self.configuration.base_path,
            q,
            HdfsRackId = hdfs_rack_id
        );
        query(
            self.configuration.borrow(),
            &uri_str,
            &"",
            hyper::Method::DELETE,
        )
    }

    fn delete_ndmp_contexts_backup_by_id(
        &self,
        ndmp_contexts_backup_id: &str,
    ) -> Box<dyn Future<Item = (), Error = Error>> {
        let uri_str = format!(
            "{}/platform/3/protocols/ndmp/contexts/backup/{NdmpContextsBackupId}",
            self.configuration.base_path,
            NdmpContextsBackupId = ndmp_contexts_backup_id
        );
        query(
            self.configuration.borrow(),
            &uri_str,
            &"",
            hyper::Method::DELETE,
        )
    }

    fn delete_ndmp_contexts_bre_by_id(
        &self,
        ndmp_contexts_bre_id: &str,
    ) -> Box<dyn Future<Item = (), Error = Error>> {
        let uri_str = format!(
            "{}/platform/3/protocols/ndmp/contexts/bre/{NdmpContextsBreId}",
            self.configuration.base_path,
            NdmpContextsBreId = ndmp_contexts_bre_id
        );
        query(
            self.configuration.borrow(),
            &uri_str,
            &"",
            hyper::Method::DELETE,
        )
    }

    fn delete_ndmp_contexts_restore_by_id(
        &self,
        ndmp_contexts_restore_id: &str,
    ) -> Box<dyn Future<Item = (), Error = Error>> {
        let uri_str = format!(
            "{}/platform/3/protocols/ndmp/contexts/restore/{NdmpContextsRestoreId}",
            self.configuration.base_path,
            NdmpContextsRestoreId = ndmp_contexts_restore_id
        );
        query(
            self.configuration.borrow(),
            &uri_str,
            &"",
            hyper::Method::DELETE,
        )
    }

    fn delete_ndmp_dumpdate(
        &self,
        ndmp_dumpdate_id: &str,
        level: i32,
    ) -> Box<dyn Future<Item = (), Error = Error>> {
        let q = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("level", &level.to_string())
            .finish();
        let uri_str = format!(
            "{}/platform/3/protocols/ndmp/dumpdates/{NdmpDumpdateId}?{}",
            self.configuration.base_path,
            q,
            NdmpDumpdateId = ndmp_dumpdate_id
        );
        query(
            self.configuration.borrow(),
            &uri_str,
            &"",
            hyper::Method::DELETE,
        )
    }

    fn delete_ndmp_session(
        &self,
        ndmp_session_id: &str,
        lnn: &str,
    ) -> Box<dyn Future<Item = (), Error = Error>> {
        let q = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("lnn", &lnn.to_string())
            .finish();
        let uri_str = format!(
            "{}/platform/3/protocols/ndmp/sessions/{NdmpSessionId}?{}",
            self.configuration.base_path,
            q,
            NdmpSessionId = ndmp_session_id
        );
        query(
            self.configuration.borrow(),
            &uri_str,
            &"",
            hyper::Method::DELETE,
        )
    }

    fn delete_ndmp_settings_preferred_ip(
        &self,
        ndmp_settings_preferred_ip_id: &str,
    ) -> Box<dyn Future<Item = (), Error = Error>> {
        let uri_str = format!(
            "{}/platform/4/protocols/ndmp/settings/preferred-ips/{NdmpSettingsPreferredIpId}",
            self.configuration.base_path,
            NdmpSettingsPreferredIpId = ndmp_settings_preferred_ip_id
        );
        query(
            self.configuration.borrow(),
            &uri_str,
            &"",
            hyper::Method::DELETE,
        )
    }

    fn delete_ndmp_settings_variable(
        &self,
        ndmp_settings_variable_id: &str,
        name: &str,
    ) -> Box<dyn Future<Item = (), Error = Error>> {
        let q = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("name", &name.to_string())
            .finish();
        let uri_str = format!(
            "{}/platform/3/protocols/ndmp/settings/variables/{NdmpSettingsVariableId}?{}",
            self.configuration.base_path,
            q,
            NdmpSettingsVariableId = ndmp_settings_variable_id
        );
        query(
            self.configuration.borrow(),
            &uri_str,
            &"",
            hyper::Method::DELETE,
        )
    }

    fn delete_ndmp_user(&self, ndmp_user_id: &str) -> Box<dyn Future<Item = (), Error = Error>> {
        let uri_str = format!(
            "{}/platform/3/protocols/ndmp/users/{NdmpUserId}",
            self.configuration.base_path,
            NdmpUserId = ndmp_user_id
        );
        query(
            self.configuration.borrow(),
            &uri_str,
            &"",
            hyper::Method::DELETE,
        )
    }

    fn delete_nfs_alias(
        &self,
        nfs_alias_id: &str,
        zone: &str,
    ) -> Box<dyn Future<Item = (), Error = Error>> {
        let q = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("zone", &zone.to_string())
            .finish();
        let uri_str = format!(
            "{}/platform/2/protocols/nfs/aliases/{NfsAliasId}?{}",
            self.configuration.base_path,
            q,
            NfsAliasId = nfs_alias_id
        );
        query(
            self.configuration.borrow(),
            &uri_str,
            &"",
            hyper::Method::DELETE,
        )
    }

    fn delete_nfs_export(
        &self,
        nfs_export_id: &str,
        zone: &str,
    ) -> Box<dyn Future<Item = (), Error = Error>> {
        let q = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("zone", &zone.to_string())
            .finish();
        let uri_str = format!(
            "{}/platform/4/protocols/nfs/exports/{NfsExportId}?{}",
            self.configuration.base_path,
            q,
            NfsExportId = nfs_export_id
        );
        query(
            self.configuration.borrow(),
            &uri_str,
            &"",
            hyper::Method::DELETE,
        )
    }

    fn delete_nfs_nlm_session(
        &self,
        nfs_nlm_session_id: &str,
        cluster_ip: &str,
        zone: &str,
        refresh: bool,
    ) -> Box<dyn Future<Item = (), Error = Error>> {
        let q = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("cluster_ip", &cluster_ip.to_string())
            .append_pair("zone", &zone.to_string())
            .append_pair("refresh", &refresh.to_string())
            .finish();
        let uri_str = format!(
            "{}/platform/3/protocols/nfs/nlm/sessions/{NfsNlmSessionId}?{}",
            self.configuration.base_path,
            q,
            NfsNlmSessionId = nfs_nlm_session_id
        );
        query(
            self.configuration.borrow(),
            &uri_str,
            &"",
            hyper::Method::DELETE,
        )
    }

    fn delete_ntp_server(&self, ntp_server_id: &str) -> Box<dyn Future<Item = (), Error = Error>> {
        let uri_str = format!(
            "{}/platform/3/protocols/ntp/servers/{NtpServerId}",
            self.configuration.base_path,
            NtpServerId = ntp_server_id
        );
        query(
            self.configuration.borrow(),
            &uri_str,
            &"",
            hyper::Method::DELETE,
        )
    }

    fn delete_ntp_servers(&self) -> Box<dyn Future<Item = (), Error = Error>> {
        let uri_str = format!(
            "{}/platform/3/protocols/ntp/servers",
            self.configuration.base_path
        );
        query(
            self.configuration.borrow(),
            &uri_str,
            &"",
            hyper::Method::DELETE,
        )
    }

    fn delete_smb_log_level_filter(
        &self,
        smb_log_level_filter_id: &str,
    ) -> Box<dyn Future<Item = (), Error = Error>> {
        let uri_str = format!(
            "{}/platform/3/protocols/smb/log-level/filters/{SmbLogLevelFilterId}",
            self.configuration.base_path,
            SmbLogLevelFilterId = smb_log_level_filter_id
        );
        query(
            self.configuration.borrow(),
            &uri_str,
            &"",
            hyper::Method::DELETE,
        )
    }

    fn delete_smb_log_level_filters(
        &self,
        level: &str,
    ) -> Box<dyn Future<Item = (), Error = Error>> {
        let q = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("level", &level.to_string())
            .finish();
        let uri_str = format!(
            "{}/platform/3/protocols/smb/log-level/filters?{}",
            self.configuration.base_path, q
        );
        query(
            self.configuration.borrow(),
            &uri_str,
            &"",
            hyper::Method::DELETE,
        )
    }

    fn delete_smb_openfile(
        &self,
        smb_openfile_id: &str,
    ) -> Box<dyn Future<Item = (), Error = Error>> {
        let uri_str = format!(
            "{}/platform/1/protocols/smb/openfiles/{SmbOpenfileId}",
            self.configuration.base_path,
            SmbOpenfileId = smb_openfile_id
        );
        query(
            self.configuration.borrow(),
            &uri_str,
            &"",
            hyper::Method::DELETE,
        )
    }

    fn delete_smb_session(
        &self,
        smb_session_id: &str,
    ) -> Box<dyn Future<Item = (), Error = Error>> {
        let uri_str = format!(
            "{}/platform/1/protocols/smb/sessions/{SmbSessionId}",
            self.configuration.base_path,
            SmbSessionId = smb_session_id
        );
        query(
            self.configuration.borrow(),
            &uri_str,
            &"",
            hyper::Method::DELETE,
        )
    }

    fn delete_smb_sessions_computer_user(
        &self,
        smb_sessions_computer_user: &str,
        computer: &str,
    ) -> Box<dyn Future<Item = (), Error = Error>> {
        let uri_str = format!(
            "{}/platform/1/protocols/smb/sessions/{Computer}/{SmbSessionsComputerUser}",
            self.configuration.base_path,
            SmbSessionsComputerUser = smb_sessions_computer_user,
            Computer = computer
        );
        query(
            self.configuration.borrow(),
            &uri_str,
            &"",
            hyper::Method::DELETE,
        )
    }

    fn delete_smb_share(
        &self,
        smb_share_id: &str,
        zone: &str,
    ) -> Box<dyn Future<Item = (), Error = Error>> {
        let q = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("zone", &zone.to_string())
            .finish();
        let uri_str = format!(
            "{}/platform/4/protocols/smb/shares/{SmbShareId}?{}",
            self.configuration.base_path,
            q,
            SmbShareId = smb_share_id
        );
        query(
            self.configuration.borrow(),
            &uri_str,
            &"",
            hyper::Method::DELETE,
        )
    }

    fn delete_smb_shares(&self) -> Box<dyn Future<Item = (), Error = Error>> {
        let uri_str = format!(
            "{}/platform/4/protocols/smb/shares",
            self.configuration.base_path
        );
        query(
            self.configuration.borrow(),
            &uri_str,
            &"",
            hyper::Method::DELETE,
        )
    }

    fn delete_swift_account(
        &self,
        swift_account_id: &str,
        zone: &str,
    ) -> Box<dyn Future<Item = (), Error = Error>> {
        let q = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("zone", &zone.to_string())
            .finish();
        let uri_str = format!(
            "{}/platform/3/protocols/swift/accounts/{SwiftAccountId}?{}",
            self.configuration.base_path,
            q,
            SwiftAccountId = swift_account_id
        );
        query(
            self.configuration.borrow(),
            &uri_str,
            &"",
            hyper::Method::DELETE,
        )
    }

    fn get_ftp_settings(
        &self,
    ) -> Box<dyn Future<Item = crate::models::FtpSettings, Error = Error>> {
        let uri_str = format!(
            "{}/platform/3/protocols/ftp/settings",
            self.configuration.base_path
        );

        //let parsed: Result<crate::models::FtpSettings, _> = serde_json::from_slice(&body);
        query(
            self.configuration.borrow(),
            &uri_str,
            &"",
            hyper::Method::GET,
        )
    }

    fn get_hdfs_log_level(
        &self,
    ) -> Box<dyn Future<Item = crate::models::HdfsLogLevel, Error = Error>> {
        let uri_str = format!(
            "{}/platform/3/protocols/hdfs/log-level",
            self.configuration.base_path
        );

        //let parsed: Result<crate::models::HdfsLogLevel, _> = serde_json::from_slice(&body);
        query(
            self.configuration.borrow(),
            &uri_str,
            &"",
            hyper::Method::GET,
        )
    }

    fn get_hdfs_proxyuser(
        &self,
        hdfs_proxyuser_id: &str,
        zone: &str,
    ) -> Box<dyn Future<Item = crate::models::HdfsProxyusers, Error = Error>> {
        let q = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("zone", &zone.to_string())
            .finish();
        let uri_str = format!(
            "{}/platform/1/protocols/hdfs/proxyusers/{HdfsProxyuserId}?{}",
            self.configuration.base_path,
            q,
            HdfsProxyuserId = hdfs_proxyuser_id
        );

        query(
            self.configuration.borrow(),
            &uri_str,
            &"",
            hyper::Method::GET,
        )
    }

    fn get_hdfs_rack(
        &self,
        hdfs_rack_id: &str,
        zone: &str,
    ) -> Box<dyn Future<Item = crate::models::HdfsRacks, Error = Error>> {
        let q = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("zone", &zone.to_string())
            .finish();
        let uri_str = format!(
            "{}/platform/1/protocols/hdfs/racks/{HdfsRackId}?{}",
            self.configuration.base_path,
            q,
            HdfsRackId = hdfs_rack_id
        );

        query(
            self.configuration.borrow(),
            &uri_str,
            &"",
            hyper::Method::GET,
        )
    }

    fn get_hdfs_ranger_plugin_settings(
        &self,
        zone: &str,
    ) -> Box<dyn Future<Item = crate::models::HdfsRangerPluginSettings, Error = Error>> {
        let q = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("zone", &zone.to_string())
            .finish();
        let uri_str = format!(
            "{}/platform/4/protocols/hdfs/ranger-plugin/settings?{}",
            self.configuration.base_path, q
        );

        query(
            self.configuration.borrow(),
            &uri_str,
            &"",
            hyper::Method::GET,
        )
    }

    fn get_hdfs_settings(
        &self,
        zone: &str,
    ) -> Box<dyn Future<Item = crate::models::HdfsSettings, Error = Error>> {
        let q = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("zone", &zone.to_string())
            .finish();
        let uri_str = format!(
            "{}/platform/4/protocols/hdfs/settings?{}",
            self.configuration.base_path, q
        );

        query(
            self.configuration.borrow(),
            &uri_str,
            &"",
            hyper::Method::GET,
        )
    }

    fn get_http_settings(
        &self,
    ) -> Box<dyn Future<Item = crate::models::HttpSettings, Error = Error>> {
        let uri_str = format!(
            "{}/platform/3/protocols/http/settings",
            self.configuration.base_path
        );

        query(
            self.configuration.borrow(),
            &uri_str,
            &"",
            hyper::Method::GET,
        )
    }

    fn get_ndmp_contexts_backup(
        &self,
        limit: i32,
        resume: &str,
    ) -> Box<dyn Future<Item = crate::models::NdmpContextsBackupExtended, Error = Error>> {
        let q = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("limit", &limit.to_string())
            .append_pair("resume", &resume.to_string())
            .finish();
        let uri_str = format!(
            "{}/platform/3/protocols/ndmp/contexts/backup?{}",
            self.configuration.base_path, q
        );

        query(
            self.configuration.borrow(),
            &uri_str,
            &"",
            hyper::Method::GET,
        )
    }

    fn get_ndmp_contexts_backup_by_id(
        &self,
        ndmp_contexts_backup_id: &str,
    ) -> Box<dyn Future<Item = crate::models::NdmpContextsBackup, Error = Error>> {
        let uri_str = format!(
            "{}/platform/3/protocols/ndmp/contexts/backup/{NdmpContextsBackupId}",
            self.configuration.base_path,
            NdmpContextsBackupId = ndmp_contexts_backup_id
        );

        query(
            self.configuration.borrow(),
            &uri_str,
            &"",
            hyper::Method::GET,
        )
    }

    fn get_ndmp_contexts_bre(
        &self,
        limit: i32,
        resume: &str,
    ) -> Box<dyn Future<Item = crate::models::NdmpContextsBreExtended, Error = Error>> {
        let q = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("limit", &limit.to_string())
            .append_pair("resume", &resume.to_string())
            .finish();
        let uri_str = format!(
            "{}/platform/3/protocols/ndmp/contexts/bre?{}",
            self.configuration.base_path, q
        );

        query(
            self.configuration.borrow(),
            &uri_str,
            &"",
            hyper::Method::GET,
        )
    }

    fn get_ndmp_contexts_bre_by_id(
        &self,
        ndmp_contexts_bre_id: &str,
    ) -> Box<dyn Future<Item = crate::models::NdmpContextsBre, Error = Error>> {
        let uri_str = format!(
            "{}/platform/3/protocols/ndmp/contexts/bre/{NdmpContextsBreId}",
            self.configuration.base_path,
            NdmpContextsBreId = ndmp_contexts_bre_id
        );

        query(
            self.configuration.borrow(),
            &uri_str,
            &"",
            hyper::Method::GET,
        )
    }

    fn get_ndmp_contexts_restore(
        &self,
        limit: i32,
        resume: &str,
    ) -> Box<dyn Future<Item = crate::models::NdmpContextsBackupExtended, Error = Error>> {
        let q = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("limit", &limit.to_string())
            .append_pair("resume", &resume.to_string())
            .finish();
        let uri_str = format!(
            "{}/platform/3/protocols/ndmp/contexts/restore?{}",
            self.configuration.base_path, q
        );

        query(
            self.configuration.borrow(),
            &uri_str,
            &"",
            hyper::Method::GET,
        )
    }

    fn get_ndmp_contexts_restore_by_id(
        &self,
        ndmp_contexts_restore_id: &str,
    ) -> Box<dyn Future<Item = crate::models::NdmpContextsBackup, Error = Error>> {
        let uri_str = format!(
            "{}/platform/3/protocols/ndmp/contexts/restore/{NdmpContextsRestoreId}",
            self.configuration.base_path,
            NdmpContextsRestoreId = ndmp_contexts_restore_id
        );

        query(
            self.configuration.borrow(),
            &uri_str,
            &"",
            hyper::Method::GET,
        )
    }

    fn get_ndmp_diagnostics(
        &self,
    ) -> Box<dyn Future<Item = crate::models::NdmpDiagnostics, Error = Error>> {
        let uri_str = format!(
            "{}/platform/3/protocols/ndmp/diagnostics",
            self.configuration.base_path
        );

        query(
            self.configuration.borrow(),
            &uri_str,
            &"",
            hyper::Method::GET,
        )
    }

    fn get_ndmp_dumpdate(
        &self,
        ndmp_dumpdate_id: &str,
        sort: &str,
        resume: &str,
        level: i32,
        limit: i32,
        path: &str,
        dir: &str,
    ) -> Box<dyn Future<Item = crate::models::NdmpDumpdates, Error = Error>> {
        let q = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("sort", &sort.to_string())
            .append_pair("resume", &resume.to_string())
            .append_pair("level", &level.to_string())
            .append_pair("limit", &limit.to_string())
            .append_pair("path", &path.to_string())
            .append_pair("dir", &dir.to_string())
            .finish();
        let uri_str = format!(
            "{}/platform/3/protocols/ndmp/dumpdates/{NdmpDumpdateId}?{}",
            self.configuration.base_path,
            q,
            NdmpDumpdateId = ndmp_dumpdate_id
        );

        //let parsed: Result<crate::models::NdmpDumpdates, _> = serde_json::from_slice(&body);
        query(
            self.configuration.borrow(),
            &uri_str,
            &"",
            hyper::Method::GET,
        )
    }

    fn get_ndmp_logs(
        &self,
        lnn: &str,
        page: i32,
        pagesize: i32,
    ) -> Box<dyn Future<Item = crate::models::NdmpLogs, Error = Error>> {
        let q = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("lnn", &lnn.to_string())
            .append_pair("page", &page.to_string())
            .append_pair("pagesize", &pagesize.to_string())
            .finish();
        let uri_str = format!(
            "{}/platform/3/protocols/ndmp/logs?{}",
            self.configuration.base_path, q
        );

        //let parsed: Result<crate::models::NdmpLogs, _> = serde_json::from_slice(&body);
        query(
            self.configuration.borrow(),
            &uri_str,
            &"",
            hyper::Method::GET,
        )
    }

    fn get_ndmp_session(
        &self,
        ndmp_session_id: &str,
        lnn: &str,
    ) -> Box<dyn Future<Item = crate::models::NdmpSessions, Error = Error>> {
        let q = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("lnn", &lnn.to_string())
            .finish();
        let uri_str = format!(
            "{}/platform/3/protocols/ndmp/sessions/{NdmpSessionId}?{}",
            self.configuration.base_path,
            q,
            NdmpSessionId = ndmp_session_id
        );

        //       let parsed: Result<crate::models::NdmpSessions, _> = serde_json::from_slice(&body);
        query(
            self.configuration.borrow(),
            &uri_str,
            &"",
            hyper::Method::GET,
        )
    }

    fn get_ndmp_sessions(
        &self,
        consolidate: bool,
        node: &str,
        session: &str,
        limit: i32,
        resume: &str,
    ) -> Box<dyn Future<Item = crate::models::NdmpSessionsExtended, Error = Error>> {
        let q = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("consolidate", &consolidate.to_string())
            .append_pair("node", &node.to_string())
            .append_pair("session", &session.to_string())
            .append_pair("limit", &limit.to_string())
            .append_pair("resume", &resume.to_string())
            .finish();
        let uri_str = format!(
            "{}/platform/3/protocols/ndmp/sessions?{}",
            self.configuration.base_path, q
        );

        //let parsed: Result<crate::models::NdmpSessionsExtended, _> = serde_json::from_slice(&body);
        query(
            self.configuration.borrow(),
            &uri_str,
            &"",
            hyper::Method::GET,
        )
    }

    fn get_ndmp_settings_dmas(
        &self,
    ) -> Box<dyn Future<Item = crate::models::NdmpSettingsDmas, Error = Error>> {
        let uri_str = format!(
            "{}/platform/3/protocols/ndmp/settings/dmas",
            self.configuration.base_path
        );

        //let parsed: Result<crate::models::NdmpSettingsDmas, _> = serde_json::from_slice(&body);
        query(
            self.configuration.borrow(),
            &uri_str,
            &"",
            hyper::Method::GET,
        )
    }

    fn get_ndmp_settings_global(
        &self,
    ) -> Box<dyn Future<Item = crate::models::NdmpSettingsGlobal, Error = Error>> {
        let uri_str = format!(
            "{}/platform/3/protocols/ndmp/settings/global",
            self.configuration.base_path
        );

        //let parsed: Result<crate::models::NdmpSettingsGlobal, _> = serde_json::from_slice(&body);
        query(
            self.configuration.borrow(),
            &uri_str,
            &"",
            hyper::Method::GET,
        )
    }

    fn get_ndmp_settings_preferred_ip(
        &self,
        ndmp_settings_preferred_ip_id: &str,
    ) -> Box<dyn Future<Item = crate::models::NdmpSettingsPreferredIps, Error = Error>> {
        let uri_str = format!(
            "{}/platform/4/protocols/ndmp/settings/preferred-ips/{NdmpSettingsPreferredIpId}",
            self.configuration.base_path,
            NdmpSettingsPreferredIpId = ndmp_settings_preferred_ip_id
        );

        //let parsed: Result<crate::models::NdmpSettingsPreferredIps, _> =
        //   serde_json::from_slice(&body);
        query(
            self.configuration.borrow(),
            &uri_str,
            &"",
            hyper::Method::GET,
        )
    }

    fn get_ndmp_settings_variable(
        &self,
        ndmp_settings_variable_id: &str,
        path: &str,
        limit: i32,
        resume: &str,
    ) -> Box<dyn Future<Item = crate::models::NdmpSettingsVariables, Error = Error>> {
        let q = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("path", &path.to_string())
            .append_pair("limit", &limit.to_string())
            .append_pair("resume", &resume.to_string())
            .finish();
        let uri_str = format!(
            "{}/platform/3/protocols/ndmp/settings/variables/{NdmpSettingsVariableId}?{}",
            self.configuration.base_path,
            q,
            NdmpSettingsVariableId = ndmp_settings_variable_id
        );

        //        let parsed: Result<crate::models::NdmpSettingsVariables, _> = serde_json::from_slice(&body);
        query(
            self.configuration.borrow(),
            &uri_str,
            &"",
            hyper::Method::GET,
        )
    }

    fn get_ndmp_user(
        &self,
        ndmp_user_id: &str,
    ) -> Box<dyn Future<Item = crate::models::NdmpUsers, Error = Error>> {
        let uri_str = format!(
            "{}/platform/3/protocols/ndmp/users/{NdmpUserId}",
            self.configuration.base_path,
            NdmpUserId = ndmp_user_id
        );

        //let parsed: Result<crate::models::NdmpUsers, _> = serde_json::from_slice(&body);
        query(
            self.configuration.borrow(),
            &uri_str,
            &"",
            hyper::Method::GET,
        )
    }

    fn get_nfs_alias(
        &self,
        nfs_alias_id: &str,
        scope: &str,
        check: bool,
        zone: &str,
    ) -> Box<dyn Future<Item = crate::models::NfsAliases, Error = Error>> {
        let q = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("scope", &scope.to_string())
            .append_pair("check", &check.to_string())
            .append_pair("zone", &zone.to_string())
            .finish();
        let uri_str = format!(
            "{}/platform/2/protocols/nfs/aliases/{NfsAliasId}?{}",
            self.configuration.base_path,
            q,
            NfsAliasId = nfs_alias_id
        );

        //        let parsed: Result<crate::models::NfsAliases, _> = serde_json::from_slice(&body);
        query(
            self.configuration.borrow(),
            &uri_str,
            &"",
            hyper::Method::GET,
        )
    }

    fn get_nfs_check(
        &self,
        ignore_bad_paths: bool,
        ignore_bad_auth: bool,
        zone: &str,
        ignore_unresolvable_hosts: bool,
    ) -> Box<dyn Future<Item = crate::models::NfsCheckExtended, Error = Error>> {
        let q = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("ignore_bad_paths", &ignore_bad_paths.to_string())
            .append_pair("ignore_bad_auth", &ignore_bad_auth.to_string())
            .append_pair("zone", &zone.to_string())
            .append_pair(
                "ignore_unresolvable_hosts",
                &ignore_unresolvable_hosts.to_string(),
            )
            .finish();
        let uri_str = format!(
            "{}/platform/2/protocols/nfs/check?{}",
            self.configuration.base_path, q
        );

        //let parsed: Result<crate::models::NfsCheckExtended, _> = serde_json::from_slice(&body);
        query(
            self.configuration.borrow(),
            &uri_str,
            &"",
            hyper::Method::GET,
        )
    }

    fn get_nfs_export(
        &self,
        nfs_export_id: &str,
        scope: &str,
        zone: &str,
    ) -> Box<dyn Future<Item = crate::models::NfsExports, Error = Error>> {
        let q = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("scope", &scope.to_string())
            .append_pair("zone", &zone.to_string())
            .finish();
        let uri_str = format!(
            "{}/platform/4/protocols/nfs/exports/{NfsExportId}?{}",
            self.configuration.base_path,
            q,
            NfsExportId = nfs_export_id
        );

        //        let parsed: Result<crate::models::NfsExports, _> = serde_json::from_slice(&body);
        query(
            self.configuration.borrow(),
            &uri_str,
            &"",
            hyper::Method::GET,
        )
    }

    fn get_nfs_exports_summary(
        &self,
        zone: &str,
    ) -> Box<dyn Future<Item = crate::models::NfsExportsSummary, Error = Error>> {
        let q = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("zone", &zone.to_string())
            .finish();
        let uri_str = format!(
            "{}/platform/2/protocols/nfs/exports-summary?{}",
            self.configuration.base_path, q
        );

        //let parsed: Result<crate::models::NfsExportsSummary, _> = serde_json::from_slice(&body);
        query(
            self.configuration.borrow(),
            &uri_str,
            &"",
            hyper::Method::GET,
        )
    }

    fn get_nfs_log_level(
        &self,
    ) -> Box<dyn Future<Item = crate::models::NfsLogLevel, Error = Error>> {
        let uri_str = format!(
            "{}/platform/3/protocols/nfs/log-level",
            self.configuration.base_path
        );

        //let parsed: Result<crate::models::NfsLogLevel, _> = serde_json::from_slice(&body);
        query(
            self.configuration.borrow(),
            &uri_str,
            &"",
            hyper::Method::GET,
        )
    }

    fn get_nfs_netgroup(
        &self,
        host: &str,
    ) -> Box<dyn Future<Item = crate::models::NfsNetgroup, Error = Error>> {
        let q = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("host", &host.to_string())
            .finish();
        let uri_str = format!(
            "{}/platform/3/protocols/nfs/netgroup?{}",
            self.configuration.base_path, q
        );

        //let parsed: Result<crate::models::NfsNetgroup, _> = serde_json::from_slice(&body);
        query(
            self.configuration.borrow(),
            &uri_str,
            &"",
            hyper::Method::GET,
        )
    }

    fn get_nfs_nlm_locks(
        &self,
        sort: &str,
        created: &str,
        lin: &str,
        resume: &str,
        client: &str,
        limit: i32,
        client_id: &str,
        path: &str,
        dir: &str,
    ) -> Box<dyn Future<Item = crate::models::NfsNlmLocks, Error = Error>> {
        let q = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("sort", &sort.to_string())
            .append_pair("created", &created.to_string())
            .append_pair("lin", &lin.to_string())
            .append_pair("resume", &resume.to_string())
            .append_pair("client", &client.to_string())
            .append_pair("limit", &limit.to_string())
            .append_pair("client_id", &client_id.to_string())
            .append_pair("path", &path.to_string())
            .append_pair("dir", &dir.to_string())
            .finish();
        let uri_str = format!(
            "{}/platform/2/protocols/nfs/nlm/locks?{}",
            self.configuration.base_path, q
        );

        //let parsed: Result<crate::models::NfsNlmLocks, _> = serde_json::from_slice(&body);
        query(
            self.configuration.borrow(),
            &uri_str,
            &"",
            hyper::Method::GET,
        )
    }

    fn get_nfs_nlm_session(
        &self,
        nfs_nlm_session_id: &str,
        cluster_ip: &str,
        zone: &str,
    ) -> Box<dyn Future<Item = crate::models::NfsNlmSessions, Error = Error>> {
        let q = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("cluster_ip", &cluster_ip.to_string())
            .append_pair("zone", &zone.to_string())
            .finish();
        let uri_str = format!(
            "{}/platform/3/protocols/nfs/nlm/sessions/{NfsNlmSessionId}?{}",
            self.configuration.base_path,
            q,
            NfsNlmSessionId = nfs_nlm_session_id
        );

        //        let parsed: Result<crate::models::NfsNlmSessions, _> = serde_json::from_slice(&body);
        query(
            self.configuration.borrow(),
            &uri_str,
            &"",
            hyper::Method::GET,
        )
    }

    fn get_nfs_nlm_sessions(
        &self,
        sort: &str,
        ip: &str,
        limit: i32,
        zone: &str,
        dir: &str,
    ) -> Box<dyn Future<Item = crate::models::NfsNlmSessionsExtended, Error = Error>> {
        let q = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("sort", &sort.to_string())
            .append_pair("ip", &ip.to_string())
            .append_pair("limit", &limit.to_string())
            .append_pair("zone", &zone.to_string())
            .append_pair("dir", &dir.to_string())
            .finish();
        let uri_str = format!(
            "{}/platform/3/protocols/nfs/nlm/sessions?{}",
            self.configuration.base_path, q
        );

        //let parsed: Result<crate::models::NfsNlmSessionsExtended, _> =
        //   serde_json::from_slice(&body);
        query(
            self.configuration.borrow(),
            &uri_str,
            &"",
            hyper::Method::GET,
        )
    }

    fn get_nfs_nlm_waiters(
        &self,
        sort: &str,
        limit: i32,
        dir: &str,
        resume: &str,
    ) -> Box<dyn Future<Item = crate::models::NfsNlmWaiters, Error = Error>> {
        let q = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("sort", &sort.to_string())
            .append_pair("limit", &limit.to_string())
            .append_pair("dir", &dir.to_string())
            .append_pair("resume", &resume.to_string())
            .finish();
        let uri_str = format!(
            "{}/platform/2/protocols/nfs/nlm/waiters?{}",
            self.configuration.base_path, q
        );

        //let parsed: Result<crate::models::NfsNlmWaiters, _> = serde_json::from_slice(&body);
        query(
            self.configuration.borrow(),
            &uri_str,
            &"",
            hyper::Method::GET,
        )
    }

    fn get_nfs_settings_export(
        &self,
        scope: &str,
        zone: &str,
    ) -> Box<dyn Future<Item = crate::models::NfsSettingsExport, Error = Error>> {
        let q = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("scope", &scope.to_string())
            .append_pair("zone", &zone.to_string())
            .finish();
        let uri_str = format!(
            "{}/platform/2/protocols/nfs/settings/export?{}",
            self.configuration.base_path, q
        );

        //let parsed: Result<crate::models::NfsSettingsExport, _> = serde_json::from_slice(&body);
        query(
            self.configuration.borrow(),
            &uri_str,
            &"",
            hyper::Method::GET,
        )
    }

    fn get_nfs_settings_global(
        &self,
        scope: &str,
    ) -> Box<dyn Future<Item = crate::models::NfsSettingsGlobal, Error = Error>> {
        let q = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("scope", &scope.to_string())
            .finish();
        let uri_str = format!(
            "{}/platform/3/protocols/nfs/settings/global?{}",
            self.configuration.base_path, q
        );

        //let parsed: Result<crate::models::NfsSettingsGlobal, _> = serde_json::from_slice(&body);
        query(
            self.configuration.borrow(),
            &uri_str,
            &"",
            hyper::Method::GET,
        )
    }

    fn get_nfs_settings_zone(
        &self,
        zone: &str,
    ) -> Box<dyn Future<Item = crate::models::NfsSettingsZone, Error = Error>> {
        let q = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("zone", &zone.to_string())
            .finish();
        let uri_str = format!(
            "{}/platform/2/protocols/nfs/settings/zone?{}",
            self.configuration.base_path, q
        );

        //let parsed: Result<crate::models::NfsSettingsZone, _> = serde_json::from_slice(&body);
        query(
            self.configuration.borrow(),
            &uri_str,
            &"",
            hyper::Method::GET,
        )
    }

    fn get_ntp_server(
        &self,
        ntp_server_id: &str,
    ) -> Box<dyn Future<Item = crate::models::NtpServers, Error = Error>> {
        let uri_str = format!(
            "{}/platform/3/protocols/ntp/servers/{NtpServerId}",
            self.configuration.base_path,
            NtpServerId = ntp_server_id
        );

        //let parsed: Result<crate::models::NtpServers, _> = serde_json::from_slice(&body);
        query(
            self.configuration.borrow(),
            &uri_str,
            &"",
            hyper::Method::GET,
        )
    }

    fn get_ntp_settings(
        &self,
    ) -> Box<dyn Future<Item = crate::models::NtpSettings, Error = Error>> {
        let uri_str = format!(
            "{}/platform/3/protocols/ntp/settings",
            self.configuration.base_path
        );

        // let parsed: Result<crate::models::NtpSettings, _> = serde_json::from_slice(&body);
        query(
            self.configuration.borrow(),
            &uri_str,
            &"",
            hyper::Method::GET,
        )
    }

    fn get_smb_log_level(
        &self,
    ) -> Box<dyn Future<Item = crate::models::SmbLogLevel, Error = Error>> {
        let uri_str = format!(
            "{}/platform/3/protocols/smb/log-level",
            self.configuration.base_path
        );

        //let parsed: Result<crate::models::SmbLogLevel, _> = serde_json::from_slice(&body);
        query(
            self.configuration.borrow(),
            &uri_str,
            &"",
            hyper::Method::GET,
        )
    }

    fn get_smb_log_level_filter(
        &self,
        smb_log_level_filter_id: &str,
    ) -> Box<dyn Future<Item = crate::models::SmbLogLevelFilters, Error = Error>> {
        let uri_str = format!(
            "{}/platform/3/protocols/smb/log-level/filters/{SmbLogLevelFilterId}",
            self.configuration.base_path,
            SmbLogLevelFilterId = smb_log_level_filter_id
        );

        //let parsed: Result<crate::models::SmbLogLevelFilters, _> = serde_json::from_slice(&body);
        query(
            self.configuration.borrow(),
            &uri_str,
            &"",
            hyper::Method::GET,
        )
    }

    fn get_smb_openfiles(
        &self,
        sort: &str,
        limit: i32,
        dir: &str,
        resume: &str,
    ) -> Box<dyn Future<Item = crate::models::SmbOpenfiles, Error = Error>> {
        let q = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("sort", &sort.to_string())
            .append_pair("limit", &limit.to_string())
            .append_pair("dir", &dir.to_string())
            .append_pair("resume", &resume.to_string())
            .finish();
        let uri_str = format!(
            "{}/platform/1/protocols/smb/openfiles?{}",
            self.configuration.base_path, q
        );

        //let parsed: Result<crate::models::SmbOpenfiles, _> = serde_json::from_slice(&body);
        query(
            self.configuration.borrow(),
            &uri_str,
            &"",
            hyper::Method::GET,
        )
    }

    fn get_smb_sessions(
        &self,
        sort: &str,
        limit: i32,
        dir: &str,
        resume: &str,
    ) -> Box<dyn Future<Item = crate::models::SmbSessions, Error = Error>> {
        let q = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("sort", &sort.to_string())
            .append_pair("limit", &limit.to_string())
            .append_pair("dir", &dir.to_string())
            .append_pair("resume", &resume.to_string())
            .finish();
        let uri_str = format!(
            "{}/platform/1/protocols/smb/sessions?{}",
            self.configuration.base_path, q
        );

        //let parsed: Result<crate::models::SmbSessions, _> = serde_json::from_slice(&body);
        query(
            self.configuration.borrow(),
            &uri_str,
            &"",
            hyper::Method::GET,
        )
    }

    fn get_smb_settings_global(
        &self,
        scope: &str,
    ) -> Box<dyn Future<Item = crate::models::SmbSettingsGlobal, Error = Error>> {
        let q = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("scope", &scope.to_string())
            .finish();
        let uri_str = format!(
            "{}/platform/3/protocols/smb/settings/global?{}",
            self.configuration.base_path, q
        );

        //let parsed: Result<crate::models::SmbSettingsGlobal, _> = serde_json::from_slice(&body);
        query(
            self.configuration.borrow(),
            &uri_str,
            &"",
            hyper::Method::GET,
        )
    }

    fn get_smb_settings_share(
        &self,
        scope: &str,
        zone: &str,
    ) -> Box<dyn Future<Item = crate::models::SmbSettingsShare, Error = Error>> {
        let q = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("scope", &scope.to_string())
            .append_pair("zone", &zone.to_string())
            .finish();
        let uri_str = format!(
            "{}/platform/3/protocols/smb/settings/share?{}",
            self.configuration.base_path, q
        );

        //        let parsed: Result<crate::models::SmbSettingsShare, _> = serde_json::from_slice(&body);
        query(
            self.configuration.borrow(),
            &uri_str,
            &"",
            hyper::Method::GET,
        )
    }

    fn get_smb_share(
        &self,
        smb_share_id: &str,
        scope: &str,
        resolve_names: bool,
        zone: &str,
    ) -> Box<dyn Future<Item = crate::models::SmbShares, Error = Error>> {
        let q = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("scope", &scope.to_string())
            .append_pair("resolve_names", &resolve_names.to_string())
            .append_pair("zone", &zone.to_string())
            .finish();
        let uri_str = format!(
            "{}/platform/4/protocols/smb/shares/{SmbShareId}?{}",
            self.configuration.base_path,
            q,
            SmbShareId = smb_share_id
        );

        //let parsed: Result<crate::models::SmbShares, _> = serde_json::from_slice(&body);
        query(
            self.configuration.borrow(),
            &uri_str,
            &"",
            hyper::Method::GET,
        )
    }

    fn get_smb_shares_summary(
        &self,
        zone: &str,
    ) -> Box<dyn Future<Item = crate::models::SmbSharesSummary, Error = Error>> {
        let q = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("zone", &zone.to_string())
            .finish();
        let uri_str = format!(
            "{}/platform/1/protocols/smb/shares-summary?{}",
            self.configuration.base_path, q
        );

        //let parsed: Result<crate::models::SmbSharesSummary, _> = serde_json::from_slice(&body);
        query(
            self.configuration.borrow(),
            &uri_str,
            &"",
            hyper::Method::GET,
        )
    }

    fn get_snmp_settings(
        &self,
    ) -> Box<dyn Future<Item = crate::models::SnmpSettings, Error = Error>> {
        let uri_str = format!(
            "{}/platform/5/protocols/snmp/settings",
            self.configuration.base_path
        );

        //let parsed: Result<crate::models::SnmpSettings, _> = serde_json::from_slice(&body);
        query(
            self.configuration.borrow(),
            &uri_str,
            &"",
            hyper::Method::GET,
        )
    }

    fn get_swift_account(
        &self,
        swift_account_id: &str,
        zone: &str,
    ) -> Box<dyn Future<Item = crate::models::SwiftAccounts, Error = Error>> {
        let q = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("zone", &zone.to_string())
            .finish();
        let uri_str = format!(
            "{}/platform/3/protocols/swift/accounts/{SwiftAccountId}?{}",
            self.configuration.base_path,
            q,
            SwiftAccountId = swift_account_id
        );

        //        let parsed: Result<crate::models::SwiftAccounts, _> = serde_json::from_slice(&body);
        query(
            self.configuration.borrow(),
            &uri_str,
            &"",
            hyper::Method::GET,
        )
    }

    fn list_hdfs_proxyusers(
        &self,
        zone: &str,
    ) -> Box<dyn Future<Item = crate::models::HdfsProxyusers, Error = Error>> {
        let q = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("zone", &zone.to_string())
            .finish();
        let uri_str = format!(
            "{}/platform/1/protocols/hdfs/proxyusers?{}",
            self.configuration.base_path, q
        );

        //let parsed: Result<crate::models::HdfsProxyusers, _> = serde_json::from_slice(&body);
        query(
            self.configuration.borrow(),
            &uri_str,
            &"",
            hyper::Method::GET,
        )
    }

    fn list_hdfs_racks(
        &self,
        zone: &str,
    ) -> Box<dyn Future<Item = crate::models::HdfsRacksExtended, Error = Error>> {
        let q = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("zone", &zone.to_string())
            .finish();
        let uri_str = format!(
            "{}/platform/1/protocols/hdfs/racks?{}",
            self.configuration.base_path, q
        );

        query(
            self.configuration.borrow(),
            &uri_str,
            &"",
            hyper::Method::GET,
        )
    }

    fn list_ndmp_settings_preferred_ips(
        &self,
        limit: i32,
        resume: &str,
    ) -> Box<dyn Future<Item = crate::models::NdmpSettingsPreferredIps, Error = Error>> {
        let q = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("limit", &limit.to_string())
            .append_pair("resume", &resume.to_string())
            .finish();
        let uri_str = format!(
            "{}/platform/4/protocols/ndmp/settings/preferred-ips?{}",
            self.configuration.base_path, q
        );

        query(
            self.configuration.borrow(),
            &uri_str,
            &"",
            hyper::Method::GET,
        )
    }

    fn list_ndmp_users(
        &self,
    ) -> Box<dyn Future<Item = crate::models::NdmpUsersExtended, Error = Error>> {
        let uri_str = format!(
            "{}/platform/3/protocols/ndmp/users",
            self.configuration.base_path
        );

        query(
            self.configuration.borrow(),
            &uri_str,
            &"",
            hyper::Method::GET,
        )
    }

    fn list_nfs_aliases(
        &self,
        sort: &str,
        zone: &str,
        resume: &str,
        limit: i32,
        check: bool,
        dir: &str,
    ) -> Box<dyn Future<Item = crate::models::NfsAliasesExtended, Error = Error>> {
        let q = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("sort", &sort.to_string())
            .append_pair("zone", &zone.to_string())
            .append_pair("resume", &resume.to_string())
            .append_pair("limit", &limit.to_string())
            .append_pair("check", &check.to_string())
            .append_pair("dir", &dir.to_string())
            .finish();
        let uri_str = format!(
            "{}/platform/2/protocols/nfs/aliases?{}",
            self.configuration.base_path, q
        );

        query(
            self.configuration.borrow(),
            &uri_str,
            &"",
            hyper::Method::GET,
        )
    }

    fn list_nfs_exports(
        &self,
        sort: &str,
        zone: &str,
        resume: &str,
        scope: &str,
        limit: i32,
        offset: i32,
        path: &str,
        check: bool,
        dir: &str,
    ) -> Box<dyn Future<Item = crate::models::NfsExportsExtended, Error = Error>> {
        let q = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("sort", &sort.to_string())
            .append_pair("zone", &zone.to_string())
            .append_pair("resume", &resume.to_string())
            .append_pair("scope", &scope.to_string())
            .append_pair("limit", &limit.to_string())
            .append_pair("offset", &offset.to_string())
            .append_pair("path", &path.to_string())
            .append_pair("check", &check.to_string())
            .append_pair("dir", &dir.to_string())
            .finish();
        let uri_str = format!(
            "{}/platform/4/protocols/nfs/exports?{}",
            self.configuration.base_path, q
        );

        query(
            self.configuration.borrow(),
            &uri_str,
            &"",
            hyper::Method::GET,
        )
    }

    fn list_ntp_servers(
        &self,
        sort: &str,
        limit: i32,
        dir: &str,
        resume: &str,
    ) -> Box<dyn Future<Item = crate::models::NtpServersExtended, Error = Error>> {
        let q = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("sort", &sort.to_string())
            .append_pair("limit", &limit.to_string())
            .append_pair("dir", &dir.to_string())
            .append_pair("resume", &resume.to_string())
            .finish();
        let uri_str = format!(
            "{}/platform/3/protocols/ntp/servers?{}",
            self.configuration.base_path, q
        );

        query(
            self.configuration.borrow(),
            &uri_str,
            &"",
            hyper::Method::GET,
        )
    }

    fn list_smb_log_level_filters(
        &self,
        sort: &str,
        dir: &str,
        level: &str,
    ) -> Box<dyn Future<Item = crate::models::SmbLogLevelFilters, Error = Error>> {
        let q = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("sort", &sort.to_string())
            .append_pair("dir", &dir.to_string())
            .append_pair("level", &level.to_string())
            .finish();
        let uri_str = format!(
            "{}/platform/3/protocols/smb/log-level/filters?{}",
            self.configuration.base_path, q
        );

        query(
            self.configuration.borrow(),
            &uri_str,
            &"",
            hyper::Method::GET,
        )
    }

    fn list_smb_shares(
        &self,
        sort: &str,
        zone: &str,
        resume: &str,
        resolve_names: bool,
        limit: i32,
        offset: i32,
        scope: &str,
        dir: &str,
    ) -> Box<dyn Future<Item = crate::models::SmbSharesExtended, Error = Error>> {
        let q = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("sort", &sort.to_string())
            .append_pair("zone", &zone.to_string())
            .append_pair("resume", &resume.to_string())
            .append_pair("resolve_names", &resolve_names.to_string())
            .append_pair("limit", &limit.to_string())
            .append_pair("offset", &offset.to_string())
            .append_pair("scope", &scope.to_string())
            .append_pair("dir", &dir.to_string())
            .finish();
        let uri_str = format!(
            "{}/platform/4/protocols/smb/shares?{}",
            self.configuration.base_path, q
        );

        query(
            self.configuration.borrow(),
            &uri_str,
            &"",
            hyper::Method::GET,
        )
    }

    fn list_swift_accounts(
        &self,
        zone: &str,
    ) -> Box<dyn Future<Item = crate::models::SwiftAccountsExtended, Error = Error>> {
        let q = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("zone", &zone.to_string())
            .finish();
        let uri_str = format!(
            "{}/platform/3/protocols/swift/accounts?{}",
            self.configuration.base_path, q
        );

        query(
            self.configuration.borrow(),
            &uri_str,
            &"",
            hyper::Method::GET,
        )
    }

    fn update_ftp_settings(
        &self,
        ftp_settings: crate::models::FtpSettingsExtended,
    ) -> Box<dyn Future<Item = (), Error = Error>> {
        let uri = format!(
            "{}/platform/3/protocols/ftp/settings",
            self.configuration.base_path
        );
        put(self.configuration.borrow(), &uri, &ftp_settings)
    }

    fn update_hdfs_log_level(
        &self,
        hdfs_log_level: crate::models::HdfsLogLevel,
    ) -> Box<dyn Future<Item = (), Error = Error>> {
        let uri = format!(
            "{}/platform/3/protocols/hdfs/log-level",
            self.configuration.base_path
        );
        put(self.configuration.borrow(), &uri, &hdfs_log_level)
    }

    fn update_hdfs_proxyuser(
        &self,
        hdfs_proxyuser: crate::models::Empty,
        hdfs_proxyuser_id: &str,
        zone: &str,
    ) -> Box<dyn Future<Item = (), Error = Error>> {
        let q = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("zone", &zone.to_string())
            .finish();
        let uri = format!(
            "{}/platform/1/protocols/hdfs/proxyusers/{HdfsProxyuserId}?{}",
            self.configuration.base_path,
            q,
            HdfsProxyuserId = hdfs_proxyuser_id
        );
        put(self.configuration.borrow(), &uri, &hdfs_proxyuser)
    }

    fn update_hdfs_rack(
        &self,
        hdfs_rack: crate::models::HdfsRack,
        hdfs_rack_id: &str,
        zone: &str,
    ) -> Box<dyn Future<Item = (), Error = Error>> {
        let q = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("zone", &zone.to_string())
            .finish();
        let uri = format!(
            "{}/platform/1/protocols/hdfs/racks/{HdfsRackId}?{}",
            self.configuration.base_path,
            q,
            HdfsRackId = hdfs_rack_id
        );
        put(self.configuration.borrow(), &uri, &hdfs_rack)
    }

    fn update_hdfs_ranger_plugin_settings(
        &self,
        hdfs_ranger_plugin_settings: crate::models::HdfsRangerPluginSettingsSettings,
        zone: &str,
    ) -> Box<dyn Future<Item = (), Error = Error>> {
        let q = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("zone", &zone.to_string())
            .finish();
        let uri = format!(
            "{}/platform/4/protocols/hdfs/ranger-plugin/settings?{}",
            self.configuration.base_path, q
        );
        put(
            self.configuration.borrow(),
            &uri,
            &hdfs_ranger_plugin_settings,
        )
    }

    fn update_hdfs_settings(
        &self,
        hdfs_settings: crate::models::HdfsSettingsSettings,
        zone: &str,
    ) -> Box<dyn Future<Item = (), Error = Error>> {
        let q = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("zone", &zone.to_string())
            .finish();
        let uri = format!(
            "{}/platform/4/protocols/hdfs/settings?{}",
            self.configuration.base_path, q
        );
        put(self.configuration.borrow(), &uri, &hdfs_settings)
    }

    fn update_http_settings(
        &self,
        http_settings: crate::models::HttpSettingsSettings,
    ) -> Box<dyn Future<Item = (), Error = Error>> {
        let uri = format!(
            "{}/platform/3/protocols/http/settings",
            self.configuration.base_path
        );
        put(self.configuration.borrow(), &uri, &http_settings)
    }

    fn update_ndmp_diagnostics(
        &self,
        ndmp_diagnostics: crate::models::NdmpDiagnosticsDiagnostics,
    ) -> Box<dyn Future<Item = (), Error = Error>> {
        let uri = format!(
            "{}/platform/3/protocols/ndmp/diagnostics",
            self.configuration.base_path
        );
        put(self.configuration.borrow(), &uri, &ndmp_diagnostics)
    }

    fn update_ndmp_settings_global(
        &self,
        ndmp_settings_global: crate::models::NdmpSettingsGlobalGlobal,
    ) -> Box<dyn Future<Item = (), Error = Error>> {
        let uri = format!(
            "{}/platform/3/protocols/ndmp/settings/global",
            self.configuration.base_path
        );
        put(self.configuration.borrow(), &uri, &ndmp_settings_global)
    }

    fn update_ndmp_settings_preferred_ip(
        &self,
        ndmp_settings_preferred_ip: crate::models::NdmpSettingsPreferredIp,
        ndmp_settings_preferred_ip_id: &str,
    ) -> Box<dyn Future<Item = (), Error = Error>> {
        let uri = format!(
            "{}/platform/4/protocols/ndmp/settings/preferred-ips/{NdmpSettingsPreferredIpId}",
            self.configuration.base_path,
            NdmpSettingsPreferredIpId = ndmp_settings_preferred_ip_id
        );
        put(
            self.configuration.borrow(),
            &uri,
            &ndmp_settings_preferred_ip,
        )
    }

    fn update_ndmp_settings_variable(
        &self,
        ndmp_settings_variable: crate::models::NdmpSettingsVariable,
        ndmp_settings_variable_id: &str,
        name: &str,
    ) -> Box<dyn Future<Item = (), Error = Error>> {
        let q = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("name", &name.to_string())
            .finish();
        let uri = format!(
            "{}/platform/3/protocols/ndmp/settings/variables/{NdmpSettingsVariableId}?{}",
            self.configuration.base_path,
            q,
            NdmpSettingsVariableId = ndmp_settings_variable_id
        );
        put(self.configuration.borrow(), &uri, &ndmp_settings_variable)
    }

    fn update_ndmp_user(
        &self,
        ndmp_user: crate::models::NdmpUser,
        ndmp_user_id: &str,
    ) -> Box<dyn Future<Item = (), Error = Error>> {
        let uri = format!(
            "{}/platform/3/protocols/ndmp/users/{NdmpUserId}",
            self.configuration.base_path,
            NdmpUserId = ndmp_user_id
        );
        put(self.configuration.borrow(), &uri, &ndmp_user)
    }

    fn update_nfs_alias(
        &self,
        nfs_alias: crate::models::NfsAlias,
        nfs_alias_id: &str,
        zone: &str,
    ) -> Box<dyn Future<Item = (), Error = Error>> {
        let q = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("zone", &zone.to_string())
            .finish();
        let uri = format!(
            "{}/platform/2/protocols/nfs/aliases/{NfsAliasId}?{}",
            self.configuration.base_path,
            q,
            NfsAliasId = nfs_alias_id
        );
        put(self.configuration.borrow(), &uri, &nfs_alias)
    }

    fn update_nfs_export(
        &self,
        nfs_export: crate::models::NfsExport,
        nfs_export_id: &str,
        force: bool,
        ignore_unresolvable_hosts: bool,
        zone: &str,
        ignore_conflicts: bool,
        ignore_bad_paths: bool,
        ignore_bad_auth: bool,
    ) -> Box<dyn Future<Item = (), Error = Error>> {
        let q = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("force", &force.to_string())
            .append_pair(
                "ignore_unresolvable_hosts",
                &ignore_unresolvable_hosts.to_string(),
            )
            .append_pair("zone", &zone.to_string())
            .append_pair("ignore_conflicts", &ignore_conflicts.to_string())
            .append_pair("ignore_bad_paths", &ignore_bad_paths.to_string())
            .append_pair("ignore_bad_auth", &ignore_bad_auth.to_string())
            .finish();
        let uri = format!(
            "{}/platform/4/protocols/nfs/exports/{NfsExportId}?{}",
            self.configuration.base_path,
            q,
            NfsExportId = nfs_export_id
        );
        put(self.configuration.borrow(), &uri, &nfs_export)
    }

    fn update_nfs_log_level(
        &self,
        nfs_log_level: crate::models::NfsLogLevel,
    ) -> Box<dyn Future<Item = (), Error = Error>> {
        let uri = format!(
            "{}/platform/3/protocols/nfs/log-level",
            self.configuration.base_path
        );
        put(self.configuration.borrow(), &uri, &nfs_log_level)
    }

    fn update_nfs_netgroup(
        &self,
        nfs_netgroup: crate::models::NfsNetgroup,
        host: &str,
    ) -> Box<dyn Future<Item = (), Error = Error>> {
        let q = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("host", &host.to_string())
            .finish();
        let uri = format!(
            "{}/platform/3/protocols/nfs/netgroup?{}",
            self.configuration.base_path, q
        );
        put(self.configuration.borrow(), &uri, &nfs_netgroup)
    }

    fn update_nfs_settings_export(
        &self,
        nfs_settings_export: crate::models::NfsSettingsExportSettings,
        zone: &str,
    ) -> Box<dyn Future<Item = (), Error = Error>> {
        let q = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("zone", &zone.to_string())
            .finish();
        let uri = format!(
            "{}/platform/2/protocols/nfs/settings/export?{}",
            self.configuration.base_path, q
        );
        put(self.configuration.borrow(), &uri, &nfs_settings_export)
    }

    fn update_nfs_settings_global(
        &self,
        nfs_settings_global: crate::models::NfsSettingsGlobalSettings,
        scope: &str,
    ) -> Box<dyn Future<Item = (), Error = Error>> {
        let q = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("scope", &scope.to_string())
            .finish();
        let uri = format!(
            "{}/platform/3/protocols/nfs/settings/global?{}",
            self.configuration.base_path, q
        );
        put(self.configuration.borrow(), &uri, &nfs_settings_global)
    }

    fn update_nfs_settings_zone(
        &self,
        nfs_settings_zone: crate::models::NfsSettingsZoneSettings,
        zone: &str,
    ) -> Box<dyn Future<Item = (), Error = Error>> {
        let q = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("zone", &zone.to_string())
            .finish();
        let uri = format!(
            "{}/platform/2/protocols/nfs/settings/zone?{}",
            self.configuration.base_path, q
        );
        put(self.configuration.borrow(), &uri, &nfs_settings_zone)
    }

    fn update_ntp_server(
        &self,
        ntp_server: crate::models::NtpServer,
        ntp_server_id: &str,
    ) -> Box<dyn Future<Item = (), Error = Error>> {
        let uri = format!(
            "{}/platform/3/protocols/ntp/servers/{NtpServerId}",
            self.configuration.base_path,
            NtpServerId = ntp_server_id
        );
        put(self.configuration.borrow(), &uri, &ntp_server)
    }

    fn update_ntp_settings(
        &self,
        ntp_settings: crate::models::NtpSettingsSettings,
    ) -> Box<dyn Future<Item = (), Error = Error>> {
        let uri = format!(
            "{}/platform/3/protocols/ntp/settings",
            self.configuration.base_path
        );
        put(self.configuration.borrow(), &uri, &ntp_settings)
    }

    fn update_smb_log_level(
        &self,
        smb_log_level: crate::models::SmbLogLevel,
    ) -> Box<dyn Future<Item = (), Error = Error>> {
        let uri = format!(
            "{}/platform/3/protocols/smb/log-level",
            self.configuration.base_path
        );
        put(self.configuration.borrow(), &uri, &smb_log_level)
    }

    fn update_smb_settings_global(
        &self,
        smb_settings_global: crate::models::SmbSettingsGlobalExtended,
    ) -> Box<dyn Future<Item = (), Error = Error>> {
        let uri = format!(
            "{}/platform/3/protocols/smb/settings/global",
            self.configuration.base_path
        );
        put(self.configuration.borrow(), &uri, &smb_settings_global)
    }

    fn update_smb_settings_share(
        &self,
        smb_settings_share: crate::models::SmbSettingsShareExtended,
        zone: &str,
    ) -> Box<dyn Future<Item = (), Error = Error>> {
        let q = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("zone", &zone.to_string())
            .finish();
        let uri = format!(
            "{}/platform/3/protocols/smb/settings/share?{}",
            self.configuration.base_path, q
        );
        put(self.configuration.borrow(), &uri, &smb_settings_share)
    }

    fn update_smb_share(
        &self,
        smb_share: crate::models::SmbShare,
        smb_share_id: &str,
        zone: &str,
    ) -> Box<dyn Future<Item = (), Error = Error>> {
        let q = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("zone", &zone.to_string())
            .finish();
        let uri = format!(
            "{}/platform/4/protocols/smb/shares/{SmbShareId}?{}",
            self.configuration.base_path,
            q,
            SmbShareId = smb_share_id
        );
        put(self.configuration.borrow(), &uri, &smb_share)
    }

    fn update_snmp_settings(
        &self,
        snmp_settings: crate::models::SnmpSettingsExtended,
    ) -> Box<dyn Future<Item = (), Error = Error>> {
        let uri = format!(
            "{}/platform/5/protocols/snmp/settings",
            self.configuration.base_path
        );
        put(self.configuration.borrow(), &uri, &snmp_settings)
    }

    fn update_swift_account(
        &self,
        swift_account: crate::models::SwiftAccount,
        swift_account_id: &str,
        zone: &str,
    ) -> Box<dyn Future<Item = (), Error = Error>> {
        let q = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("zone", &zone.to_string())
            .finish();
        let uri = format!(
            "{}/platform/3/protocols/swift/accounts/{SwiftAccountId}?{}",
            self.configuration.base_path,
            q,
            SwiftAccountId = swift_account_id
        );
        put(self.configuration.borrow(), &uri, &swift_account)
    }
}
