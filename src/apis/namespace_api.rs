/*
 * Isilon SDK
 *
 * Isilon SDK - Language bindings for the OneFS API
 *
 * OpenAPI spec version: 5
 * Contact: sdk@isilon.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

use std::borrow::Borrow;
use std::collections::HashMap;
use std::rc::Rc;

use futures;
use futures::Future;
use hyper;

use super::{configuration, custom_query, query, Error};

pub struct NamespaceApiClient<C: hyper::client::connect::Connect> {
    configuration: Rc<configuration::Configuration<C>>,
}

impl<C: hyper::client::connect::Connect> NamespaceApiClient<C> {
    pub fn new(configuration: Rc<configuration::Configuration<C>>) -> NamespaceApiClient<C> {
        NamespaceApiClient {
            configuration: configuration,
        }
    }
}

pub trait NamespaceApi {
    fn copy_directory(
        &self,
        directory_copy_target: &str,
        x_isi_ifs_copy_source: &str,
        overwrite: bool,
        merge: bool,
        _continue: bool,
    ) -> Box<dyn Future<Item = crate::models::CopyErrors, Error = Error>>;
    fn copy_file(
        &self,
        file_copy_target: &str,
        x_isi_ifs_copy_source: &str,
        clone: bool,
        snapshot: &str,
        overwrite: bool,
    ) -> Box<dyn Future<Item = crate::models::CopyErrors, Error = Error>>;
    fn create_access_point(
        &self,
        access_point_name: &str,
        access_point: crate::models::AccessPointCreateParams,
    ) -> Box<dyn Future<Item = crate::models::Empty, Error = Error>>;
    fn create_directory(
        &self,
        directory_path: &str,
        x_isi_ifs_target_type: &str,
        x_isi_ifs_access_control: &str,
        x_isi_ifs_node_pool_name: &str,
        recursive: bool,
        overwrite: bool,
    ) -> Box<dyn Future<Item = crate::models::Empty, Error = Error>>;
    fn create_file(
        &self,
        file_path: &str,
        x_isi_ifs_target_type: &str,
        file_contents: &str,
        x_isi_ifs_access_control: &str,
        content_encoding: &str,
        content_type: &str,
        overwrite: bool,
    ) -> Box<dyn Future<Item = crate::models::Empty, Error = Error>>;
    fn delete_access_point(
        &self,
        access_point_name: &str,
    ) -> Box<dyn Future<Item = crate::models::Empty, Error = Error>>;
    fn delete_directory(
        &self,
        directory_path: &str,
        recursive: bool,
    ) -> Box<dyn Future<Item = crate::models::Empty, Error = Error>>;
    fn delete_file(
        &self,
        file_path: &str,
    ) -> Box<dyn Future<Item = crate::models::Empty, Error = Error>>;
    fn get_acl(
        &self,
        namespace_path: &str,
        acl: bool,
        nsaccess: bool,
    ) -> Box<dyn Future<Item = crate::models::NamespaceAcl, Error = Error>>;
    fn get_directory_attributes(
        &self,
        directory_path: &str,
        if_modified_since: &str,
        if_unmodified_since: &str,
    ) -> Box<dyn Future<Item = crate::models::Empty, Error = Error>>;
    fn get_directory_contents(
        &self,
        directory_path: &str,
        detail: &str,
        limit: i32,
        resume: &str,
        sort: &str,
        dir: &str,
        _type: &str,
        hidden: bool,
    ) -> Box<dyn Future<Item = crate::models::NamespaceObjects, Error = Error>>;
    fn get_directory_metadata(
        &self,
        directory_metadata_path: &str,
        metadata: bool,
    ) -> Box<dyn Future<Item = crate::models::NamespaceMetadataList, Error = Error>>;
    fn get_file_attributes(
        &self,
        file_path: &str,
        if_modified_since: &str,
        if_unmodified_since: &str,
    ) -> Box<dyn Future<Item = crate::models::Empty, Error = Error>>;
    fn get_file_contents(
        &self,
        file_path: &str,
        range: &str,
        if_modified_since: &str,
        if_unmodified_since: &str,
    ) -> Box<dyn Future<Item = crate::models::Empty, Error = Error>>;
    fn get_file_metadata(
        &self,
        file_metadata_path: &str,
        metadata: bool,
    ) -> Box<dyn Future<Item = crate::models::NamespaceMetadataList, Error = Error>>;
    fn get_worm_properties(
        &self,
        worm_file_path: &str,
        worm: bool,
    ) -> Box<dyn Future<Item = crate::models::WormProperties, Error = Error>>;
    fn list_access_points(
        &self,
        versions: bool,
    ) -> Box<dyn Future<Item = crate::models::NamespaceAccessPoints, Error = Error>>;
    fn move_directory(
        &self,
        directory_path: &str,
        x_isi_ifs_set_location: &str,
    ) -> Box<dyn Future<Item = crate::models::Empty, Error = Error>>;
    fn move_file(
        &self,
        file_path: &str,
        x_isi_ifs_set_location: &str,
    ) -> Box<dyn Future<Item = crate::models::Empty, Error = Error>>;
    fn query_directory(
        &self,
        query_path: &str,
        query: bool,
        directory_query: crate::models::DirectoryQuery,
        limit: i32,
        detail: &str,
        max_depth: i32,
    ) -> Box<dyn Future<Item = crate::models::NamespaceObjects, Error = Error>>;
    fn set_acl(
        &self,
        namespace_path: &str,
        acl: bool,
        namespace_acl: crate::models::NamespaceAcl,
        nsaccess: bool,
    ) -> Box<dyn Future<Item = crate::models::Empty, Error = Error>>;
    fn set_directory_metadata(
        &self,
        directory_metadata_path: &str,
        metadata: bool,
        directory_metadata: crate::models::NamespaceMetadata,
    ) -> Box<dyn Future<Item = crate::models::Empty, Error = Error>>;
    fn set_file_metadata(
        &self,
        file_metadata_path: &str,
        metadata: bool,
        file_metadata: crate::models::NamespaceMetadata,
    ) -> Box<dyn Future<Item = crate::models::Empty, Error = Error>>;
    fn set_worm_properties(
        &self,
        worm_file_path: &str,
        worm: bool,
        worm_properties: crate::models::WormCreateParams,
    ) -> Box<dyn Future<Item = crate::models::Empty, Error = Error>>;
}

impl<C: hyper::client::connect::Connect + 'static> NamespaceApi for NamespaceApiClient<C> {
    fn copy_directory(
        &self,
        directory_copy_target: &str,
        x_isi_ifs_copy_source: &str,
        overwrite: bool,
        merge: bool,
        _continue: bool,
    ) -> Box<dyn Future<Item = crate::models::CopyErrors, Error = Error>> {
        let mut headers: HashMap<String, String> = HashMap::new();

        let q = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("overwrite", &overwrite.to_string())
            .append_pair("merge", &merge.to_string())
            .append_pair("continue", &_continue.to_string())
            .finish();
        let uri_str = format!(
            "{}/namespace/{DirectoryCopyTarget}?{}",
            self.configuration.base_path,
            q,
            DirectoryCopyTarget = directory_copy_target
        );

        headers.insert("x-isi-ifs-copy-source".into(), x_isi_ifs_copy_source.into());

        custom_query(
            self.configuration.borrow(),
            &uri_str,
            &"",
            hyper::Method::PUT,
            headers,
        )
    }

    fn copy_file(
        &self,
        file_copy_target: &str,
        x_isi_ifs_copy_source: &str,
        clone: bool,
        snapshot: &str,
        overwrite: bool,
    ) -> Box<dyn Future<Item = crate::models::CopyErrors, Error = Error>> {
        let mut headers: HashMap<String, String> = HashMap::new();

        let q = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("clone", &clone.to_string())
            .append_pair("snapshot", &snapshot.to_string())
            .append_pair("overwrite", &overwrite.to_string())
            .finish();
        let uri_str = format!(
            "{}/namespace/{FileCopyTarget}?{}",
            self.configuration.base_path,
            q,
            FileCopyTarget = file_copy_target
        );

        headers.insert("x-isi-ifs-copy-source".into(), x_isi_ifs_copy_source.into());

        custom_query(
            self.configuration.borrow(),
            &uri_str,
            &"",
            hyper::Method::PUT,
            headers,
        )
    }

    fn create_access_point(
        &self,
        access_point_name: &str,
        access_point: crate::models::AccessPointCreateParams,
    ) -> Box<dyn Future<Item = crate::models::Empty, Error = Error>> {
        let uri_str = format!(
            "{}/namespace/{AccessPointName}",
            self.configuration.base_path,
            AccessPointName = access_point_name
        );
        query(
            self.configuration.borrow(),
            &uri_str,
            &access_point,
            hyper::Method::PUT,
        )
    }

    fn create_directory(
        &self,
        directory_path: &str,
        x_isi_ifs_target_type: &str,
        x_isi_ifs_access_control: &str,
        x_isi_ifs_node_pool_name: &str,
        recursive: bool,
        overwrite: bool,
    ) -> Box<dyn Future<Item = crate::models::Empty, Error = Error>> {
        let mut headers: HashMap<String, String> = HashMap::new();

        let q = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("recursive", &recursive.to_string())
            .append_pair("overwrite", &overwrite.to_string())
            .finish();
        let uri_str = format!(
            "{}/namespace/{DirectoryPath}?{}",
            self.configuration.base_path,
            q,
            DirectoryPath = directory_path
        );

        headers.insert("x-isi-ifs-target-type".into(), x_isi_ifs_target_type.into());
        headers.insert(
            "x-isi-ifs-access-control".into(),
            x_isi_ifs_access_control.into(),
        );
        headers.insert(
            "x-isi-ifs-node-pool-name".into(),
            x_isi_ifs_node_pool_name.into(),
        );
        custom_query(
            self.configuration.borrow(),
            &uri_str,
            &"",
            hyper::Method::PUT,
            headers,
        )
    }

    fn create_file(
        &self,
        file_path: &str,
        x_isi_ifs_target_type: &str,
        file_contents: &str,
        x_isi_ifs_access_control: &str,
        content_encoding: &str,
        content_type: &str,
        overwrite: bool,
    ) -> Box<dyn Future<Item = crate::models::Empty, Error = Error>> {
        let mut headers: HashMap<String, String> = HashMap::new();

        let q = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("overwrite", &overwrite.to_string())
            .finish();
        let uri_str = format!(
            "{}/namespace/{FilePath}?{}",
            self.configuration.base_path,
            q,
            FilePath = file_path
        );

        headers.insert("Content-Type".into(), content_type.into());
        headers.insert("x-isi-ifs-target-type".into(), x_isi_ifs_target_type.into());
        headers.insert(
            "x-isi-ifs-access-control".into(),
            x_isi_ifs_access_control.into(),
        );
        headers.insert("Content-Encoding".into(), content_encoding.into());
        custom_query(
            self.configuration.borrow(),
            &uri_str,
            &file_contents,
            hyper::Method::PUT,
            headers,
        )
    }

    fn delete_access_point(
        &self,
        access_point_name: &str,
    ) -> Box<dyn Future<Item = crate::models::Empty, Error = Error>> {
        let uri_str = format!(
            "{}/namespace/{AccessPointName}",
            self.configuration.base_path,
            AccessPointName = access_point_name
        );
        query(
            self.configuration.borrow(),
            &uri_str,
            &"",
            hyper::Method::DELETE,
        )
    }

    fn delete_directory(
        &self,
        directory_path: &str,
        recursive: bool,
    ) -> Box<dyn Future<Item = crate::models::Empty, Error = Error>> {
        let q = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("recursive", &recursive.to_string())
            .finish();
        let uri_str = format!(
            "{}/namespace/{DirectoryPath}?{}",
            self.configuration.base_path,
            q,
            DirectoryPath = directory_path
        );
        query(
            self.configuration.borrow(),
            &uri_str,
            &"",
            hyper::Method::DELETE,
        )
    }

    fn delete_file(
        &self,
        file_path: &str,
    ) -> Box<dyn Future<Item = crate::models::Empty, Error = Error>> {
        let uri_str = format!(
            "{}/namespace/{FilePath}",
            self.configuration.base_path,
            FilePath = file_path
        );
        query(
            self.configuration.borrow(),
            &uri_str,
            &"",
            hyper::Method::DELETE,
        )
    }

    fn get_acl(
        &self,
        namespace_path: &str,
        acl: bool,
        nsaccess: bool,
    ) -> Box<dyn Future<Item = crate::models::NamespaceAcl, Error = Error>> {
        let q = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("acl", &acl.to_string())
            .append_pair("nsaccess", &nsaccess.to_string())
            .finish();
        let uri_str = format!(
            "{}/namespace/{NamespacePath}?{}",
            self.configuration.base_path,
            q,
            NamespacePath = namespace_path
        );
        query(
            self.configuration.borrow(),
            &uri_str,
            &"",
            hyper::Method::GET,
        )
    }

    fn get_directory_attributes(
        &self,
        directory_path: &str,
        if_modified_since: &str,
        if_unmodified_since: &str,
    ) -> Box<dyn Future<Item = crate::models::Empty, Error = Error>> {
        let mut headers: HashMap<String, String> = HashMap::new();

        let uri_str = format!(
            "{}/namespace/{DirectoryPath}",
            self.configuration.base_path,
            DirectoryPath = directory_path
        );

        headers.insert("If-Modified-Since".into(), if_modified_since.into());
        headers.insert("If-Unmodified-Since".into(), if_unmodified_since.into());
        custom_query(
            self.configuration.borrow(),
            &uri_str,
            &"",
            hyper::Method::HEAD,
            headers,
        )
    }

    fn get_directory_contents(
        &self,
        directory_path: &str,
        detail: &str,
        limit: i32,
        resume: &str,
        sort: &str,
        dir: &str,
        _type: &str,
        hidden: bool,
    ) -> Box<dyn Future<Item = crate::models::NamespaceObjects, Error = Error>> {
        let q = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("detail", &detail.to_string())
            .append_pair("limit", &limit.to_string())
            .append_pair("resume", &resume.to_string())
            .append_pair("sort", &sort.to_string())
            .append_pair("dir", &dir.to_string())
            .append_pair("type", &_type.to_string())
            .append_pair("hidden", &hidden.to_string())
            .finish();
        let uri_str = format!(
            "{}/namespace/{DirectoryPath}?{}",
            self.configuration.base_path,
            q,
            DirectoryPath = directory_path
        );
        query(
            self.configuration.borrow(),
            &uri_str,
            &"",
            hyper::Method::GET,
        )
    }

    fn get_directory_metadata(
        &self,
        directory_metadata_path: &str,
        metadata: bool,
    ) -> Box<dyn Future<Item = crate::models::NamespaceMetadataList, Error = Error>> {

        let q = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("metadata", &metadata.to_string())
            .finish();
        let uri_str = format!(
            "{}/namespace/{DirectoryMetadataPath}?{}",
            self.configuration.base_path,
            q,
            DirectoryMetadataPath = directory_metadata_path
        );
        query(
            self.configuration.borrow(),
            &uri_str,
            &"",
            hyper::Method::GET,
        )
    }

    fn get_file_attributes(
        &self,
        file_path: &str,
        if_modified_since: &str,
        if_unmodified_since: &str,
    ) -> Box<dyn Future<Item = crate::models::Empty, Error = Error>> {
        let uri_str = format!(
            "{}/namespace/{FilePath}",
            self.configuration.base_path,
            FilePath = file_path
        );
        let mut headers: HashMap<String, String> = HashMap::new();

        headers.insert("If-Modified-Since".into(), if_modified_since.into());
        headers.insert("If-Unmodified-Since".into(), if_unmodified_since.into());
        custom_query(
            self.configuration.borrow(),
            &uri_str,
            &"",
            hyper::Method::HEAD,
            headers,
        )
    }

    fn get_file_contents(
        &self,
        file_path: &str,
        range: &str,
        if_modified_since: &str,
        if_unmodified_since: &str,
    ) -> Box<dyn Future<Item = crate::models::Empty, Error = Error>> {
        let uri_str = format!(
            "{}/namespace/{FilePath}",
            self.configuration.base_path,
            FilePath = file_path
        );

        let mut headers: HashMap<String, String> = HashMap::new();
        headers.insert("Range".to_string(), range.into());
        headers.insert("If-Modified-Since".to_string(), if_modified_since.into());
        headers.insert(
            "If-Unmodified-Since".to_string(),
            if_unmodified_since.into(),
        );

        custom_query(
            self.configuration.borrow(),
            &uri_str,
            &"",
            hyper::Method::GET,
            headers,
        )
    }

    fn get_file_metadata(
        &self,
        file_metadata_path: &str,
        metadata: bool,
    ) -> Box<dyn Future<Item = crate::models::NamespaceMetadataList, Error = Error>> {
        let q = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("metadata", &metadata.to_string())
            .finish();
        let uri_str = format!(
            "{}/namespace/{FileMetadataPath}?{}",
            self.configuration.base_path,
            q,
            FileMetadataPath = file_metadata_path
        );
        query(
            self.configuration.borrow(),
            &uri_str,
            &"",
            hyper::Method::GET,
        )
    }

    fn get_worm_properties(
        &self,
        worm_file_path: &str,
        worm: bool,
    ) -> Box<dyn Future<Item = crate::models::WormProperties, Error = Error>> {
        let q = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("worm", &worm.to_string())
            .finish();
        let uri_str = format!(
            "{}/namespace/{WormFilePath}?{}",
            self.configuration.base_path,
            q,
            WormFilePath = worm_file_path
        );
        query(
            self.configuration.borrow(),
            &uri_str,
            &"",
            hyper::Method::GET,
        )
    }

    fn list_access_points(
        &self,
        versions: bool,
    ) -> Box<dyn Future<Item = crate::models::NamespaceAccessPoints, Error = Error>> {
        let q = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("versions", &versions.to_string())
            .finish();
        let uri_str = format!("{}/namespace?{}", self.configuration.base_path, q);
        query(
            self.configuration.borrow(),
            &uri_str,
            &"",
            hyper::Method::GET,
        )
    }

    fn move_directory(
        &self,
        directory_path: &str,
        x_isi_ifs_set_location: &str,
    ) -> Box<dyn Future<Item = crate::models::Empty, Error = Error>> {
        let mut headers: HashMap<String, String> = HashMap::new();
        headers.insert(
            "x-isi-ifs-set-location".into(),
            x_isi_ifs_set_location.into(),
        );

        let uri_str = format!(
            "{}/namespace/{DirectoryPath}",
            self.configuration.base_path,
            DirectoryPath = directory_path
        );

        custom_query(
            self.configuration.borrow(),
            &uri_str,
            &"",
            hyper::Method::POST,
            headers,
        )
    }

    fn move_file(
        &self,
        file_path: &str,
        x_isi_ifs_set_location: &str,
    ) -> Box<dyn Future<Item = crate::models::Empty, Error = Error>> {
        let mut headers: HashMap<String, String> = HashMap::new();
        headers.insert(
            "x-isi-ifs-set-location".into(),
            x_isi_ifs_set_location.into(),
        );

        let uri_str = format!(
            "{}/namespace/{FilePath}",
            self.configuration.base_path,
            FilePath = file_path
        );

        custom_query(
            self.configuration.borrow(),
            &uri_str,
            &"",
            hyper::Method::POST,
            headers,
        )
    }

    fn query_directory(
        &self,
        query_path: &str,
        query: bool,
        directory_query: crate::models::DirectoryQuery,
        limit: i32,
        detail: &str,
        max_depth: i32,
    ) -> Box<dyn Future<Item = crate::models::NamespaceObjects, Error = Error>> {
        let q = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("query", &query.to_string())
            .append_pair("limit", &limit.to_string())
            .append_pair("detail", &detail.to_string())
            .append_pair("max-depth", &max_depth.to_string())
            .finish();
        let uri_str = format!(
            "{}/namespace/{QueryPath}?{}",
            self.configuration.base_path,
            q,
            QueryPath = query_path
        );
        super::query(
            self.configuration.borrow(),
            &uri_str,
            &directory_query,
            hyper::Method::POST,
        )
    }

    fn set_acl(
        &self,
        namespace_path: &str,
        acl: bool,
        namespace_acl: crate::models::NamespaceAcl,
        nsaccess: bool,
    ) -> Box<dyn Future<Item = crate::models::Empty, Error = Error>> {
        let q = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("acl", &acl.to_string())
            .append_pair("nsaccess", &nsaccess.to_string())
            .finish();
        let uri_str = format!(
            "{}/namespace/{NamespacePath}?{}",
            self.configuration.base_path,
            q,
            NamespacePath = namespace_path
        );

        query(
            self.configuration.borrow(),
            &uri_str,
            &namespace_acl,
            hyper::Method::PUT,
        )
    }

    fn set_directory_metadata(
        &self,
        directory_metadata_path: &str,
        metadata: bool,
        directory_metadata: crate::models::NamespaceMetadata,
    ) -> Box<dyn Future<Item = crate::models::Empty, Error = Error>> {
        let q = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("metadata", &metadata.to_string())
            .finish();
        let uri_str = format!(
            "{}/namespace/{DirectoryMetadataPath}?{}",
            self.configuration.base_path,
            q,
            DirectoryMetadataPath = directory_metadata_path
        );

        query(
            self.configuration.borrow(),
            &uri_str,
            &directory_metadata,
            hyper::Method::PUT,
        )
    }

    fn set_file_metadata(
        &self,
        file_metadata_path: &str,
        metadata: bool,
        file_metadata: crate::models::NamespaceMetadata,
    ) -> Box<dyn Future<Item = crate::models::Empty, Error = Error>> {
        let q = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("metadata", &metadata.to_string())
            .finish();
        let uri_str = format!(
            "{}/namespace/{FileMetadataPath}?{}",
            self.configuration.base_path,
            q,
            FileMetadataPath = file_metadata_path
        );

        query(
            self.configuration.borrow(),
            &uri_str,
            &file_metadata,
            hyper::Method::PUT,
        )
    }

    fn set_worm_properties(
        &self,
        worm_file_path: &str,
        worm: bool,
        worm_properties: crate::models::WormCreateParams,
    ) -> Box<dyn Future<Item = crate::models::Empty, Error = Error>> {
        let q = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("worm", &worm.to_string())
            .finish();
        let uri_str = format!(
            "{}/namespace/{WormFilePath}?{}",
            self.configuration.base_path,
            q,
            WormFilePath = worm_file_path
        );
        query(
            self.configuration.borrow(),
            &uri_str,
            &worm_properties,
            hyper::Method::PUT,
        )
    }
}
