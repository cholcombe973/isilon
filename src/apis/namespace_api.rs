/*
 * Isilon SDK
 *
 * Isilon SDK - Language bindings for the OneFS API
 *
 * OpenAPI spec version: 5
 * Contact: sdk@isilon.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

use std::borrow::Borrow;
use std::rc::Rc;

use futures;
use futures::{Future, Stream};
use hyper;
use serde_json;

use super::{configuration, Error};

pub struct NamespaceApiClient<C: hyper::client::Connect> {
    configuration: Rc<configuration::Configuration<C>>,
}

impl<C: hyper::client::Connect> NamespaceApiClient<C> {
    pub fn new(configuration: Rc<configuration::Configuration<C>>) -> NamespaceApiClient<C> {
        NamespaceApiClient {
            configuration: configuration,
        }
    }
}

pub trait NamespaceApi {
    fn copy_directory(
        &self,
        directory_copy_target: &str,
        x_isi_ifs_copy_source: &str,
        overwrite: bool,
        merge: bool,
        _continue: bool,
    ) -> Box<Future<Item = ::models::CopyErrors, Error = Error>>;
    fn copy_file(
        &self,
        file_copy_target: &str,
        x_isi_ifs_copy_source: &str,
        clone: bool,
        snapshot: &str,
        overwrite: bool,
    ) -> Box<Future<Item = ::models::CopyErrors, Error = Error>>;
    fn create_access_point(
        &self,
        access_point_name: &str,
        access_point: ::models::AccessPointCreateParams,
    ) -> Box<Future<Item = ::models::Empty, Error = Error>>;
    fn create_directory(
        &self,
        directory_path: &str,
        x_isi_ifs_target_type: &str,
        x_isi_ifs_access_control: &str,
        x_isi_ifs_node_pool_name: &str,
        recursive: bool,
        overwrite: bool,
    ) -> Box<Future<Item = ::models::Empty, Error = Error>>;
    fn create_file(
        &self,
        file_path: &str,
        x_isi_ifs_target_type: &str,
        file_contents: &str,
        x_isi_ifs_access_control: &str,
        content_encoding: &str,
        content_type: &str,
        overwrite: bool,
    ) -> Box<Future<Item = ::models::Empty, Error = Error>>;
    fn delete_access_point(
        &self,
        access_point_name: &str,
    ) -> Box<Future<Item = ::models::Empty, Error = Error>>;
    fn delete_directory(
        &self,
        directory_path: &str,
        recursive: bool,
    ) -> Box<Future<Item = ::models::Empty, Error = Error>>;
    fn delete_file(&self, file_path: &str) -> Box<Future<Item = ::models::Empty, Error = Error>>;
    fn get_acl(
        &self,
        namespace_path: &str,
        acl: bool,
        nsaccess: bool,
    ) -> Box<Future<Item = ::models::NamespaceAcl, Error = Error>>;
    fn get_directory_attributes(
        &self,
        directory_path: &str,
        if_modified_since: &str,
        if_unmodified_since: &str,
    ) -> Box<Future<Item = ::models::Empty, Error = Error>>;
    fn get_directory_contents(
        &self,
        directory_path: &str,
        detail: &str,
        limit: i32,
        resume: &str,
        sort: &str,
        dir: &str,
        _type: &str,
        hidden: bool,
    ) -> Box<Future<Item = ::models::NamespaceObjects, Error = Error>>;
    fn get_directory_metadata(
        &self,
        directory_metadata_path: &str,
        metadata: bool,
    ) -> Box<Future<Item = ::models::NamespaceMetadataList, Error = Error>>;
    fn get_file_attributes(
        &self,
        file_path: &str,
        if_modified_since: &str,
        if_unmodified_since: &str,
    ) -> Box<Future<Item = ::models::Empty, Error = Error>>;
    fn get_file_contents(
        &self,
        file_path: &str,
        range: &str,
        if_modified_since: &str,
        if_unmodified_since: &str,
    ) -> Box<Future<Item = ::models::Empty, Error = Error>>;
    fn get_file_metadata(
        &self,
        file_metadata_path: &str,
        metadata: bool,
    ) -> Box<Future<Item = ::models::NamespaceMetadataList, Error = Error>>;
    fn get_worm_properties(
        &self,
        worm_file_path: &str,
        worm: bool,
    ) -> Box<Future<Item = ::models::WormProperties, Error = Error>>;
    fn list_access_points(
        &self,
        versions: bool,
    ) -> Box<Future<Item = ::models::NamespaceAccessPoints, Error = Error>>;
    fn move_directory(
        &self,
        directory_path: &str,
        x_isi_ifs_set_location: &str,
    ) -> Box<Future<Item = ::models::Empty, Error = Error>>;
    fn move_file(
        &self,
        file_path: &str,
        x_isi_ifs_set_location: &str,
    ) -> Box<Future<Item = ::models::Empty, Error = Error>>;
    fn query_directory(
        &self,
        query_path: &str,
        query: bool,
        directory_query: ::models::DirectoryQuery,
        limit: i32,
        detail: &str,
        max_depth: i32,
    ) -> Box<Future<Item = ::models::NamespaceObjects, Error = Error>>;
    fn set_acl(
        &self,
        namespace_path: &str,
        acl: bool,
        namespace_acl: ::models::NamespaceAcl,
        nsaccess: bool,
    ) -> Box<Future<Item = ::models::Empty, Error = Error>>;
    fn set_directory_metadata(
        &self,
        directory_metadata_path: &str,
        metadata: bool,
        directory_metadata: ::models::NamespaceMetadata,
    ) -> Box<Future<Item = ::models::Empty, Error = Error>>;
    fn set_file_metadata(
        &self,
        file_metadata_path: &str,
        metadata: bool,
        file_metadata: ::models::NamespaceMetadata,
    ) -> Box<Future<Item = ::models::Empty, Error = Error>>;
    fn set_worm_properties(
        &self,
        worm_file_path: &str,
        worm: bool,
        worm_properties: ::models::WormCreateParams,
    ) -> Box<Future<Item = ::models::Empty, Error = Error>>;
}

impl<C: hyper::client::Connect> NamespaceApi for NamespaceApiClient<C> {
    fn copy_directory(
        &self,
        directory_copy_target: &str,
        x_isi_ifs_copy_source: &str,
        overwrite: bool,
        merge: bool,
        _continue: bool,
    ) -> Box<Future<Item = ::models::CopyErrors, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Put;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("overwrite", &overwrite.to_string())
            .append_pair("merge", &merge.to_string())
            .append_pair("continue", &_continue.to_string())
            .finish();
        let uri_str = format!(
            "{}/namespace/{DirectoryCopyTarget}{}",
            configuration.base_path,
            query,
            DirectoryCopyTarget = directory_copy_target
        );

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());
        configuration.set_session(&mut req).unwrap();

        {
            let mut headers = req.headers_mut();
            headers.set_raw("x-isi-ifs-copy-source", x_isi_ifs_copy_source);
        }

        // send request
        Box::new(
            configuration
                .client
                .request(req)
                .and_then(|res| res.body().concat2())
                .map_err(|e| Error::from(e))
                .and_then(|body| {
                    let parsed: Result<::models::CopyErrors, _> = serde_json::from_slice(&body);
                    parsed.map_err(|e| Error::from(e))
                })
                .map_err(|e| Error::from(e)),
        )
    }

    fn copy_file(
        &self,
        file_copy_target: &str,
        x_isi_ifs_copy_source: &str,
        clone: bool,
        snapshot: &str,
        overwrite: bool,
    ) -> Box<Future<Item = ::models::CopyErrors, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Put;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("clone", &clone.to_string())
            .append_pair("snapshot", &snapshot.to_string())
            .append_pair("overwrite", &overwrite.to_string())
            .finish();
        let uri_str = format!(
            "{}/namespace/{FileCopyTarget}{}",
            configuration.base_path,
            query,
            FileCopyTarget = file_copy_target
        );

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());
        configuration.set_session(&mut req).unwrap();

        {
            let mut headers = req.headers_mut();
            headers.set_raw("x-isi-ifs-copy-source", x_isi_ifs_copy_source);
        }

        // send request
        Box::new(
            configuration
                .client
                .request(req)
                .and_then(|res| res.body().concat2())
                .map_err(|e| Error::from(e))
                .and_then(|body| {
                    let parsed: Result<::models::CopyErrors, _> = serde_json::from_slice(&body);
                    parsed.map_err(|e| Error::from(e))
                })
                .map_err(|e| Error::from(e)),
        )
    }

    fn create_access_point(
        &self,
        access_point_name: &str,
        access_point: ::models::AccessPointCreateParams,
    ) -> Box<Future<Item = ::models::Empty, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Put;

        let uri_str = format!(
            "{}/namespace/{AccessPointName}",
            configuration.base_path,
            AccessPointName = access_point_name
        );

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());
        configuration.set_session(&mut req).unwrap();

        let serialized = serde_json::to_string(&access_point).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut()
            .set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
            configuration
                .client
                .request(req)
                .and_then(|res| res.body().concat2())
                .map_err(|e| Error::from(e))
                .and_then(|body| {
                    let parsed: Result<::models::Empty, _> = serde_json::from_slice(&body);
                    parsed.map_err(|e| Error::from(e))
                })
                .map_err(|e| Error::from(e)),
        )
    }

    fn create_directory(
        &self,
        directory_path: &str,
        x_isi_ifs_target_type: &str,
        x_isi_ifs_access_control: &str,
        x_isi_ifs_node_pool_name: &str,
        recursive: bool,
        overwrite: bool,
    ) -> Box<Future<Item = ::models::Empty, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Put;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("recursive", &recursive.to_string())
            .append_pair("overwrite", &overwrite.to_string())
            .finish();
        let uri_str = format!(
            "{}/namespace/{DirectoryPath}{}",
            configuration.base_path,
            query,
            DirectoryPath = directory_path
        );

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());
        configuration.set_session(&mut req).unwrap();

        {
            let mut headers = req.headers_mut();
            headers.set_raw("x-isi-ifs-target-type", x_isi_ifs_target_type);
            headers.set_raw("x-isi-ifs-access-control", x_isi_ifs_access_control);
            headers.set_raw("x-isi-ifs-node-pool-name", x_isi_ifs_node_pool_name);
        }

        // send request
        Box::new(
            configuration
                .client
                .request(req)
                .and_then(|res| res.body().concat2())
                .map_err(|e| Error::from(e))
                .and_then(|body| {
                    let parsed: Result<::models::Empty, _> = serde_json::from_slice(&body);
                    parsed.map_err(|e| Error::from(e))
                })
                .map_err(|e| Error::from(e)),
        )
    }

    fn create_file(
        &self,
        file_path: &str,
        x_isi_ifs_target_type: &str,
        file_contents: &str,
        x_isi_ifs_access_control: &str,
        content_encoding: &str,
        content_type: &str,
        overwrite: bool,
    ) -> Box<Future<Item = ::models::Empty, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Put;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("overwrite", &overwrite.to_string())
            .finish();
        let uri_str = format!(
            "{}/namespace/{FilePath}{}",
            configuration.base_path,
            query,
            FilePath = file_path
        );

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());
        configuration.set_session(&mut req).unwrap();

        {
            let mut headers = req.headers_mut();
            headers.set_raw("x-isi-ifs-target-type", x_isi_ifs_target_type);
            headers.set_raw("x-isi-ifs-access-control", x_isi_ifs_access_control);
            headers.set_raw("Content-Encoding", content_encoding);
            headers.set_raw("Content-Type", content_type);
        }

        let serialized = serde_json::to_string(&file_contents).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut()
            .set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
            configuration
                .client
                .request(req)
                .and_then(|res| res.body().concat2())
                .map_err(|e| Error::from(e))
                .and_then(|body| {
                    let parsed: Result<::models::Empty, _> = serde_json::from_slice(&body);
                    parsed.map_err(|e| Error::from(e))
                })
                .map_err(|e| Error::from(e)),
        )
    }

    fn delete_access_point(
        &self,
        access_point_name: &str,
    ) -> Box<Future<Item = ::models::Empty, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Delete;

        let uri_str = format!(
            "{}/namespace/{AccessPointName}",
            configuration.base_path,
            AccessPointName = access_point_name
        );

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());
        configuration.set_session(&mut req).unwrap();

        // send request
        Box::new(
            configuration
                .client
                .request(req)
                .and_then(|res| res.body().concat2())
                .map_err(|e| Error::from(e))
                .and_then(|body| {
                    let parsed: Result<::models::Empty, _> = serde_json::from_slice(&body);
                    parsed.map_err(|e| Error::from(e))
                })
                .map_err(|e| Error::from(e)),
        )
    }

    fn delete_directory(
        &self,
        directory_path: &str,
        recursive: bool,
    ) -> Box<Future<Item = ::models::Empty, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Delete;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("recursive", &recursive.to_string())
            .finish();
        let uri_str = format!(
            "{}/namespace/{DirectoryPath}{}",
            configuration.base_path,
            query,
            DirectoryPath = directory_path
        );

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());
        configuration.set_session(&mut req).unwrap();

        // send request
        Box::new(
            configuration
                .client
                .request(req)
                .and_then(|res| res.body().concat2())
                .map_err(|e| Error::from(e))
                .and_then(|body| {
                    let parsed: Result<::models::Empty, _> = serde_json::from_slice(&body);
                    parsed.map_err(|e| Error::from(e))
                })
                .map_err(|e| Error::from(e)),
        )
    }

    fn delete_file(&self, file_path: &str) -> Box<Future<Item = ::models::Empty, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Delete;

        let uri_str = format!(
            "{}/namespace/{FilePath}",
            configuration.base_path,
            FilePath = file_path
        );

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());
        configuration.set_session(&mut req).unwrap();

        // send request
        Box::new(
            configuration
                .client
                .request(req)
                .and_then(|res| res.body().concat2())
                .map_err(|e| Error::from(e))
                .and_then(|body| {
                    let parsed: Result<::models::Empty, _> = serde_json::from_slice(&body);
                    parsed.map_err(|e| Error::from(e))
                })
                .map_err(|e| Error::from(e)),
        )
    }

    fn get_acl(
        &self,
        namespace_path: &str,
        acl: bool,
        nsaccess: bool,
    ) -> Box<Future<Item = ::models::NamespaceAcl, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("acl", &acl.to_string())
            .append_pair("nsaccess", &nsaccess.to_string())
            .finish();
        let uri_str = format!(
            "{}/namespace/{NamespacePath}{}",
            configuration.base_path,
            query,
            NamespacePath = namespace_path
        );

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());
        configuration.set_session(&mut req).unwrap();

        // send request
        Box::new(
            configuration
                .client
                .request(req)
                .and_then(|res| res.body().concat2())
                .map_err(|e| Error::from(e))
                .and_then(|body| {
                    let parsed: Result<::models::NamespaceAcl, _> = serde_json::from_slice(&body);
                    parsed.map_err(|e| Error::from(e))
                })
                .map_err(|e| Error::from(e)),
        )
    }

    fn get_directory_attributes(
        &self,
        directory_path: &str,
        if_modified_since: &str,
        if_unmodified_since: &str,
    ) -> Box<Future<Item = ::models::Empty, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Head;

        let uri_str = format!(
            "{}/namespace/{DirectoryPath}",
            configuration.base_path,
            DirectoryPath = directory_path
        );

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());
        configuration.set_session(&mut req).unwrap();

        {
            let mut headers = req.headers_mut();
            headers.set_raw("If-Modified-Since", if_modified_since);
            headers.set_raw("If-Unmodified-Since", if_unmodified_since);
        }

        // send request
        Box::new(
            configuration
                .client
                .request(req)
                .and_then(|res| res.body().concat2())
                .map_err(|e| Error::from(e))
                .and_then(|body| {
                    let parsed: Result<::models::Empty, _> = serde_json::from_slice(&body);
                    parsed.map_err(|e| Error::from(e))
                })
                .map_err(|e| Error::from(e)),
        )
    }

    fn get_directory_contents(
        &self,
        directory_path: &str,
        detail: &str,
        limit: i32,
        resume: &str,
        sort: &str,
        dir: &str,
        _type: &str,
        hidden: bool,
    ) -> Box<Future<Item = ::models::NamespaceObjects, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("detail", &detail.to_string())
            .append_pair("limit", &limit.to_string())
            .append_pair("resume", &resume.to_string())
            .append_pair("sort", &sort.to_string())
            .append_pair("dir", &dir.to_string())
            .append_pair("type", &_type.to_string())
            .append_pair("hidden", &hidden.to_string())
            .finish();
        let uri_str = format!(
            "{}/namespace/{DirectoryPath}{}",
            configuration.base_path,
            query,
            DirectoryPath = directory_path
        );

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());
        configuration.set_session(&mut req).unwrap();

        // send request
        Box::new(
            configuration
                .client
                .request(req)
                .and_then(|res| res.body().concat2())
                .map_err(|e| Error::from(e))
                .and_then(|body| {
                    let parsed: Result<::models::NamespaceObjects, _> =
                        serde_json::from_slice(&body);
                    parsed.map_err(|e| Error::from(e))
                })
                .map_err(|e| Error::from(e)),
        )
    }

    fn get_directory_metadata(
        &self,
        directory_metadata_path: &str,
        metadata: bool,
    ) -> Box<Future<Item = ::models::NamespaceMetadataList, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("metadata", &metadata.to_string())
            .finish();
        let uri_str = format!(
            "{}/namespace/{DirectoryMetadataPath}{}",
            configuration.base_path,
            query,
            DirectoryMetadataPath = directory_metadata_path
        );

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());
        configuration.set_session(&mut req).unwrap();

        // send request
        Box::new(
            configuration
                .client
                .request(req)
                .and_then(|res| res.body().concat2())
                .map_err(|e| Error::from(e))
                .and_then(|body| {
                    let parsed: Result<::models::NamespaceMetadataList, _> =
                        serde_json::from_slice(&body);
                    parsed.map_err(|e| Error::from(e))
                })
                .map_err(|e| Error::from(e)),
        )
    }

    fn get_file_attributes(
        &self,
        file_path: &str,
        if_modified_since: &str,
        if_unmodified_since: &str,
    ) -> Box<Future<Item = ::models::Empty, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Head;

        let uri_str = format!(
            "{}/namespace/{FilePath}",
            configuration.base_path,
            FilePath = file_path
        );

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());
        configuration.set_session(&mut req).unwrap();

        {
            let mut headers = req.headers_mut();
            headers.set_raw("If-Modified-Since", if_modified_since);
            headers.set_raw("If-Unmodified-Since", if_unmodified_since);
        }

        // send request
        Box::new(
            configuration
                .client
                .request(req)
                .and_then(|res| res.body().concat2())
                .map_err(|e| Error::from(e))
                .and_then(|body| {
                    let parsed: Result<::models::Empty, _> = serde_json::from_slice(&body);
                    parsed.map_err(|e| Error::from(e))
                })
                .map_err(|e| Error::from(e)),
        )
    }

    fn get_file_contents(
        &self,
        file_path: &str,
        range: &str,
        if_modified_since: &str,
        if_unmodified_since: &str,
    ) -> Box<Future<Item = ::models::Empty, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let uri_str = format!(
            "{}/namespace/{FilePath}",
            configuration.base_path,
            FilePath = file_path
        );

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());
        configuration.set_session(&mut req).unwrap();

        {
            let mut headers = req.headers_mut();
            headers.set_raw("Range", range);
            headers.set_raw("If-Modified-Since", if_modified_since);
            headers.set_raw("If-Unmodified-Since", if_unmodified_since);
        }

        // send request
        Box::new(
            configuration
                .client
                .request(req)
                .and_then(|res| res.body().concat2())
                .map_err(|e| Error::from(e))
                .and_then(|body| {
                    let parsed: Result<::models::Empty, _> = serde_json::from_slice(&body);
                    parsed.map_err(|e| Error::from(e))
                })
                .map_err(|e| Error::from(e)),
        )
    }

    fn get_file_metadata(
        &self,
        file_metadata_path: &str,
        metadata: bool,
    ) -> Box<Future<Item = ::models::NamespaceMetadataList, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("metadata", &metadata.to_string())
            .finish();
        let uri_str = format!(
            "{}/namespace/{FileMetadataPath}{}",
            configuration.base_path,
            query,
            FileMetadataPath = file_metadata_path
        );

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());
        configuration.set_session(&mut req).unwrap();

        // send request
        Box::new(
            configuration
                .client
                .request(req)
                .and_then(|res| res.body().concat2())
                .map_err(|e| Error::from(e))
                .and_then(|body| {
                    let parsed: Result<::models::NamespaceMetadataList, _> =
                        serde_json::from_slice(&body);
                    parsed.map_err(|e| Error::from(e))
                })
                .map_err(|e| Error::from(e)),
        )
    }

    fn get_worm_properties(
        &self,
        worm_file_path: &str,
        worm: bool,
    ) -> Box<Future<Item = ::models::WormProperties, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("worm", &worm.to_string())
            .finish();
        let uri_str = format!(
            "{}/namespace/{WormFilePath}{}",
            configuration.base_path,
            query,
            WormFilePath = worm_file_path
        );

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());
        configuration.set_session(&mut req).unwrap();

        // send request
        Box::new(
            configuration
                .client
                .request(req)
                .and_then(|res| res.body().concat2())
                .map_err(|e| Error::from(e))
                .and_then(|body| {
                    let parsed: Result<::models::WormProperties, _> = serde_json::from_slice(&body);
                    parsed.map_err(|e| Error::from(e))
                })
                .map_err(|e| Error::from(e)),
        )
    }

    fn list_access_points(
        &self,
        versions: bool,
    ) -> Box<Future<Item = ::models::NamespaceAccessPoints, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Get;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("versions", &versions.to_string())
            .finish();
        let uri_str = format!("{}/namespace{}", configuration.base_path, query);

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());
        configuration.set_session(&mut req).unwrap();

        // send request
        Box::new(
            configuration
                .client
                .request(req)
                .and_then(|res| res.body().concat2())
                .map_err(|e| Error::from(e))
                .and_then(|body| {
                    let parsed: Result<::models::NamespaceAccessPoints, _> =
                        serde_json::from_slice(&body);
                    parsed.map_err(|e| Error::from(e))
                })
                .map_err(|e| Error::from(e)),
        )
    }

    fn move_directory(
        &self,
        directory_path: &str,
        x_isi_ifs_set_location: &str,
    ) -> Box<Future<Item = ::models::Empty, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Post;

        let uri_str = format!(
            "{}/namespace/{DirectoryPath}",
            configuration.base_path,
            DirectoryPath = directory_path
        );

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());
        configuration.set_session(&mut req).unwrap();

        {
            let mut headers = req.headers_mut();
            headers.set_raw("x-isi-ifs-set-location", x_isi_ifs_set_location);
        }

        // send request
        Box::new(
            configuration
                .client
                .request(req)
                .and_then(|res| res.body().concat2())
                .map_err(|e| Error::from(e))
                .and_then(|body| {
                    let parsed: Result<::models::Empty, _> = serde_json::from_slice(&body);
                    parsed.map_err(|e| Error::from(e))
                })
                .map_err(|e| Error::from(e)),
        )
    }

    fn move_file(
        &self,
        file_path: &str,
        x_isi_ifs_set_location: &str,
    ) -> Box<Future<Item = ::models::Empty, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Post;

        let uri_str = format!(
            "{}/namespace/{FilePath}",
            configuration.base_path,
            FilePath = file_path
        );

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());
        configuration.set_session(&mut req).unwrap();

        {
            let mut headers = req.headers_mut();
            headers.set_raw("x-isi-ifs-set-location", x_isi_ifs_set_location);
        }

        // send request
        Box::new(
            configuration
                .client
                .request(req)
                .and_then(|res| res.body().concat2())
                .map_err(|e| Error::from(e))
                .and_then(|body| {
                    let parsed: Result<::models::Empty, _> = serde_json::from_slice(&body);
                    parsed.map_err(|e| Error::from(e))
                })
                .map_err(|e| Error::from(e)),
        )
    }

    fn query_directory(
        &self,
        query_path: &str,
        query: bool,
        directory_query: ::models::DirectoryQuery,
        limit: i32,
        detail: &str,
        max_depth: i32,
    ) -> Box<Future<Item = ::models::NamespaceObjects, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Post;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("query", &query.to_string())
            .append_pair("limit", &limit.to_string())
            .append_pair("detail", &detail.to_string())
            .append_pair("max-depth", &max_depth.to_string())
            .finish();
        let uri_str = format!(
            "{}/namespace/{QueryPath}{}",
            configuration.base_path,
            query,
            QueryPath = query_path
        );

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());
        configuration.set_session(&mut req).unwrap();

        let serialized = serde_json::to_string(&directory_query).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut()
            .set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
            configuration
                .client
                .request(req)
                .and_then(|res| res.body().concat2())
                .map_err(|e| Error::from(e))
                .and_then(|body| {
                    let parsed: Result<::models::NamespaceObjects, _> =
                        serde_json::from_slice(&body);
                    parsed.map_err(|e| Error::from(e))
                })
                .map_err(|e| Error::from(e)),
        )
    }

    fn set_acl(
        &self,
        namespace_path: &str,
        acl: bool,
        namespace_acl: ::models::NamespaceAcl,
        nsaccess: bool,
    ) -> Box<Future<Item = ::models::Empty, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Put;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("acl", &acl.to_string())
            .append_pair("nsaccess", &nsaccess.to_string())
            .finish();
        let uri_str = format!(
            "{}/namespace/{NamespacePath}{}",
            configuration.base_path,
            query,
            NamespacePath = namespace_path
        );

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());
        configuration.set_session(&mut req).unwrap();

        let serialized = serde_json::to_string(&namespace_acl).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut()
            .set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
            configuration
                .client
                .request(req)
                .and_then(|res| res.body().concat2())
                .map_err(|e| Error::from(e))
                .and_then(|body| {
                    let parsed: Result<::models::Empty, _> = serde_json::from_slice(&body);
                    parsed.map_err(|e| Error::from(e))
                })
                .map_err(|e| Error::from(e)),
        )
    }

    fn set_directory_metadata(
        &self,
        directory_metadata_path: &str,
        metadata: bool,
        directory_metadata: ::models::NamespaceMetadata,
    ) -> Box<Future<Item = ::models::Empty, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Put;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("metadata", &metadata.to_string())
            .finish();
        let uri_str = format!(
            "{}/namespace/{DirectoryMetadataPath}{}",
            configuration.base_path,
            query,
            DirectoryMetadataPath = directory_metadata_path
        );

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());
        configuration.set_session(&mut req).unwrap();

        let serialized = serde_json::to_string(&directory_metadata).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut()
            .set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
            configuration
                .client
                .request(req)
                .and_then(|res| res.body().concat2())
                .map_err(|e| Error::from(e))
                .and_then(|body| {
                    let parsed: Result<::models::Empty, _> = serde_json::from_slice(&body);
                    parsed.map_err(|e| Error::from(e))
                })
                .map_err(|e| Error::from(e)),
        )
    }

    fn set_file_metadata(
        &self,
        file_metadata_path: &str,
        metadata: bool,
        file_metadata: ::models::NamespaceMetadata,
    ) -> Box<Future<Item = ::models::Empty, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Put;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("metadata", &metadata.to_string())
            .finish();
        let uri_str = format!(
            "{}/namespace/{FileMetadataPath}{}",
            configuration.base_path,
            query,
            FileMetadataPath = file_metadata_path
        );

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());
        configuration.set_session(&mut req).unwrap();

        let serialized = serde_json::to_string(&file_metadata).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut()
            .set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
            configuration
                .client
                .request(req)
                .and_then(|res| res.body().concat2())
                .map_err(|e| Error::from(e))
                .and_then(|body| {
                    let parsed: Result<::models::Empty, _> = serde_json::from_slice(&body);
                    parsed.map_err(|e| Error::from(e))
                })
                .map_err(|e| Error::from(e)),
        )
    }

    fn set_worm_properties(
        &self,
        worm_file_path: &str,
        worm: bool,
        worm_properties: ::models::WormCreateParams,
    ) -> Box<Future<Item = ::models::Empty, Error = Error>> {
        let configuration: &configuration::Configuration<C> = self.configuration.borrow();

        let method = hyper::Method::Put;

        let query = ::url::form_urlencoded::Serializer::new(String::new())
            .append_pair("worm", &worm.to_string())
            .finish();
        let uri_str = format!(
            "{}/namespace/{WormFilePath}{}",
            configuration.base_path,
            query,
            WormFilePath = worm_file_path
        );

        let uri = uri_str.parse();
        // TODO(farcaller): handle error
        // if let Err(e) = uri {
        //     return Box::new(futures::future::err(e));
        // }
        let mut req = hyper::Request::new(method, uri.unwrap());
        configuration.set_session(&mut req).unwrap();

        let serialized = serde_json::to_string(&worm_properties).unwrap();
        req.headers_mut().set(hyper::header::ContentType::json());
        req.headers_mut()
            .set(hyper::header::ContentLength(serialized.len() as u64));
        req.set_body(serialized);

        // send request
        Box::new(
            configuration
                .client
                .request(req)
                .and_then(|res| res.body().concat2())
                .map_err(|e| Error::from(e))
                .and_then(|body| {
                    let parsed: Result<::models::Empty, _> = serde_json::from_slice(&body);
                    parsed.map_err(|e| Error::from(e))
                })
                .map_err(|e| Error::from(e)),
        )
    }
}
