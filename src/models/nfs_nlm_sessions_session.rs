/* 
 * Isilon SDK
 *
 * Isilon SDK - Language bindings for the OneFS API
 *
 * OpenAPI spec version: 5
 * Contact: sdk@isilon.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */


#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct NfsNlmSessionsSession {
  #[serde(rename = "delegates")]
  delegates: Option<Vec<i32>>,
  /// The sort of host that this entry represents
  #[serde(rename = "host_type")]
  host_type: Option<String>,
  /// The host being monitored
  #[serde(rename = "hostname")]
  hostname: Option<String>,
  /// Whether or not the client is actively being monitored
  #[serde(rename = "is_active")]
  is_active: Option<bool>,
  /// Unix time in seconds that the client was last modified (monitored or unmonitored)
  #[serde(rename = "last_modified")]
  last_modified: Option<i32>,
  /// An IP address for which NSM has client records
  #[serde(rename = "node_ip")]
  node_ip: Option<String>,
  /// Number of times we will attempt to notify this client before giving up
  #[serde(rename = "notify_attempts_remaining")]
  notify_attempts_remaining: Option<i32>,
  /// Last error recieved attempting to notify this client
  #[serde(rename = "notify_error")]
  notify_error: Option<String>,
  /// Unix time in seconds when we last attempted to notify this clients
  #[serde(rename = "notify_last_attempt")]
  notify_last_attempt: Option<i32>
}

impl NfsNlmSessionsSession {
  pub fn new() -> NfsNlmSessionsSession {
    NfsNlmSessionsSession {
      delegates: None,
      host_type: None,
      hostname: None,
      is_active: None,
      last_modified: None,
      node_ip: None,
      notify_attempts_remaining: None,
      notify_error: None,
      notify_last_attempt: None
    }
  }

  pub fn set_delegates(&mut self, delegates: Vec<i32>) {
    self.delegates = Some(delegates);
  }

  pub fn with_delegates(mut self, delegates: Vec<i32>) -> NfsNlmSessionsSession {
    self.delegates = Some(delegates);
    self
  }

  pub fn delegates(&self) -> Option<&Vec<i32>> {
    self.delegates.as_ref()
  }

  pub fn reset_delegates(&mut self) {
    self.delegates = None;
  }

  pub fn set_host_type(&mut self, host_type: String) {
    self.host_type = Some(host_type);
  }

  pub fn with_host_type(mut self, host_type: String) -> NfsNlmSessionsSession {
    self.host_type = Some(host_type);
    self
  }

  pub fn host_type(&self) -> Option<&String> {
    self.host_type.as_ref()
  }

  pub fn reset_host_type(&mut self) {
    self.host_type = None;
  }

  pub fn set_hostname(&mut self, hostname: String) {
    self.hostname = Some(hostname);
  }

  pub fn with_hostname(mut self, hostname: String) -> NfsNlmSessionsSession {
    self.hostname = Some(hostname);
    self
  }

  pub fn hostname(&self) -> Option<&String> {
    self.hostname.as_ref()
  }

  pub fn reset_hostname(&mut self) {
    self.hostname = None;
  }

  pub fn set_is_active(&mut self, is_active: bool) {
    self.is_active = Some(is_active);
  }

  pub fn with_is_active(mut self, is_active: bool) -> NfsNlmSessionsSession {
    self.is_active = Some(is_active);
    self
  }

  pub fn is_active(&self) -> Option<&bool> {
    self.is_active.as_ref()
  }

  pub fn reset_is_active(&mut self) {
    self.is_active = None;
  }

  pub fn set_last_modified(&mut self, last_modified: i32) {
    self.last_modified = Some(last_modified);
  }

  pub fn with_last_modified(mut self, last_modified: i32) -> NfsNlmSessionsSession {
    self.last_modified = Some(last_modified);
    self
  }

  pub fn last_modified(&self) -> Option<&i32> {
    self.last_modified.as_ref()
  }

  pub fn reset_last_modified(&mut self) {
    self.last_modified = None;
  }

  pub fn set_node_ip(&mut self, node_ip: String) {
    self.node_ip = Some(node_ip);
  }

  pub fn with_node_ip(mut self, node_ip: String) -> NfsNlmSessionsSession {
    self.node_ip = Some(node_ip);
    self
  }

  pub fn node_ip(&self) -> Option<&String> {
    self.node_ip.as_ref()
  }

  pub fn reset_node_ip(&mut self) {
    self.node_ip = None;
  }

  pub fn set_notify_attempts_remaining(&mut self, notify_attempts_remaining: i32) {
    self.notify_attempts_remaining = Some(notify_attempts_remaining);
  }

  pub fn with_notify_attempts_remaining(mut self, notify_attempts_remaining: i32) -> NfsNlmSessionsSession {
    self.notify_attempts_remaining = Some(notify_attempts_remaining);
    self
  }

  pub fn notify_attempts_remaining(&self) -> Option<&i32> {
    self.notify_attempts_remaining.as_ref()
  }

  pub fn reset_notify_attempts_remaining(&mut self) {
    self.notify_attempts_remaining = None;
  }

  pub fn set_notify_error(&mut self, notify_error: String) {
    self.notify_error = Some(notify_error);
  }

  pub fn with_notify_error(mut self, notify_error: String) -> NfsNlmSessionsSession {
    self.notify_error = Some(notify_error);
    self
  }

  pub fn notify_error(&self) -> Option<&String> {
    self.notify_error.as_ref()
  }

  pub fn reset_notify_error(&mut self) {
    self.notify_error = None;
  }

  pub fn set_notify_last_attempt(&mut self, notify_last_attempt: i32) {
    self.notify_last_attempt = Some(notify_last_attempt);
  }

  pub fn with_notify_last_attempt(mut self, notify_last_attempt: i32) -> NfsNlmSessionsSession {
    self.notify_last_attempt = Some(notify_last_attempt);
    self
  }

  pub fn notify_last_attempt(&self) -> Option<&i32> {
    self.notify_last_attempt.as_ref()
  }

  pub fn reset_notify_last_attempt(&mut self) {
    self.notify_last_attempt = None;
  }

}



