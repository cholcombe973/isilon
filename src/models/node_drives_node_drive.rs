/* 
 * Isilon SDK
 *
 * Isilon SDK - Language bindings for the OneFS API
 *
 * OpenAPI spec version: 5
 * Contact: sdk@isilon.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */


#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct NodeDrivesNodeDrive {
  /// The name of the bay group this drive belongs to.
  #[serde(rename = "bay_group")]
  bay_group: Option<String>,
  /// Numerical representation of this drive's bay.
  #[serde(rename = "baynum")]
  baynum: Option<i32>,
  /// Number of blocks on this drive.
  #[serde(rename = "blocks")]
  blocks: Option<i32>,
  /// The chassis number which contains this drive.
  #[serde(rename = "chassis")]
  chassis: Option<i32>,
  /// This drive's device name.
  #[serde(rename = "devname")]
  devname: Option<String>,
  /// Drive firmware information.
  #[serde(rename = "firmware")]
  firmware: Option<::models::NodeDrivesNodeDriveFirmware>,
  /// Drive_d's handle representation for this drive
  #[serde(rename = "handle")]
  handle: Option<i32>,
  /// String representtation of this drive's interface type.
  #[serde(rename = "interface_type")]
  interface_type: Option<String>,
  /// This drive's logical drive number in IFS.
  #[serde(rename = "lnum")]
  lnum: Option<i32>,
  /// String representation of this drive's physical location.
  #[serde(rename = "locnstr")]
  locnstr: Option<String>,
  /// Size of a logical block on this drive.
  #[serde(rename = "logical_block_length")]
  logical_block_length: Option<i32>,
  /// String representation of this drive's media type.
  #[serde(rename = "media_type")]
  media_type: Option<String>,
  /// This drive's manufacturer and model.
  #[serde(rename = "model")]
  model: Option<String>,
  /// This drive's current outstanding actions. For example, \"add\" or \"firmware_update\".
  #[serde(rename = "pending_actions")]
  pending_actions: Option<Vec<String>>,
  /// Size of a physical block on this drive.
  #[serde(rename = "physical_block_length")]
  physical_block_length: Option<i32>,
  /// Indicates whether this drive is physically present in the node.
  #[serde(rename = "present")]
  present: Option<bool>,
  /// This drive's purpose in the DRV state machine.
  #[serde(rename = "purpose")]
  purpose: Option<String>,
  /// Description of this drive's purpose.
  #[serde(rename = "purpose_description")]
  purpose_description: Option<String>,
  /// Serial number for this drive.
  #[serde(rename = "serial")]
  serial: Option<String>,
  /// This drive's state as presented to the UI.
  #[serde(rename = "ui_state")]
  ui_state: Option<String>,
  /// The drive's 'worldwide name' from its NAA identifiers.
  #[serde(rename = "wwn")]
  wwn: Option<String>,
  /// This drive's x-axis grid location.
  #[serde(rename = "x_loc")]
  x_loc: Option<i32>,
  /// This drive's y-axis grid location.
  #[serde(rename = "y_loc")]
  y_loc: Option<i32>
}

impl NodeDrivesNodeDrive {
  pub fn new() -> NodeDrivesNodeDrive {
    NodeDrivesNodeDrive {
      bay_group: None,
      baynum: None,
      blocks: None,
      chassis: None,
      devname: None,
      firmware: None,
      handle: None,
      interface_type: None,
      lnum: None,
      locnstr: None,
      logical_block_length: None,
      media_type: None,
      model: None,
      pending_actions: None,
      physical_block_length: None,
      present: None,
      purpose: None,
      purpose_description: None,
      serial: None,
      ui_state: None,
      wwn: None,
      x_loc: None,
      y_loc: None
    }
  }

  pub fn set_bay_group(&mut self, bay_group: String) {
    self.bay_group = Some(bay_group);
  }

  pub fn with_bay_group(mut self, bay_group: String) -> NodeDrivesNodeDrive {
    self.bay_group = Some(bay_group);
    self
  }

  pub fn bay_group(&self) -> Option<&String> {
    self.bay_group.as_ref()
  }

  pub fn reset_bay_group(&mut self) {
    self.bay_group = None;
  }

  pub fn set_baynum(&mut self, baynum: i32) {
    self.baynum = Some(baynum);
  }

  pub fn with_baynum(mut self, baynum: i32) -> NodeDrivesNodeDrive {
    self.baynum = Some(baynum);
    self
  }

  pub fn baynum(&self) -> Option<&i32> {
    self.baynum.as_ref()
  }

  pub fn reset_baynum(&mut self) {
    self.baynum = None;
  }

  pub fn set_blocks(&mut self, blocks: i32) {
    self.blocks = Some(blocks);
  }

  pub fn with_blocks(mut self, blocks: i32) -> NodeDrivesNodeDrive {
    self.blocks = Some(blocks);
    self
  }

  pub fn blocks(&self) -> Option<&i32> {
    self.blocks.as_ref()
  }

  pub fn reset_blocks(&mut self) {
    self.blocks = None;
  }

  pub fn set_chassis(&mut self, chassis: i32) {
    self.chassis = Some(chassis);
  }

  pub fn with_chassis(mut self, chassis: i32) -> NodeDrivesNodeDrive {
    self.chassis = Some(chassis);
    self
  }

  pub fn chassis(&self) -> Option<&i32> {
    self.chassis.as_ref()
  }

  pub fn reset_chassis(&mut self) {
    self.chassis = None;
  }

  pub fn set_devname(&mut self, devname: String) {
    self.devname = Some(devname);
  }

  pub fn with_devname(mut self, devname: String) -> NodeDrivesNodeDrive {
    self.devname = Some(devname);
    self
  }

  pub fn devname(&self) -> Option<&String> {
    self.devname.as_ref()
  }

  pub fn reset_devname(&mut self) {
    self.devname = None;
  }

  pub fn set_firmware(&mut self, firmware: ::models::NodeDrivesNodeDriveFirmware) {
    self.firmware = Some(firmware);
  }

  pub fn with_firmware(mut self, firmware: ::models::NodeDrivesNodeDriveFirmware) -> NodeDrivesNodeDrive {
    self.firmware = Some(firmware);
    self
  }

  pub fn firmware(&self) -> Option<&::models::NodeDrivesNodeDriveFirmware> {
    self.firmware.as_ref()
  }

  pub fn reset_firmware(&mut self) {
    self.firmware = None;
  }

  pub fn set_handle(&mut self, handle: i32) {
    self.handle = Some(handle);
  }

  pub fn with_handle(mut self, handle: i32) -> NodeDrivesNodeDrive {
    self.handle = Some(handle);
    self
  }

  pub fn handle(&self) -> Option<&i32> {
    self.handle.as_ref()
  }

  pub fn reset_handle(&mut self) {
    self.handle = None;
  }

  pub fn set_interface_type(&mut self, interface_type: String) {
    self.interface_type = Some(interface_type);
  }

  pub fn with_interface_type(mut self, interface_type: String) -> NodeDrivesNodeDrive {
    self.interface_type = Some(interface_type);
    self
  }

  pub fn interface_type(&self) -> Option<&String> {
    self.interface_type.as_ref()
  }

  pub fn reset_interface_type(&mut self) {
    self.interface_type = None;
  }

  pub fn set_lnum(&mut self, lnum: i32) {
    self.lnum = Some(lnum);
  }

  pub fn with_lnum(mut self, lnum: i32) -> NodeDrivesNodeDrive {
    self.lnum = Some(lnum);
    self
  }

  pub fn lnum(&self) -> Option<&i32> {
    self.lnum.as_ref()
  }

  pub fn reset_lnum(&mut self) {
    self.lnum = None;
  }

  pub fn set_locnstr(&mut self, locnstr: String) {
    self.locnstr = Some(locnstr);
  }

  pub fn with_locnstr(mut self, locnstr: String) -> NodeDrivesNodeDrive {
    self.locnstr = Some(locnstr);
    self
  }

  pub fn locnstr(&self) -> Option<&String> {
    self.locnstr.as_ref()
  }

  pub fn reset_locnstr(&mut self) {
    self.locnstr = None;
  }

  pub fn set_logical_block_length(&mut self, logical_block_length: i32) {
    self.logical_block_length = Some(logical_block_length);
  }

  pub fn with_logical_block_length(mut self, logical_block_length: i32) -> NodeDrivesNodeDrive {
    self.logical_block_length = Some(logical_block_length);
    self
  }

  pub fn logical_block_length(&self) -> Option<&i32> {
    self.logical_block_length.as_ref()
  }

  pub fn reset_logical_block_length(&mut self) {
    self.logical_block_length = None;
  }

  pub fn set_media_type(&mut self, media_type: String) {
    self.media_type = Some(media_type);
  }

  pub fn with_media_type(mut self, media_type: String) -> NodeDrivesNodeDrive {
    self.media_type = Some(media_type);
    self
  }

  pub fn media_type(&self) -> Option<&String> {
    self.media_type.as_ref()
  }

  pub fn reset_media_type(&mut self) {
    self.media_type = None;
  }

  pub fn set_model(&mut self, model: String) {
    self.model = Some(model);
  }

  pub fn with_model(mut self, model: String) -> NodeDrivesNodeDrive {
    self.model = Some(model);
    self
  }

  pub fn model(&self) -> Option<&String> {
    self.model.as_ref()
  }

  pub fn reset_model(&mut self) {
    self.model = None;
  }

  pub fn set_pending_actions(&mut self, pending_actions: Vec<String>) {
    self.pending_actions = Some(pending_actions);
  }

  pub fn with_pending_actions(mut self, pending_actions: Vec<String>) -> NodeDrivesNodeDrive {
    self.pending_actions = Some(pending_actions);
    self
  }

  pub fn pending_actions(&self) -> Option<&Vec<String>> {
    self.pending_actions.as_ref()
  }

  pub fn reset_pending_actions(&mut self) {
    self.pending_actions = None;
  }

  pub fn set_physical_block_length(&mut self, physical_block_length: i32) {
    self.physical_block_length = Some(physical_block_length);
  }

  pub fn with_physical_block_length(mut self, physical_block_length: i32) -> NodeDrivesNodeDrive {
    self.physical_block_length = Some(physical_block_length);
    self
  }

  pub fn physical_block_length(&self) -> Option<&i32> {
    self.physical_block_length.as_ref()
  }

  pub fn reset_physical_block_length(&mut self) {
    self.physical_block_length = None;
  }

  pub fn set_present(&mut self, present: bool) {
    self.present = Some(present);
  }

  pub fn with_present(mut self, present: bool) -> NodeDrivesNodeDrive {
    self.present = Some(present);
    self
  }

  pub fn present(&self) -> Option<&bool> {
    self.present.as_ref()
  }

  pub fn reset_present(&mut self) {
    self.present = None;
  }

  pub fn set_purpose(&mut self, purpose: String) {
    self.purpose = Some(purpose);
  }

  pub fn with_purpose(mut self, purpose: String) -> NodeDrivesNodeDrive {
    self.purpose = Some(purpose);
    self
  }

  pub fn purpose(&self) -> Option<&String> {
    self.purpose.as_ref()
  }

  pub fn reset_purpose(&mut self) {
    self.purpose = None;
  }

  pub fn set_purpose_description(&mut self, purpose_description: String) {
    self.purpose_description = Some(purpose_description);
  }

  pub fn with_purpose_description(mut self, purpose_description: String) -> NodeDrivesNodeDrive {
    self.purpose_description = Some(purpose_description);
    self
  }

  pub fn purpose_description(&self) -> Option<&String> {
    self.purpose_description.as_ref()
  }

  pub fn reset_purpose_description(&mut self) {
    self.purpose_description = None;
  }

  pub fn set_serial(&mut self, serial: String) {
    self.serial = Some(serial);
  }

  pub fn with_serial(mut self, serial: String) -> NodeDrivesNodeDrive {
    self.serial = Some(serial);
    self
  }

  pub fn serial(&self) -> Option<&String> {
    self.serial.as_ref()
  }

  pub fn reset_serial(&mut self) {
    self.serial = None;
  }

  pub fn set_ui_state(&mut self, ui_state: String) {
    self.ui_state = Some(ui_state);
  }

  pub fn with_ui_state(mut self, ui_state: String) -> NodeDrivesNodeDrive {
    self.ui_state = Some(ui_state);
    self
  }

  pub fn ui_state(&self) -> Option<&String> {
    self.ui_state.as_ref()
  }

  pub fn reset_ui_state(&mut self) {
    self.ui_state = None;
  }

  pub fn set_wwn(&mut self, wwn: String) {
    self.wwn = Some(wwn);
  }

  pub fn with_wwn(mut self, wwn: String) -> NodeDrivesNodeDrive {
    self.wwn = Some(wwn);
    self
  }

  pub fn wwn(&self) -> Option<&String> {
    self.wwn.as_ref()
  }

  pub fn reset_wwn(&mut self) {
    self.wwn = None;
  }

  pub fn set_x_loc(&mut self, x_loc: i32) {
    self.x_loc = Some(x_loc);
  }

  pub fn with_x_loc(mut self, x_loc: i32) -> NodeDrivesNodeDrive {
    self.x_loc = Some(x_loc);
    self
  }

  pub fn x_loc(&self) -> Option<&i32> {
    self.x_loc.as_ref()
  }

  pub fn reset_x_loc(&mut self) {
    self.x_loc = None;
  }

  pub fn set_y_loc(&mut self, y_loc: i32) {
    self.y_loc = Some(y_loc);
  }

  pub fn with_y_loc(mut self, y_loc: i32) -> NodeDrivesNodeDrive {
    self.y_loc = Some(y_loc);
    self
  }

  pub fn y_loc(&self) -> Option<&i32> {
    self.y_loc.as_ref()
  }

  pub fn reset_y_loc(&mut self) {
    self.y_loc = None;
  }

}



