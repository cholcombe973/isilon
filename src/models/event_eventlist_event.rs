/* 
 * Isilon SDK
 *
 * Isilon SDK - Language bindings for the OneFS API
 *
 * OpenAPI spec version: 5
 * Contact: sdk@isilon.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */


#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct EventEventlistEvent {
  /// The device id of the node if it is still part of the cluster otherwise None.
  #[serde(rename = "devid")]
  devid: Option<i32>,
  /// Time event was ended (eventgroup resolved)
  #[serde(rename = "ended")]
  ended: Option<f32>,
  /// Integer identifier of the event type
  #[serde(rename = "event")]
  event: Option<i32>,
  /// Unique identifier of event occurrence.
  #[serde(rename = "id")]
  id: Option<String>,
  /// The lnn of the node if it is still part of the cluster, otherwise None.
  #[serde(rename = "lnn")]
  lnn: Option<i32>,
  /// Human readable description
  #[serde(rename = "message")]
  message: Option<String>,
  /// Time the event was resolved.
  #[serde(rename = "resolve_time")]
  resolve_time: Option<i32>,
  /// Severity of event occurrence.
  #[serde(rename = "severity")]
  severity: Option<String>,
  /// A collection of parameters defined per event.
  #[serde(rename = "specifier")]
  specifier: Option<::models::Empty>,
  /// Time event was detected as UNIX timestamp.
  #[serde(rename = "time")]
  time: Option<i32>,
  /// Value of measurement associated with this event.
  #[serde(rename = "value")]
  value: Option<f32>
}

impl EventEventlistEvent {
  pub fn new() -> EventEventlistEvent {
    EventEventlistEvent {
      devid: None,
      ended: None,
      event: None,
      id: None,
      lnn: None,
      message: None,
      resolve_time: None,
      severity: None,
      specifier: None,
      time: None,
      value: None
    }
  }

  pub fn set_devid(&mut self, devid: i32) {
    self.devid = Some(devid);
  }

  pub fn with_devid(mut self, devid: i32) -> EventEventlistEvent {
    self.devid = Some(devid);
    self
  }

  pub fn devid(&self) -> Option<&i32> {
    self.devid.as_ref()
  }

  pub fn reset_devid(&mut self) {
    self.devid = None;
  }

  pub fn set_ended(&mut self, ended: f32) {
    self.ended = Some(ended);
  }

  pub fn with_ended(mut self, ended: f32) -> EventEventlistEvent {
    self.ended = Some(ended);
    self
  }

  pub fn ended(&self) -> Option<&f32> {
    self.ended.as_ref()
  }

  pub fn reset_ended(&mut self) {
    self.ended = None;
  }

  pub fn set_event(&mut self, event: i32) {
    self.event = Some(event);
  }

  pub fn with_event(mut self, event: i32) -> EventEventlistEvent {
    self.event = Some(event);
    self
  }

  pub fn event(&self) -> Option<&i32> {
    self.event.as_ref()
  }

  pub fn reset_event(&mut self) {
    self.event = None;
  }

  pub fn set_id(&mut self, id: String) {
    self.id = Some(id);
  }

  pub fn with_id(mut self, id: String) -> EventEventlistEvent {
    self.id = Some(id);
    self
  }

  pub fn id(&self) -> Option<&String> {
    self.id.as_ref()
  }

  pub fn reset_id(&mut self) {
    self.id = None;
  }

  pub fn set_lnn(&mut self, lnn: i32) {
    self.lnn = Some(lnn);
  }

  pub fn with_lnn(mut self, lnn: i32) -> EventEventlistEvent {
    self.lnn = Some(lnn);
    self
  }

  pub fn lnn(&self) -> Option<&i32> {
    self.lnn.as_ref()
  }

  pub fn reset_lnn(&mut self) {
    self.lnn = None;
  }

  pub fn set_message(&mut self, message: String) {
    self.message = Some(message);
  }

  pub fn with_message(mut self, message: String) -> EventEventlistEvent {
    self.message = Some(message);
    self
  }

  pub fn message(&self) -> Option<&String> {
    self.message.as_ref()
  }

  pub fn reset_message(&mut self) {
    self.message = None;
  }

  pub fn set_resolve_time(&mut self, resolve_time: i32) {
    self.resolve_time = Some(resolve_time);
  }

  pub fn with_resolve_time(mut self, resolve_time: i32) -> EventEventlistEvent {
    self.resolve_time = Some(resolve_time);
    self
  }

  pub fn resolve_time(&self) -> Option<&i32> {
    self.resolve_time.as_ref()
  }

  pub fn reset_resolve_time(&mut self) {
    self.resolve_time = None;
  }

  pub fn set_severity(&mut self, severity: String) {
    self.severity = Some(severity);
  }

  pub fn with_severity(mut self, severity: String) -> EventEventlistEvent {
    self.severity = Some(severity);
    self
  }

  pub fn severity(&self) -> Option<&String> {
    self.severity.as_ref()
  }

  pub fn reset_severity(&mut self) {
    self.severity = None;
  }

  pub fn set_specifier(&mut self, specifier: ::models::Empty) {
    self.specifier = Some(specifier);
  }

  pub fn with_specifier(mut self, specifier: ::models::Empty) -> EventEventlistEvent {
    self.specifier = Some(specifier);
    self
  }

  pub fn specifier(&self) -> Option<&::models::Empty> {
    self.specifier.as_ref()
  }

  pub fn reset_specifier(&mut self) {
    self.specifier = None;
  }

  pub fn set_time(&mut self, time: i32) {
    self.time = Some(time);
  }

  pub fn with_time(mut self, time: i32) -> EventEventlistEvent {
    self.time = Some(time);
    self
  }

  pub fn time(&self) -> Option<&i32> {
    self.time.as_ref()
  }

  pub fn reset_time(&mut self) {
    self.time = None;
  }

  pub fn set_value(&mut self, value: f32) {
    self.value = Some(value);
  }

  pub fn with_value(mut self, value: f32) -> EventEventlistEvent {
    self.value = Some(value);
    self
  }

  pub fn value(&self) -> Option<&f32> {
    self.value.as_ref()
  }

  pub fn reset_value(&mut self) {
    self.value = None;
  }

}



