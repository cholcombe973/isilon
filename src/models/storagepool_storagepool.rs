/* 
 * Isilon SDK
 *
 * Isilon SDK - Language bindings for the OneFS API
 *
 * OpenAPI spec version: 5
 * Contact: sdk@isilon.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */


#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct StoragepoolStoragepool {
  /// Indicates if disabling L3 is possible.
  #[serde(rename = "can_disable_l3")]
  can_disable_l3: Option<bool>,
  /// Indicates if enabling L3 is possible. L3 cannot be enabled if there are unprovisioned drives.
  #[serde(rename = "can_enable_l3")]
  can_enable_l3: Option<bool>,
  /// The names or IDs of the pool's children.
  #[serde(rename = "children")]
  children: Option<Vec<String>>,
  /// An array of containing any health issues with this pool.  If the pool is healthy, the list is empty.  Only appears on 'nodepool' type storagepools.
  #[serde(rename = "health_flags")]
  health_flags: Option<Vec<String>>,
  /// The system ID given to the pool.
  #[serde(rename = "id")]
  id: i32,
  /// Use SSDs in this node pool for L3 cache.
  #[serde(rename = "l3")]
  l3: Option<bool>,
  /// 'storage' if the 'l3' option is disabled. If the l3 option is enabled, 'migrating' if any SSDs in this node pool have not yet been migrated to L3. If all SSDs have been migrated, 'l3'.
  #[serde(rename = "l3_status")]
  l3_status: Option<String>,
  /// The nodes that are part of this pool.
  #[serde(rename = "lnns")]
  lnns: Vec<i32>,
  /// Whether or not the node pool is manually managed.
  #[serde(rename = "manual")]
  manual: Option<bool>,
  /// The pool name.
  #[serde(rename = "name")]
  name: String,
  /// The underlying protection policy.
  #[serde(rename = "protection_policy")]
  protection_policy: Option<String>,
  /// The pool type.
  #[serde(rename = "type")]
  _type: String,
  /// Total pool usage.
  #[serde(rename = "usage")]
  usage: ::models::StoragepoolTierUsage
}

impl StoragepoolStoragepool {
  pub fn new(id: i32, lnns: Vec<i32>, name: String, _type: String, usage: ::models::StoragepoolTierUsage) -> StoragepoolStoragepool {
    StoragepoolStoragepool {
      can_disable_l3: None,
      can_enable_l3: None,
      children: None,
      health_flags: None,
      id: id,
      l3: None,
      l3_status: None,
      lnns: lnns,
      manual: None,
      name: name,
      protection_policy: None,
      _type: _type,
      usage: usage
    }
  }

  pub fn set_can_disable_l3(&mut self, can_disable_l3: bool) {
    self.can_disable_l3 = Some(can_disable_l3);
  }

  pub fn with_can_disable_l3(mut self, can_disable_l3: bool) -> StoragepoolStoragepool {
    self.can_disable_l3 = Some(can_disable_l3);
    self
  }

  pub fn can_disable_l3(&self) -> Option<&bool> {
    self.can_disable_l3.as_ref()
  }

  pub fn reset_can_disable_l3(&mut self) {
    self.can_disable_l3 = None;
  }

  pub fn set_can_enable_l3(&mut self, can_enable_l3: bool) {
    self.can_enable_l3 = Some(can_enable_l3);
  }

  pub fn with_can_enable_l3(mut self, can_enable_l3: bool) -> StoragepoolStoragepool {
    self.can_enable_l3 = Some(can_enable_l3);
    self
  }

  pub fn can_enable_l3(&self) -> Option<&bool> {
    self.can_enable_l3.as_ref()
  }

  pub fn reset_can_enable_l3(&mut self) {
    self.can_enable_l3 = None;
  }

  pub fn set_children(&mut self, children: Vec<String>) {
    self.children = Some(children);
  }

  pub fn with_children(mut self, children: Vec<String>) -> StoragepoolStoragepool {
    self.children = Some(children);
    self
  }

  pub fn children(&self) -> Option<&Vec<String>> {
    self.children.as_ref()
  }

  pub fn reset_children(&mut self) {
    self.children = None;
  }

  pub fn set_health_flags(&mut self, health_flags: Vec<String>) {
    self.health_flags = Some(health_flags);
  }

  pub fn with_health_flags(mut self, health_flags: Vec<String>) -> StoragepoolStoragepool {
    self.health_flags = Some(health_flags);
    self
  }

  pub fn health_flags(&self) -> Option<&Vec<String>> {
    self.health_flags.as_ref()
  }

  pub fn reset_health_flags(&mut self) {
    self.health_flags = None;
  }

  pub fn set_id(&mut self, id: i32) {
    self.id = id;
  }

  pub fn with_id(mut self, id: i32) -> StoragepoolStoragepool {
    self.id = id;
    self
  }

  pub fn id(&self) -> &i32 {
    &self.id
  }


  pub fn set_l3(&mut self, l3: bool) {
    self.l3 = Some(l3);
  }

  pub fn with_l3(mut self, l3: bool) -> StoragepoolStoragepool {
    self.l3 = Some(l3);
    self
  }

  pub fn l3(&self) -> Option<&bool> {
    self.l3.as_ref()
  }

  pub fn reset_l3(&mut self) {
    self.l3 = None;
  }

  pub fn set_l3_status(&mut self, l3_status: String) {
    self.l3_status = Some(l3_status);
  }

  pub fn with_l3_status(mut self, l3_status: String) -> StoragepoolStoragepool {
    self.l3_status = Some(l3_status);
    self
  }

  pub fn l3_status(&self) -> Option<&String> {
    self.l3_status.as_ref()
  }

  pub fn reset_l3_status(&mut self) {
    self.l3_status = None;
  }

  pub fn set_lnns(&mut self, lnns: Vec<i32>) {
    self.lnns = lnns;
  }

  pub fn with_lnns(mut self, lnns: Vec<i32>) -> StoragepoolStoragepool {
    self.lnns = lnns;
    self
  }

  pub fn lnns(&self) -> &Vec<i32> {
    &self.lnns
  }


  pub fn set_manual(&mut self, manual: bool) {
    self.manual = Some(manual);
  }

  pub fn with_manual(mut self, manual: bool) -> StoragepoolStoragepool {
    self.manual = Some(manual);
    self
  }

  pub fn manual(&self) -> Option<&bool> {
    self.manual.as_ref()
  }

  pub fn reset_manual(&mut self) {
    self.manual = None;
  }

  pub fn set_name(&mut self, name: String) {
    self.name = name;
  }

  pub fn with_name(mut self, name: String) -> StoragepoolStoragepool {
    self.name = name;
    self
  }

  pub fn name(&self) -> &String {
    &self.name
  }


  pub fn set_protection_policy(&mut self, protection_policy: String) {
    self.protection_policy = Some(protection_policy);
  }

  pub fn with_protection_policy(mut self, protection_policy: String) -> StoragepoolStoragepool {
    self.protection_policy = Some(protection_policy);
    self
  }

  pub fn protection_policy(&self) -> Option<&String> {
    self.protection_policy.as_ref()
  }

  pub fn reset_protection_policy(&mut self) {
    self.protection_policy = None;
  }

  pub fn set__type(&mut self, _type: String) {
    self._type = _type;
  }

  pub fn with__type(mut self, _type: String) -> StoragepoolStoragepool {
    self._type = _type;
    self
  }

  pub fn _type(&self) -> &String {
    &self._type
  }


  pub fn set_usage(&mut self, usage: ::models::StoragepoolTierUsage) {
    self.usage = usage;
  }

  pub fn with_usage(mut self, usage: ::models::StoragepoolTierUsage) -> StoragepoolStoragepool {
    self.usage = usage;
    self
  }

  pub fn usage(&self) -> &::models::StoragepoolTierUsage {
    &self.usage
  }


}



