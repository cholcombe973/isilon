/* 
 * Isilon SDK
 *
 * Isilon SDK - Language bindings for the OneFS API
 *
 * OpenAPI spec version: 5
 * Contact: sdk@isilon.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */


#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct SubnetsSubnetPool {
  /// Name of a valid access zone to map IP address pool to the zone.
  #[serde(rename = "access_zone")]
  access_zone: Option<String>,
  /// OneFS supports the following NIC aggregation modes.
  #[serde(rename = "aggregation_mode")]
  aggregation_mode: Option<String>,
  /// Specifies how IP address allocation is done among pool members.
  #[serde(rename = "alloc_method")]
  alloc_method: Option<String>,
  /// A description of the pool.
  #[serde(rename = "description")]
  description: Option<String>,
  /// List of interface members in this pool.
  #[serde(rename = "ifaces")]
  ifaces: Option<Vec<::models::SubnetsSubnetPoolIface>>,
  /// The name of the pool. It must be unique throughout the given subnet.It's a required field with POST method.
  #[serde(rename = "name")]
  name: Option<String>,
  /// List of IP address ranges in this pool.
  #[serde(rename = "ranges")]
  ranges: Option<Vec<::models::SubnetsSubnetPoolRange>>,
  /// Rebalance policy..
  #[serde(rename = "rebalance_policy")]
  rebalance_policy: Option<String>,
  /// Time delay in seconds before a node which has been                 automatically unsuspended becomes usable in SmartConnect                responses for pool zones.
  #[serde(rename = "sc_auto_unsuspend_delay")]
  sc_auto_unsuspend_delay: Option<i32>,
  /// SmartConnect client connection balancing policy.
  #[serde(rename = "sc_connect_policy")]
  sc_connect_policy: Option<String>,
  /// SmartConnect zone name for the pool.
  #[serde(rename = "sc_dns_zone")]
  sc_dns_zone: Option<String>,
  /// List of SmartConnect zone aliases (DNS names) to the pool.
  #[serde(rename = "sc_dns_zone_aliases")]
  sc_dns_zone_aliases: Option<Vec<String>>,
  /// SmartConnect IP failover policy.
  #[serde(rename = "sc_failover_policy")]
  sc_failover_policy: Option<String>,
  /// Name of SmartConnect service subnet for this pool.
  #[serde(rename = "sc_subnet")]
  sc_subnet: Option<String>,
  /// Time to live value for SmartConnect DNS query responses in seconds.
  #[serde(rename = "sc_ttl")]
  sc_ttl: Option<i32>,
  /// List of interface members in this pool.
  #[serde(rename = "static_routes")]
  static_routes: Option<Vec<::models::SubnetsSubnetPoolStaticRoute>>
}

impl SubnetsSubnetPool {
  pub fn new() -> SubnetsSubnetPool {
    SubnetsSubnetPool {
      access_zone: None,
      aggregation_mode: None,
      alloc_method: None,
      description: None,
      ifaces: None,
      name: None,
      ranges: None,
      rebalance_policy: None,
      sc_auto_unsuspend_delay: None,
      sc_connect_policy: None,
      sc_dns_zone: None,
      sc_dns_zone_aliases: None,
      sc_failover_policy: None,
      sc_subnet: None,
      sc_ttl: None,
      static_routes: None
    }
  }

  pub fn set_access_zone(&mut self, access_zone: String) {
    self.access_zone = Some(access_zone);
  }

  pub fn with_access_zone(mut self, access_zone: String) -> SubnetsSubnetPool {
    self.access_zone = Some(access_zone);
    self
  }

  pub fn access_zone(&self) -> Option<&String> {
    self.access_zone.as_ref()
  }

  pub fn reset_access_zone(&mut self) {
    self.access_zone = None;
  }

  pub fn set_aggregation_mode(&mut self, aggregation_mode: String) {
    self.aggregation_mode = Some(aggregation_mode);
  }

  pub fn with_aggregation_mode(mut self, aggregation_mode: String) -> SubnetsSubnetPool {
    self.aggregation_mode = Some(aggregation_mode);
    self
  }

  pub fn aggregation_mode(&self) -> Option<&String> {
    self.aggregation_mode.as_ref()
  }

  pub fn reset_aggregation_mode(&mut self) {
    self.aggregation_mode = None;
  }

  pub fn set_alloc_method(&mut self, alloc_method: String) {
    self.alloc_method = Some(alloc_method);
  }

  pub fn with_alloc_method(mut self, alloc_method: String) -> SubnetsSubnetPool {
    self.alloc_method = Some(alloc_method);
    self
  }

  pub fn alloc_method(&self) -> Option<&String> {
    self.alloc_method.as_ref()
  }

  pub fn reset_alloc_method(&mut self) {
    self.alloc_method = None;
  }

  pub fn set_description(&mut self, description: String) {
    self.description = Some(description);
  }

  pub fn with_description(mut self, description: String) -> SubnetsSubnetPool {
    self.description = Some(description);
    self
  }

  pub fn description(&self) -> Option<&String> {
    self.description.as_ref()
  }

  pub fn reset_description(&mut self) {
    self.description = None;
  }

  pub fn set_ifaces(&mut self, ifaces: Vec<::models::SubnetsSubnetPoolIface>) {
    self.ifaces = Some(ifaces);
  }

  pub fn with_ifaces(mut self, ifaces: Vec<::models::SubnetsSubnetPoolIface>) -> SubnetsSubnetPool {
    self.ifaces = Some(ifaces);
    self
  }

  pub fn ifaces(&self) -> Option<&Vec<::models::SubnetsSubnetPoolIface>> {
    self.ifaces.as_ref()
  }

  pub fn reset_ifaces(&mut self) {
    self.ifaces = None;
  }

  pub fn set_name(&mut self, name: String) {
    self.name = Some(name);
  }

  pub fn with_name(mut self, name: String) -> SubnetsSubnetPool {
    self.name = Some(name);
    self
  }

  pub fn name(&self) -> Option<&String> {
    self.name.as_ref()
  }

  pub fn reset_name(&mut self) {
    self.name = None;
  }

  pub fn set_ranges(&mut self, ranges: Vec<::models::SubnetsSubnetPoolRange>) {
    self.ranges = Some(ranges);
  }

  pub fn with_ranges(mut self, ranges: Vec<::models::SubnetsSubnetPoolRange>) -> SubnetsSubnetPool {
    self.ranges = Some(ranges);
    self
  }

  pub fn ranges(&self) -> Option<&Vec<::models::SubnetsSubnetPoolRange>> {
    self.ranges.as_ref()
  }

  pub fn reset_ranges(&mut self) {
    self.ranges = None;
  }

  pub fn set_rebalance_policy(&mut self, rebalance_policy: String) {
    self.rebalance_policy = Some(rebalance_policy);
  }

  pub fn with_rebalance_policy(mut self, rebalance_policy: String) -> SubnetsSubnetPool {
    self.rebalance_policy = Some(rebalance_policy);
    self
  }

  pub fn rebalance_policy(&self) -> Option<&String> {
    self.rebalance_policy.as_ref()
  }

  pub fn reset_rebalance_policy(&mut self) {
    self.rebalance_policy = None;
  }

  pub fn set_sc_auto_unsuspend_delay(&mut self, sc_auto_unsuspend_delay: i32) {
    self.sc_auto_unsuspend_delay = Some(sc_auto_unsuspend_delay);
  }

  pub fn with_sc_auto_unsuspend_delay(mut self, sc_auto_unsuspend_delay: i32) -> SubnetsSubnetPool {
    self.sc_auto_unsuspend_delay = Some(sc_auto_unsuspend_delay);
    self
  }

  pub fn sc_auto_unsuspend_delay(&self) -> Option<&i32> {
    self.sc_auto_unsuspend_delay.as_ref()
  }

  pub fn reset_sc_auto_unsuspend_delay(&mut self) {
    self.sc_auto_unsuspend_delay = None;
  }

  pub fn set_sc_connect_policy(&mut self, sc_connect_policy: String) {
    self.sc_connect_policy = Some(sc_connect_policy);
  }

  pub fn with_sc_connect_policy(mut self, sc_connect_policy: String) -> SubnetsSubnetPool {
    self.sc_connect_policy = Some(sc_connect_policy);
    self
  }

  pub fn sc_connect_policy(&self) -> Option<&String> {
    self.sc_connect_policy.as_ref()
  }

  pub fn reset_sc_connect_policy(&mut self) {
    self.sc_connect_policy = None;
  }

  pub fn set_sc_dns_zone(&mut self, sc_dns_zone: String) {
    self.sc_dns_zone = Some(sc_dns_zone);
  }

  pub fn with_sc_dns_zone(mut self, sc_dns_zone: String) -> SubnetsSubnetPool {
    self.sc_dns_zone = Some(sc_dns_zone);
    self
  }

  pub fn sc_dns_zone(&self) -> Option<&String> {
    self.sc_dns_zone.as_ref()
  }

  pub fn reset_sc_dns_zone(&mut self) {
    self.sc_dns_zone = None;
  }

  pub fn set_sc_dns_zone_aliases(&mut self, sc_dns_zone_aliases: Vec<String>) {
    self.sc_dns_zone_aliases = Some(sc_dns_zone_aliases);
  }

  pub fn with_sc_dns_zone_aliases(mut self, sc_dns_zone_aliases: Vec<String>) -> SubnetsSubnetPool {
    self.sc_dns_zone_aliases = Some(sc_dns_zone_aliases);
    self
  }

  pub fn sc_dns_zone_aliases(&self) -> Option<&Vec<String>> {
    self.sc_dns_zone_aliases.as_ref()
  }

  pub fn reset_sc_dns_zone_aliases(&mut self) {
    self.sc_dns_zone_aliases = None;
  }

  pub fn set_sc_failover_policy(&mut self, sc_failover_policy: String) {
    self.sc_failover_policy = Some(sc_failover_policy);
  }

  pub fn with_sc_failover_policy(mut self, sc_failover_policy: String) -> SubnetsSubnetPool {
    self.sc_failover_policy = Some(sc_failover_policy);
    self
  }

  pub fn sc_failover_policy(&self) -> Option<&String> {
    self.sc_failover_policy.as_ref()
  }

  pub fn reset_sc_failover_policy(&mut self) {
    self.sc_failover_policy = None;
  }

  pub fn set_sc_subnet(&mut self, sc_subnet: String) {
    self.sc_subnet = Some(sc_subnet);
  }

  pub fn with_sc_subnet(mut self, sc_subnet: String) -> SubnetsSubnetPool {
    self.sc_subnet = Some(sc_subnet);
    self
  }

  pub fn sc_subnet(&self) -> Option<&String> {
    self.sc_subnet.as_ref()
  }

  pub fn reset_sc_subnet(&mut self) {
    self.sc_subnet = None;
  }

  pub fn set_sc_ttl(&mut self, sc_ttl: i32) {
    self.sc_ttl = Some(sc_ttl);
  }

  pub fn with_sc_ttl(mut self, sc_ttl: i32) -> SubnetsSubnetPool {
    self.sc_ttl = Some(sc_ttl);
    self
  }

  pub fn sc_ttl(&self) -> Option<&i32> {
    self.sc_ttl.as_ref()
  }

  pub fn reset_sc_ttl(&mut self) {
    self.sc_ttl = None;
  }

  pub fn set_static_routes(&mut self, static_routes: Vec<::models::SubnetsSubnetPoolStaticRoute>) {
    self.static_routes = Some(static_routes);
  }

  pub fn with_static_routes(mut self, static_routes: Vec<::models::SubnetsSubnetPoolStaticRoute>) -> SubnetsSubnetPool {
    self.static_routes = Some(static_routes);
    self
  }

  pub fn static_routes(&self) -> Option<&Vec<::models::SubnetsSubnetPoolStaticRoute>> {
    self.static_routes.as_ref()
  }

  pub fn reset_static_routes(&mut self) {
    self.static_routes = None;
  }

}



