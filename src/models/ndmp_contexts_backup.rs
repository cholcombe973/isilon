/* 
 * Isilon SDK
 *
 * Isilon SDK - Language bindings for the OneFS API
 *
 * OpenAPI spec version: 5
 * Contact: sdk@isilon.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

/// NdmpContextsBackup : View a NDMP Context

#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct NdmpContextsBackup {
  /// Context expiration time
  #[serde(rename = "context_expiration_time")]
  context_expiration_time: Option<i32>,
  /// Context ID
  #[serde(rename = "context_id")]
  context_id: Option<String>,
  /// Unique display id.
  #[serde(rename = "id")]
  id: Option<String>,
  /// The directory of the backup. This is not applicable to restore contexts.
  #[serde(rename = "path")]
  path: Option<String>,
  #[serde(rename = "sessions")]
  sessions: Option<Vec<::models::NdmpContextsBackupSession>>,
  /// Snapshot ID reserved for the context. This is not applicable to restore contexts.
  #[serde(rename = "snapid")]
  snapid: Option<i32>,
  /// Context creation time
  #[serde(rename = "start_time")]
  start_time: Option<i32>,
  /// Whether the context is active.
  #[serde(rename = "status")]
  status: Option<String>,
  /// The number of sessions in the context
  #[serde(rename = "total_sessions")]
  total_sessions: Option<i32>,
  /// Type of context; It can be bre, backup, and restore
  #[serde(rename = "type")]
  _type: Option<String>
}

impl NdmpContextsBackup {
  /// View a NDMP Context
  pub fn new() -> NdmpContextsBackup {
    NdmpContextsBackup {
      context_expiration_time: None,
      context_id: None,
      id: None,
      path: None,
      sessions: None,
      snapid: None,
      start_time: None,
      status: None,
      total_sessions: None,
      _type: None
    }
  }

  pub fn set_context_expiration_time(&mut self, context_expiration_time: i32) {
    self.context_expiration_time = Some(context_expiration_time);
  }

  pub fn with_context_expiration_time(mut self, context_expiration_time: i32) -> NdmpContextsBackup {
    self.context_expiration_time = Some(context_expiration_time);
    self
  }

  pub fn context_expiration_time(&self) -> Option<&i32> {
    self.context_expiration_time.as_ref()
  }

  pub fn reset_context_expiration_time(&mut self) {
    self.context_expiration_time = None;
  }

  pub fn set_context_id(&mut self, context_id: String) {
    self.context_id = Some(context_id);
  }

  pub fn with_context_id(mut self, context_id: String) -> NdmpContextsBackup {
    self.context_id = Some(context_id);
    self
  }

  pub fn context_id(&self) -> Option<&String> {
    self.context_id.as_ref()
  }

  pub fn reset_context_id(&mut self) {
    self.context_id = None;
  }

  pub fn set_id(&mut self, id: String) {
    self.id = Some(id);
  }

  pub fn with_id(mut self, id: String) -> NdmpContextsBackup {
    self.id = Some(id);
    self
  }

  pub fn id(&self) -> Option<&String> {
    self.id.as_ref()
  }

  pub fn reset_id(&mut self) {
    self.id = None;
  }

  pub fn set_path(&mut self, path: String) {
    self.path = Some(path);
  }

  pub fn with_path(mut self, path: String) -> NdmpContextsBackup {
    self.path = Some(path);
    self
  }

  pub fn path(&self) -> Option<&String> {
    self.path.as_ref()
  }

  pub fn reset_path(&mut self) {
    self.path = None;
  }

  pub fn set_sessions(&mut self, sessions: Vec<::models::NdmpContextsBackupSession>) {
    self.sessions = Some(sessions);
  }

  pub fn with_sessions(mut self, sessions: Vec<::models::NdmpContextsBackupSession>) -> NdmpContextsBackup {
    self.sessions = Some(sessions);
    self
  }

  pub fn sessions(&self) -> Option<&Vec<::models::NdmpContextsBackupSession>> {
    self.sessions.as_ref()
  }

  pub fn reset_sessions(&mut self) {
    self.sessions = None;
  }

  pub fn set_snapid(&mut self, snapid: i32) {
    self.snapid = Some(snapid);
  }

  pub fn with_snapid(mut self, snapid: i32) -> NdmpContextsBackup {
    self.snapid = Some(snapid);
    self
  }

  pub fn snapid(&self) -> Option<&i32> {
    self.snapid.as_ref()
  }

  pub fn reset_snapid(&mut self) {
    self.snapid = None;
  }

  pub fn set_start_time(&mut self, start_time: i32) {
    self.start_time = Some(start_time);
  }

  pub fn with_start_time(mut self, start_time: i32) -> NdmpContextsBackup {
    self.start_time = Some(start_time);
    self
  }

  pub fn start_time(&self) -> Option<&i32> {
    self.start_time.as_ref()
  }

  pub fn reset_start_time(&mut self) {
    self.start_time = None;
  }

  pub fn set_status(&mut self, status: String) {
    self.status = Some(status);
  }

  pub fn with_status(mut self, status: String) -> NdmpContextsBackup {
    self.status = Some(status);
    self
  }

  pub fn status(&self) -> Option<&String> {
    self.status.as_ref()
  }

  pub fn reset_status(&mut self) {
    self.status = None;
  }

  pub fn set_total_sessions(&mut self, total_sessions: i32) {
    self.total_sessions = Some(total_sessions);
  }

  pub fn with_total_sessions(mut self, total_sessions: i32) -> NdmpContextsBackup {
    self.total_sessions = Some(total_sessions);
    self
  }

  pub fn total_sessions(&self) -> Option<&i32> {
    self.total_sessions.as_ref()
  }

  pub fn reset_total_sessions(&mut self) {
    self.total_sessions = None;
  }

  pub fn set__type(&mut self, _type: String) {
    self._type = Some(_type);
  }

  pub fn with__type(mut self, _type: String) -> NdmpContextsBackup {
    self._type = Some(_type);
    self
  }

  pub fn _type(&self) -> Option<&String> {
    self._type.as_ref()
  }

  pub fn reset__type(&mut self) {
    self._type = None;
  }

}



