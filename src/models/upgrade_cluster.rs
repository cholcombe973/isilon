/* 
 * Isilon SDK
 *
 * Isilon SDK - Language bindings for the OneFS API
 *
 * OpenAPI spec version: 5
 * Contact: sdk@isilon.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

/// UpgradeCluster : Cluster wide upgrade status info.

#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct UpgradeCluster {
  /// The cluster overview of an upgrade process.
  #[serde(rename = "cluster_overview")]
  cluster_overview: Option<::models::UpgradeClusterClusterOverview>,
  /// The different states of an upgrade, rollback, or assessment. One of the following values: 'committed', 'upgraded', 'partially upgraded', 'upgrading', 'rolling back', 'assessing', 'error'
  #[serde(rename = "cluster_state")]
  cluster_state: Option<String>,
  /// The current upgrade activity.
  #[serde(rename = "current_process")]
  current_process: Option<String>,
  /// The time when a rollback, assessment or upgrade has finished completely. Use ISO 8601 standard. Null if the cluster_state is not 'upgraded'.
  #[serde(rename = "finish_time")]
  finish_time: Option<String>,
  /// The location (path) of the upgrade image which must be within /ifs. Null if the cluster_state is 'committed' or 'upgraded.'
  #[serde(rename = "install_image_path")]
  install_image_path: Option<String>,
  /// The median time (seconds) to complete each node so far during this upgrade. Before the first node in an upgrade has completed this key will have an associated null value.
  #[serde(rename = "node_median_time")]
  node_median_time: Option<i32>,
  /// The current OneFS version before upgrade.
  #[serde(rename = "onefs_version_current")]
  onefs_version_current: Option<::models::ClusterNodesOnefsVersion>,
  /// The OneFS version the user is attempting to upgrade to. Null if the cluster_state is 'committed' or 'assessing.'
  #[serde(rename = "onefs_version_upgrade")]
  onefs_version_upgrade: Option<::models::ClusterNodesOnefsVersion>,
  /// The most recent patch action performed.
  #[serde(rename = "patch_action")]
  patch_action: Option<String>,
  /// The patch with the most recent patch action.
  #[serde(rename = "patch_name")]
  patch_name: Option<String>,
  /// The time when an upgrade, rollback, or assessment was started. Use ISO 8601 standard. Null if the cluster_state is 'committed' or 'partially upgraded.'
  #[serde(rename = "start_time")]
  start_time: Option<String>,
  /// True if upgrade is committed.
  #[serde(rename = "upgrade_is_committed")]
  upgrade_is_committed: Option<bool>,
  /// The settings necessary when starting an upgrade. Null if the cluster_state is not 'upgrading' or 'partially upgraded.' or 'error'.
  #[serde(rename = "upgrade_settings")]
  upgrade_settings: Option<::models::UpgradeClusterUpgradeSettings>,
  /// Time at which upgrade was originally requested.
  #[serde(rename = "upgrade_triggered_time")]
  upgrade_triggered_time: Option<String>
}

impl UpgradeCluster {
  /// Cluster wide upgrade status info.
  pub fn new() -> UpgradeCluster {
    UpgradeCluster {
      cluster_overview: None,
      cluster_state: None,
      current_process: None,
      finish_time: None,
      install_image_path: None,
      node_median_time: None,
      onefs_version_current: None,
      onefs_version_upgrade: None,
      patch_action: None,
      patch_name: None,
      start_time: None,
      upgrade_is_committed: None,
      upgrade_settings: None,
      upgrade_triggered_time: None
    }
  }

  pub fn set_cluster_overview(&mut self, cluster_overview: ::models::UpgradeClusterClusterOverview) {
    self.cluster_overview = Some(cluster_overview);
  }

  pub fn with_cluster_overview(mut self, cluster_overview: ::models::UpgradeClusterClusterOverview) -> UpgradeCluster {
    self.cluster_overview = Some(cluster_overview);
    self
  }

  pub fn cluster_overview(&self) -> Option<&::models::UpgradeClusterClusterOverview> {
    self.cluster_overview.as_ref()
  }

  pub fn reset_cluster_overview(&mut self) {
    self.cluster_overview = None;
  }

  pub fn set_cluster_state(&mut self, cluster_state: String) {
    self.cluster_state = Some(cluster_state);
  }

  pub fn with_cluster_state(mut self, cluster_state: String) -> UpgradeCluster {
    self.cluster_state = Some(cluster_state);
    self
  }

  pub fn cluster_state(&self) -> Option<&String> {
    self.cluster_state.as_ref()
  }

  pub fn reset_cluster_state(&mut self) {
    self.cluster_state = None;
  }

  pub fn set_current_process(&mut self, current_process: String) {
    self.current_process = Some(current_process);
  }

  pub fn with_current_process(mut self, current_process: String) -> UpgradeCluster {
    self.current_process = Some(current_process);
    self
  }

  pub fn current_process(&self) -> Option<&String> {
    self.current_process.as_ref()
  }

  pub fn reset_current_process(&mut self) {
    self.current_process = None;
  }

  pub fn set_finish_time(&mut self, finish_time: String) {
    self.finish_time = Some(finish_time);
  }

  pub fn with_finish_time(mut self, finish_time: String) -> UpgradeCluster {
    self.finish_time = Some(finish_time);
    self
  }

  pub fn finish_time(&self) -> Option<&String> {
    self.finish_time.as_ref()
  }

  pub fn reset_finish_time(&mut self) {
    self.finish_time = None;
  }

  pub fn set_install_image_path(&mut self, install_image_path: String) {
    self.install_image_path = Some(install_image_path);
  }

  pub fn with_install_image_path(mut self, install_image_path: String) -> UpgradeCluster {
    self.install_image_path = Some(install_image_path);
    self
  }

  pub fn install_image_path(&self) -> Option<&String> {
    self.install_image_path.as_ref()
  }

  pub fn reset_install_image_path(&mut self) {
    self.install_image_path = None;
  }

  pub fn set_node_median_time(&mut self, node_median_time: i32) {
    self.node_median_time = Some(node_median_time);
  }

  pub fn with_node_median_time(mut self, node_median_time: i32) -> UpgradeCluster {
    self.node_median_time = Some(node_median_time);
    self
  }

  pub fn node_median_time(&self) -> Option<&i32> {
    self.node_median_time.as_ref()
  }

  pub fn reset_node_median_time(&mut self) {
    self.node_median_time = None;
  }

  pub fn set_onefs_version_current(&mut self, onefs_version_current: ::models::ClusterNodesOnefsVersion) {
    self.onefs_version_current = Some(onefs_version_current);
  }

  pub fn with_onefs_version_current(mut self, onefs_version_current: ::models::ClusterNodesOnefsVersion) -> UpgradeCluster {
    self.onefs_version_current = Some(onefs_version_current);
    self
  }

  pub fn onefs_version_current(&self) -> Option<&::models::ClusterNodesOnefsVersion> {
    self.onefs_version_current.as_ref()
  }

  pub fn reset_onefs_version_current(&mut self) {
    self.onefs_version_current = None;
  }

  pub fn set_onefs_version_upgrade(&mut self, onefs_version_upgrade: ::models::ClusterNodesOnefsVersion) {
    self.onefs_version_upgrade = Some(onefs_version_upgrade);
  }

  pub fn with_onefs_version_upgrade(mut self, onefs_version_upgrade: ::models::ClusterNodesOnefsVersion) -> UpgradeCluster {
    self.onefs_version_upgrade = Some(onefs_version_upgrade);
    self
  }

  pub fn onefs_version_upgrade(&self) -> Option<&::models::ClusterNodesOnefsVersion> {
    self.onefs_version_upgrade.as_ref()
  }

  pub fn reset_onefs_version_upgrade(&mut self) {
    self.onefs_version_upgrade = None;
  }

  pub fn set_patch_action(&mut self, patch_action: String) {
    self.patch_action = Some(patch_action);
  }

  pub fn with_patch_action(mut self, patch_action: String) -> UpgradeCluster {
    self.patch_action = Some(patch_action);
    self
  }

  pub fn patch_action(&self) -> Option<&String> {
    self.patch_action.as_ref()
  }

  pub fn reset_patch_action(&mut self) {
    self.patch_action = None;
  }

  pub fn set_patch_name(&mut self, patch_name: String) {
    self.patch_name = Some(patch_name);
  }

  pub fn with_patch_name(mut self, patch_name: String) -> UpgradeCluster {
    self.patch_name = Some(patch_name);
    self
  }

  pub fn patch_name(&self) -> Option<&String> {
    self.patch_name.as_ref()
  }

  pub fn reset_patch_name(&mut self) {
    self.patch_name = None;
  }

  pub fn set_start_time(&mut self, start_time: String) {
    self.start_time = Some(start_time);
  }

  pub fn with_start_time(mut self, start_time: String) -> UpgradeCluster {
    self.start_time = Some(start_time);
    self
  }

  pub fn start_time(&self) -> Option<&String> {
    self.start_time.as_ref()
  }

  pub fn reset_start_time(&mut self) {
    self.start_time = None;
  }

  pub fn set_upgrade_is_committed(&mut self, upgrade_is_committed: bool) {
    self.upgrade_is_committed = Some(upgrade_is_committed);
  }

  pub fn with_upgrade_is_committed(mut self, upgrade_is_committed: bool) -> UpgradeCluster {
    self.upgrade_is_committed = Some(upgrade_is_committed);
    self
  }

  pub fn upgrade_is_committed(&self) -> Option<&bool> {
    self.upgrade_is_committed.as_ref()
  }

  pub fn reset_upgrade_is_committed(&mut self) {
    self.upgrade_is_committed = None;
  }

  pub fn set_upgrade_settings(&mut self, upgrade_settings: ::models::UpgradeClusterUpgradeSettings) {
    self.upgrade_settings = Some(upgrade_settings);
  }

  pub fn with_upgrade_settings(mut self, upgrade_settings: ::models::UpgradeClusterUpgradeSettings) -> UpgradeCluster {
    self.upgrade_settings = Some(upgrade_settings);
    self
  }

  pub fn upgrade_settings(&self) -> Option<&::models::UpgradeClusterUpgradeSettings> {
    self.upgrade_settings.as_ref()
  }

  pub fn reset_upgrade_settings(&mut self) {
    self.upgrade_settings = None;
  }

  pub fn set_upgrade_triggered_time(&mut self, upgrade_triggered_time: String) {
    self.upgrade_triggered_time = Some(upgrade_triggered_time);
  }

  pub fn with_upgrade_triggered_time(mut self, upgrade_triggered_time: String) -> UpgradeCluster {
    self.upgrade_triggered_time = Some(upgrade_triggered_time);
    self
  }

  pub fn upgrade_triggered_time(&self) -> Option<&String> {
    self.upgrade_triggered_time.as_ref()
  }

  pub fn reset_upgrade_triggered_time(&mut self) {
    self.upgrade_triggered_time = None;
  }

}



