/* 
 * Isilon SDK
 *
 * Isilon SDK - Language bindings for the OneFS API
 *
 * OpenAPI spec version: 5
 * Contact: sdk@isilon.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */


#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct NodePartitionsNodePartitionStatfs {
  /// Free blocks available to non-superuser on this partition.
  #[serde(rename = "f_bavail")]
  f_bavail: Option<i32>,
  /// Free blocks on this partition.
  #[serde(rename = "f_bfree")]
  f_bfree: Option<i32>,
  /// Total data blocks on this partition.
  #[serde(rename = "f_blocks")]
  f_blocks: Option<i32>,
  /// Filesystem fragment size; block size in OneFS.
  #[serde(rename = "f_bsize")]
  f_bsize: Option<i32>,
  /// Free file nodes avail to non-superuser.
  #[serde(rename = "f_ffree")]
  f_ffree: Option<i32>,
  /// Total file nodes in filesystem.
  #[serde(rename = "f_files")]
  f_files: Option<i32>,
  /// Mount exported flags.
  #[serde(rename = "f_flags")]
  f_flags: Option<i32>,
  /// File system type name.
  #[serde(rename = "f_fstypename")]
  f_fstypename: Option<String>,
  /// Optimal transfer block size.
  #[serde(rename = "f_iosize")]
  f_iosize: Option<i32>,
  /// Names of devices this partition is mounted from.
  #[serde(rename = "f_mntfromname")]
  f_mntfromname: Option<String>,
  /// Directory this partition is mounted to.
  #[serde(rename = "f_mntonname")]
  f_mntonname: Option<String>,
  /// Maximum filename length.
  #[serde(rename = "f_namemax")]
  f_namemax: Option<i32>,
  /// UID of user that mounted the filesystem.
  #[serde(rename = "f_owner")]
  f_owner: Option<i32>,
  /// Type of filesystem.
  #[serde(rename = "f_type")]
  f_type: Option<i32>,
  /// statfs() structure version number.
  #[serde(rename = "f_version")]
  f_version: Option<i32>
}

impl NodePartitionsNodePartitionStatfs {
  pub fn new() -> NodePartitionsNodePartitionStatfs {
    NodePartitionsNodePartitionStatfs {
      f_bavail: None,
      f_bfree: None,
      f_blocks: None,
      f_bsize: None,
      f_ffree: None,
      f_files: None,
      f_flags: None,
      f_fstypename: None,
      f_iosize: None,
      f_mntfromname: None,
      f_mntonname: None,
      f_namemax: None,
      f_owner: None,
      f_type: None,
      f_version: None
    }
  }

  pub fn set_f_bavail(&mut self, f_bavail: i32) {
    self.f_bavail = Some(f_bavail);
  }

  pub fn with_f_bavail(mut self, f_bavail: i32) -> NodePartitionsNodePartitionStatfs {
    self.f_bavail = Some(f_bavail);
    self
  }

  pub fn f_bavail(&self) -> Option<&i32> {
    self.f_bavail.as_ref()
  }

  pub fn reset_f_bavail(&mut self) {
    self.f_bavail = None;
  }

  pub fn set_f_bfree(&mut self, f_bfree: i32) {
    self.f_bfree = Some(f_bfree);
  }

  pub fn with_f_bfree(mut self, f_bfree: i32) -> NodePartitionsNodePartitionStatfs {
    self.f_bfree = Some(f_bfree);
    self
  }

  pub fn f_bfree(&self) -> Option<&i32> {
    self.f_bfree.as_ref()
  }

  pub fn reset_f_bfree(&mut self) {
    self.f_bfree = None;
  }

  pub fn set_f_blocks(&mut self, f_blocks: i32) {
    self.f_blocks = Some(f_blocks);
  }

  pub fn with_f_blocks(mut self, f_blocks: i32) -> NodePartitionsNodePartitionStatfs {
    self.f_blocks = Some(f_blocks);
    self
  }

  pub fn f_blocks(&self) -> Option<&i32> {
    self.f_blocks.as_ref()
  }

  pub fn reset_f_blocks(&mut self) {
    self.f_blocks = None;
  }

  pub fn set_f_bsize(&mut self, f_bsize: i32) {
    self.f_bsize = Some(f_bsize);
  }

  pub fn with_f_bsize(mut self, f_bsize: i32) -> NodePartitionsNodePartitionStatfs {
    self.f_bsize = Some(f_bsize);
    self
  }

  pub fn f_bsize(&self) -> Option<&i32> {
    self.f_bsize.as_ref()
  }

  pub fn reset_f_bsize(&mut self) {
    self.f_bsize = None;
  }

  pub fn set_f_ffree(&mut self, f_ffree: i32) {
    self.f_ffree = Some(f_ffree);
  }

  pub fn with_f_ffree(mut self, f_ffree: i32) -> NodePartitionsNodePartitionStatfs {
    self.f_ffree = Some(f_ffree);
    self
  }

  pub fn f_ffree(&self) -> Option<&i32> {
    self.f_ffree.as_ref()
  }

  pub fn reset_f_ffree(&mut self) {
    self.f_ffree = None;
  }

  pub fn set_f_files(&mut self, f_files: i32) {
    self.f_files = Some(f_files);
  }

  pub fn with_f_files(mut self, f_files: i32) -> NodePartitionsNodePartitionStatfs {
    self.f_files = Some(f_files);
    self
  }

  pub fn f_files(&self) -> Option<&i32> {
    self.f_files.as_ref()
  }

  pub fn reset_f_files(&mut self) {
    self.f_files = None;
  }

  pub fn set_f_flags(&mut self, f_flags: i32) {
    self.f_flags = Some(f_flags);
  }

  pub fn with_f_flags(mut self, f_flags: i32) -> NodePartitionsNodePartitionStatfs {
    self.f_flags = Some(f_flags);
    self
  }

  pub fn f_flags(&self) -> Option<&i32> {
    self.f_flags.as_ref()
  }

  pub fn reset_f_flags(&mut self) {
    self.f_flags = None;
  }

  pub fn set_f_fstypename(&mut self, f_fstypename: String) {
    self.f_fstypename = Some(f_fstypename);
  }

  pub fn with_f_fstypename(mut self, f_fstypename: String) -> NodePartitionsNodePartitionStatfs {
    self.f_fstypename = Some(f_fstypename);
    self
  }

  pub fn f_fstypename(&self) -> Option<&String> {
    self.f_fstypename.as_ref()
  }

  pub fn reset_f_fstypename(&mut self) {
    self.f_fstypename = None;
  }

  pub fn set_f_iosize(&mut self, f_iosize: i32) {
    self.f_iosize = Some(f_iosize);
  }

  pub fn with_f_iosize(mut self, f_iosize: i32) -> NodePartitionsNodePartitionStatfs {
    self.f_iosize = Some(f_iosize);
    self
  }

  pub fn f_iosize(&self) -> Option<&i32> {
    self.f_iosize.as_ref()
  }

  pub fn reset_f_iosize(&mut self) {
    self.f_iosize = None;
  }

  pub fn set_f_mntfromname(&mut self, f_mntfromname: String) {
    self.f_mntfromname = Some(f_mntfromname);
  }

  pub fn with_f_mntfromname(mut self, f_mntfromname: String) -> NodePartitionsNodePartitionStatfs {
    self.f_mntfromname = Some(f_mntfromname);
    self
  }

  pub fn f_mntfromname(&self) -> Option<&String> {
    self.f_mntfromname.as_ref()
  }

  pub fn reset_f_mntfromname(&mut self) {
    self.f_mntfromname = None;
  }

  pub fn set_f_mntonname(&mut self, f_mntonname: String) {
    self.f_mntonname = Some(f_mntonname);
  }

  pub fn with_f_mntonname(mut self, f_mntonname: String) -> NodePartitionsNodePartitionStatfs {
    self.f_mntonname = Some(f_mntonname);
    self
  }

  pub fn f_mntonname(&self) -> Option<&String> {
    self.f_mntonname.as_ref()
  }

  pub fn reset_f_mntonname(&mut self) {
    self.f_mntonname = None;
  }

  pub fn set_f_namemax(&mut self, f_namemax: i32) {
    self.f_namemax = Some(f_namemax);
  }

  pub fn with_f_namemax(mut self, f_namemax: i32) -> NodePartitionsNodePartitionStatfs {
    self.f_namemax = Some(f_namemax);
    self
  }

  pub fn f_namemax(&self) -> Option<&i32> {
    self.f_namemax.as_ref()
  }

  pub fn reset_f_namemax(&mut self) {
    self.f_namemax = None;
  }

  pub fn set_f_owner(&mut self, f_owner: i32) {
    self.f_owner = Some(f_owner);
  }

  pub fn with_f_owner(mut self, f_owner: i32) -> NodePartitionsNodePartitionStatfs {
    self.f_owner = Some(f_owner);
    self
  }

  pub fn f_owner(&self) -> Option<&i32> {
    self.f_owner.as_ref()
  }

  pub fn reset_f_owner(&mut self) {
    self.f_owner = None;
  }

  pub fn set_f_type(&mut self, f_type: i32) {
    self.f_type = Some(f_type);
  }

  pub fn with_f_type(mut self, f_type: i32) -> NodePartitionsNodePartitionStatfs {
    self.f_type = Some(f_type);
    self
  }

  pub fn f_type(&self) -> Option<&i32> {
    self.f_type.as_ref()
  }

  pub fn reset_f_type(&mut self) {
    self.f_type = None;
  }

  pub fn set_f_version(&mut self, f_version: i32) {
    self.f_version = Some(f_version);
  }

  pub fn with_f_version(mut self, f_version: i32) -> NodePartitionsNodePartitionStatfs {
    self.f_version = Some(f_version);
    self
  }

  pub fn f_version(&self) -> Option<&i32> {
    self.f_version.as_ref()
  }

  pub fn reset_f_version(&mut self) {
    self.f_version = None;
  }

}



