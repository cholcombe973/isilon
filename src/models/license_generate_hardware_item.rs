/* 
 * Isilon SDK
 *
 * Isilon SDK - Language bindings for the OneFS API
 *
 * OpenAPI spec version: 5
 * Contact: sdk@isilon.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */


#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct LicenseGenerateHardwareItem {
  /// Licensed terabyte (TB, 10^12 bytes) drive capacity allocated as storage associated with tier. Included if tier is not NONINF and license is not a base only license.
  #[serde(rename = "drive_capacity")]
  drive_capacity: Option<i32>,
  /// Licensed number of nodes in this tier.
  #[serde(rename = "node_count")]
  node_count: Option<i32>,
  /// Licensed number of nodes of this tier that contain self-encrypting drives. Included only if license is ONEFS and tier is not NONINF.
  #[serde(rename = "nodes_with_seds_count")]
  nodes_with_seds_count: Option<i32>,
  /// OneFS hardware tier. Tier is a number, NONINF, or NO_TIER. NONINF indicates a non infinity tier. NO_TIER indicates a license that is not tier based.
  #[serde(rename = "tier")]
  tier: Option<String>
}

impl LicenseGenerateHardwareItem {
  pub fn new() -> LicenseGenerateHardwareItem {
    LicenseGenerateHardwareItem {
      drive_capacity: None,
      node_count: None,
      nodes_with_seds_count: None,
      tier: None
    }
  }

  pub fn set_drive_capacity(&mut self, drive_capacity: i32) {
    self.drive_capacity = Some(drive_capacity);
  }

  pub fn with_drive_capacity(mut self, drive_capacity: i32) -> LicenseGenerateHardwareItem {
    self.drive_capacity = Some(drive_capacity);
    self
  }

  pub fn drive_capacity(&self) -> Option<&i32> {
    self.drive_capacity.as_ref()
  }

  pub fn reset_drive_capacity(&mut self) {
    self.drive_capacity = None;
  }

  pub fn set_node_count(&mut self, node_count: i32) {
    self.node_count = Some(node_count);
  }

  pub fn with_node_count(mut self, node_count: i32) -> LicenseGenerateHardwareItem {
    self.node_count = Some(node_count);
    self
  }

  pub fn node_count(&self) -> Option<&i32> {
    self.node_count.as_ref()
  }

  pub fn reset_node_count(&mut self) {
    self.node_count = None;
  }

  pub fn set_nodes_with_seds_count(&mut self, nodes_with_seds_count: i32) {
    self.nodes_with_seds_count = Some(nodes_with_seds_count);
  }

  pub fn with_nodes_with_seds_count(mut self, nodes_with_seds_count: i32) -> LicenseGenerateHardwareItem {
    self.nodes_with_seds_count = Some(nodes_with_seds_count);
    self
  }

  pub fn nodes_with_seds_count(&self) -> Option<&i32> {
    self.nodes_with_seds_count.as_ref()
  }

  pub fn reset_nodes_with_seds_count(&mut self) {
    self.nodes_with_seds_count = None;
  }

  pub fn set_tier(&mut self, tier: String) {
    self.tier = Some(tier);
  }

  pub fn with_tier(mut self, tier: String) -> LicenseGenerateHardwareItem {
    self.tier = Some(tier);
    self
  }

  pub fn tier(&self) -> Option<&String> {
    self.tier.as_ref()
  }

  pub fn reset_tier(&mut self) {
    self.tier = None;
  }

}



