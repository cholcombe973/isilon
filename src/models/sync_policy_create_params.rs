/* 
 * Isilon SDK
 *
 * Isilon SDK - Language bindings for the OneFS API
 *
 * OpenAPI spec version: 5
 * Contact: sdk@isilon.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */


#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct SyncPolicyCreateParams {
  /// If set to true, SyncIQ will perform failback configuration tasks during the next job run, rather than waiting to perform those tasks during the failback process. Performing these tasks ahead of time will increase the speed of failback operations.
  #[serde(rename = "accelerated_failback")]
  accelerated_failback: Option<bool>,
  /// If 'copy', source files will be copied to the target cluster.  If 'sync', the target directory will be made an image of the source directory:  Files and directories that have been deleted on the source, have been moved within the target directory, or no longer match the selection criteria will be deleted from the target directory.
  #[serde(rename = "action")]
  action: String,
  /// NOTE: This field should not be changed without the help of Isilon support.  Enable/disable UDP-based data transfer.
  #[serde(rename = "burst_mode")]
  burst_mode: Option<bool>,
  /// If true, retain previous source snapshot and incremental repstate, both of which are required for changelist creation.
  #[serde(rename = "changelist")]
  changelist: Option<bool>,
  /// If true, the sync target performs cyclic redundancy checks (CRC) on the data as it is received.
  #[serde(rename = "check_integrity")]
  check_integrity: Option<bool>,
  /// If set to deny, replicates all CloudPools smartlinks to the target cluster as smartlinks; if the target cluster does not support the smartlinks, the job will fail. If set to force, replicates all smartlinks to the target cluster as regular files. If set to allow, SyncIQ will attempt to replicate smartlinks to the target cluster as smartlinks; if the target cluster does not support the smartlinks, SyncIQ will replicate the smartlinks as regular files.
  #[serde(rename = "cloud_deep_copy")]
  cloud_deep_copy: Option<String>,
  /// User-assigned description of this sync policy.
  #[serde(rename = "description")]
  description: Option<String>,
  /// NOTE: This field should not be changed without the help of Isilon support.  If true, the 7.2+ file splitting capability will be disabled.
  #[serde(rename = "disable_file_split")]
  disable_file_split: Option<bool>,
  /// NOTE: This field should not be changed without the help of Isilon support.  Enable/disable sync failover/failback.
  #[serde(rename = "disable_fofb")]
  disable_fofb: Option<bool>,
  /// NOTE: This field should not be changed without the help of Isilon support.  Enable/disable the 6.5+ STF based data transfer and uses only treewalk.
  #[serde(rename = "disable_stf")]
  disable_stf: Option<bool>,
  /// If true, jobs will be automatically run based on this policy, according to its schedule.
  #[serde(rename = "enabled")]
  enabled: Option<bool>,
  /// NOTE: This field should not be changed without the help of Isilon support.  Continue sending files even with the corrupted filesystem.
  #[serde(rename = "expected_dataloss")]
  expected_dataloss: Option<bool>,
  /// A file matching pattern, organized as an OR'ed set of AND'ed file criteria, for example ((a AND b) OR (x AND y)) used to define a set of files with specific properties.  Policies of type 'sync' cannot use 'path' or time criteria in their matching patterns, but policies of type 'copy' can use all listed criteria.
  #[serde(rename = "file_matching_pattern")]
  file_matching_pattern: Option<::models::SyncJobPolicyFileMatchingPattern>,
  /// NOTE: This field should not be changed without the help of Isilon support.  Determines whether data is sent only through the subnet and pool specified in the \"source_network\" field. This option can be useful if there are multiple interfaces for the given source subnet.  If you enable this option, the net.inet.ip.choose_ifa_by_ipsrc sysctl should be set.
  #[serde(rename = "force_interface")]
  force_interface: Option<bool>,
  /// If --schedule is set to When-Source-Modified, the duration to wait after a modification is made before starting a job (default is 0 seconds).
  #[serde(rename = "job_delay")]
  job_delay: Option<i32>,
  /// Severity an event must reach before it is logged.
  #[serde(rename = "log_level")]
  log_level: Option<String>,
  /// If true, the system will log any files or directories that are deleted due to a sync.
  #[serde(rename = "log_removed_files")]
  log_removed_files: Option<bool>,
  /// User-assigned name of this sync policy.
  #[serde(rename = "name")]
  name: String,
  /// The password for the target cluster.  This field is not readable.
  #[serde(rename = "password")]
  password: Option<String>,
  /// Determines the priority level of a policy. Policies with higher priority will have precedence to run over lower priority policies. Valid range is [0, 1]. Default is 0.
  #[serde(rename = "priority")]
  priority: Option<i32>,
  /// Length of time (in seconds) a policy report will be stored.
  #[serde(rename = "report_max_age")]
  report_max_age: Option<i32>,
  /// Maximum number of policy reports that will be stored on the system.
  #[serde(rename = "report_max_count")]
  report_max_count: Option<i32>,
  /// If you specify true, and you specify a SmartConnect zone in the \"target_host\" field, replication policies will connect only to nodes in the specified SmartConnect zone.  If you specify false, replication policies are not restricted to specific nodes on the target cluster.
  #[serde(rename = "restrict_target_network")]
  restrict_target_network: Option<bool>,
  /// If --schedule is set to a time/date, an alert is created if the specified RPO for this policy is exceeded. The default value is 0, which will not generate RPO alerts.
  #[serde(rename = "rpo_alert")]
  rpo_alert: Option<i32>,
  /// The schedule on which new jobs will be run for this policy.
  #[serde(rename = "schedule")]
  schedule: Option<String>,
  /// Skip DNS lookup of target IPs.
  #[serde(rename = "skip_lookup")]
  skip_lookup: Option<bool>,
  /// If true and --schedule is set to a time/date, the policy will not run if no changes have been made to the contents of the source directory since the last job successfully completed.
  #[serde(rename = "skip_when_source_unmodified")]
  skip_when_source_unmodified: Option<bool>,
  /// If true, snapshot-triggered syncs will include snapshots taken before policy creation time (requires --schedule when-snapshot-taken).
  #[serde(rename = "snapshot_sync_existing")]
  snapshot_sync_existing: Option<bool>,
  /// The naming pattern that a snapshot must match to trigger a sync when the schedule is when-snapshot-taken (default is \"*\").
  #[serde(rename = "snapshot_sync_pattern")]
  snapshot_sync_pattern: Option<String>,
  /// Directories that will be excluded from the sync.  Modifying this field will result in a full synchronization of all data.
  #[serde(rename = "source_exclude_directories")]
  source_exclude_directories: Option<Vec<String>>,
  /// Directories that will be included in the sync.  Modifying this field will result in a full synchronization of all data.
  #[serde(rename = "source_include_directories")]
  source_include_directories: Option<Vec<String>>,
  /// Restricts replication policies on the local cluster to running on the specified subnet and pool.
  #[serde(rename = "source_network")]
  source_network: Option<::models::SyncPolicySourceNetwork>,
  /// The root directory on the source cluster the files will be synced from.  Modifying this field will result in a full synchronization of all data.
  #[serde(rename = "source_root_path")]
  source_root_path: String,
  /// If true, archival snapshots of the source data will be taken on the source cluster before a sync.
  #[serde(rename = "source_snapshot_archive")]
  source_snapshot_archive: Option<bool>,
  /// The length of time in seconds to keep snapshots on the source cluster.
  #[serde(rename = "source_snapshot_expiration")]
  source_snapshot_expiration: Option<i32>,
  /// The name pattern for snapshots taken on the source cluster before a sync.
  #[serde(rename = "source_snapshot_pattern")]
  source_snapshot_pattern: Option<String>,
  /// If true, the target creates diffs against the original sync.
  #[serde(rename = "target_compare_initial_sync")]
  target_compare_initial_sync: Option<bool>,
  /// If true, target cluster will detect if files have been changed on the target by legacy tree walk syncs.
  #[serde(rename = "target_detect_modifications")]
  target_detect_modifications: Option<bool>,
  /// Hostname or IP address of sync target cluster.  Modifying the target cluster host can result in the policy being unrunnable if the new target does not match the current target association.
  #[serde(rename = "target_host")]
  target_host: String,
  /// Absolute filesystem path on the target cluster for the sync destination.
  #[serde(rename = "target_path")]
  target_path: String,
  /// The alias of the snapshot taken on the target cluster after the sync completes. A value of @DEFAULT will reset this field to the default creation value.
  #[serde(rename = "target_snapshot_alias")]
  target_snapshot_alias: Option<String>,
  /// If true, archival snapshots of the target data will be taken on the target cluster after successful sync completions.
  #[serde(rename = "target_snapshot_archive")]
  target_snapshot_archive: Option<bool>,
  /// The length of time in seconds to keep snapshots on the target cluster.
  #[serde(rename = "target_snapshot_expiration")]
  target_snapshot_expiration: Option<i32>,
  /// The name pattern for snapshots taken on the target cluster after the sync completes.  A value of @DEFAULT will reset this field to the default creation value.
  #[serde(rename = "target_snapshot_pattern")]
  target_snapshot_pattern: Option<String>,
  /// The number of worker threads on a node performing a sync.
  #[serde(rename = "workers_per_node")]
  workers_per_node: Option<i32>
}

impl SyncPolicyCreateParams {
  pub fn new(action: String, name: String, source_root_path: String, target_host: String, target_path: String) -> SyncPolicyCreateParams {
    SyncPolicyCreateParams {
      accelerated_failback: None,
      action: action,
      burst_mode: None,
      changelist: None,
      check_integrity: None,
      cloud_deep_copy: None,
      description: None,
      disable_file_split: None,
      disable_fofb: None,
      disable_stf: None,
      enabled: None,
      expected_dataloss: None,
      file_matching_pattern: None,
      force_interface: None,
      job_delay: None,
      log_level: None,
      log_removed_files: None,
      name: name,
      password: None,
      priority: None,
      report_max_age: None,
      report_max_count: None,
      restrict_target_network: None,
      rpo_alert: None,
      schedule: None,
      skip_lookup: None,
      skip_when_source_unmodified: None,
      snapshot_sync_existing: None,
      snapshot_sync_pattern: None,
      source_exclude_directories: None,
      source_include_directories: None,
      source_network: None,
      source_root_path: source_root_path,
      source_snapshot_archive: None,
      source_snapshot_expiration: None,
      source_snapshot_pattern: None,
      target_compare_initial_sync: None,
      target_detect_modifications: None,
      target_host: target_host,
      target_path: target_path,
      target_snapshot_alias: None,
      target_snapshot_archive: None,
      target_snapshot_expiration: None,
      target_snapshot_pattern: None,
      workers_per_node: None
    }
  }

  pub fn set_accelerated_failback(&mut self, accelerated_failback: bool) {
    self.accelerated_failback = Some(accelerated_failback);
  }

  pub fn with_accelerated_failback(mut self, accelerated_failback: bool) -> SyncPolicyCreateParams {
    self.accelerated_failback = Some(accelerated_failback);
    self
  }

  pub fn accelerated_failback(&self) -> Option<&bool> {
    self.accelerated_failback.as_ref()
  }

  pub fn reset_accelerated_failback(&mut self) {
    self.accelerated_failback = None;
  }

  pub fn set_action(&mut self, action: String) {
    self.action = action;
  }

  pub fn with_action(mut self, action: String) -> SyncPolicyCreateParams {
    self.action = action;
    self
  }

  pub fn action(&self) -> &String {
    &self.action
  }


  pub fn set_burst_mode(&mut self, burst_mode: bool) {
    self.burst_mode = Some(burst_mode);
  }

  pub fn with_burst_mode(mut self, burst_mode: bool) -> SyncPolicyCreateParams {
    self.burst_mode = Some(burst_mode);
    self
  }

  pub fn burst_mode(&self) -> Option<&bool> {
    self.burst_mode.as_ref()
  }

  pub fn reset_burst_mode(&mut self) {
    self.burst_mode = None;
  }

  pub fn set_changelist(&mut self, changelist: bool) {
    self.changelist = Some(changelist);
  }

  pub fn with_changelist(mut self, changelist: bool) -> SyncPolicyCreateParams {
    self.changelist = Some(changelist);
    self
  }

  pub fn changelist(&self) -> Option<&bool> {
    self.changelist.as_ref()
  }

  pub fn reset_changelist(&mut self) {
    self.changelist = None;
  }

  pub fn set_check_integrity(&mut self, check_integrity: bool) {
    self.check_integrity = Some(check_integrity);
  }

  pub fn with_check_integrity(mut self, check_integrity: bool) -> SyncPolicyCreateParams {
    self.check_integrity = Some(check_integrity);
    self
  }

  pub fn check_integrity(&self) -> Option<&bool> {
    self.check_integrity.as_ref()
  }

  pub fn reset_check_integrity(&mut self) {
    self.check_integrity = None;
  }

  pub fn set_cloud_deep_copy(&mut self, cloud_deep_copy: String) {
    self.cloud_deep_copy = Some(cloud_deep_copy);
  }

  pub fn with_cloud_deep_copy(mut self, cloud_deep_copy: String) -> SyncPolicyCreateParams {
    self.cloud_deep_copy = Some(cloud_deep_copy);
    self
  }

  pub fn cloud_deep_copy(&self) -> Option<&String> {
    self.cloud_deep_copy.as_ref()
  }

  pub fn reset_cloud_deep_copy(&mut self) {
    self.cloud_deep_copy = None;
  }

  pub fn set_description(&mut self, description: String) {
    self.description = Some(description);
  }

  pub fn with_description(mut self, description: String) -> SyncPolicyCreateParams {
    self.description = Some(description);
    self
  }

  pub fn description(&self) -> Option<&String> {
    self.description.as_ref()
  }

  pub fn reset_description(&mut self) {
    self.description = None;
  }

  pub fn set_disable_file_split(&mut self, disable_file_split: bool) {
    self.disable_file_split = Some(disable_file_split);
  }

  pub fn with_disable_file_split(mut self, disable_file_split: bool) -> SyncPolicyCreateParams {
    self.disable_file_split = Some(disable_file_split);
    self
  }

  pub fn disable_file_split(&self) -> Option<&bool> {
    self.disable_file_split.as_ref()
  }

  pub fn reset_disable_file_split(&mut self) {
    self.disable_file_split = None;
  }

  pub fn set_disable_fofb(&mut self, disable_fofb: bool) {
    self.disable_fofb = Some(disable_fofb);
  }

  pub fn with_disable_fofb(mut self, disable_fofb: bool) -> SyncPolicyCreateParams {
    self.disable_fofb = Some(disable_fofb);
    self
  }

  pub fn disable_fofb(&self) -> Option<&bool> {
    self.disable_fofb.as_ref()
  }

  pub fn reset_disable_fofb(&mut self) {
    self.disable_fofb = None;
  }

  pub fn set_disable_stf(&mut self, disable_stf: bool) {
    self.disable_stf = Some(disable_stf);
  }

  pub fn with_disable_stf(mut self, disable_stf: bool) -> SyncPolicyCreateParams {
    self.disable_stf = Some(disable_stf);
    self
  }

  pub fn disable_stf(&self) -> Option<&bool> {
    self.disable_stf.as_ref()
  }

  pub fn reset_disable_stf(&mut self) {
    self.disable_stf = None;
  }

  pub fn set_enabled(&mut self, enabled: bool) {
    self.enabled = Some(enabled);
  }

  pub fn with_enabled(mut self, enabled: bool) -> SyncPolicyCreateParams {
    self.enabled = Some(enabled);
    self
  }

  pub fn enabled(&self) -> Option<&bool> {
    self.enabled.as_ref()
  }

  pub fn reset_enabled(&mut self) {
    self.enabled = None;
  }

  pub fn set_expected_dataloss(&mut self, expected_dataloss: bool) {
    self.expected_dataloss = Some(expected_dataloss);
  }

  pub fn with_expected_dataloss(mut self, expected_dataloss: bool) -> SyncPolicyCreateParams {
    self.expected_dataloss = Some(expected_dataloss);
    self
  }

  pub fn expected_dataloss(&self) -> Option<&bool> {
    self.expected_dataloss.as_ref()
  }

  pub fn reset_expected_dataloss(&mut self) {
    self.expected_dataloss = None;
  }

  pub fn set_file_matching_pattern(&mut self, file_matching_pattern: ::models::SyncJobPolicyFileMatchingPattern) {
    self.file_matching_pattern = Some(file_matching_pattern);
  }

  pub fn with_file_matching_pattern(mut self, file_matching_pattern: ::models::SyncJobPolicyFileMatchingPattern) -> SyncPolicyCreateParams {
    self.file_matching_pattern = Some(file_matching_pattern);
    self
  }

  pub fn file_matching_pattern(&self) -> Option<&::models::SyncJobPolicyFileMatchingPattern> {
    self.file_matching_pattern.as_ref()
  }

  pub fn reset_file_matching_pattern(&mut self) {
    self.file_matching_pattern = None;
  }

  pub fn set_force_interface(&mut self, force_interface: bool) {
    self.force_interface = Some(force_interface);
  }

  pub fn with_force_interface(mut self, force_interface: bool) -> SyncPolicyCreateParams {
    self.force_interface = Some(force_interface);
    self
  }

  pub fn force_interface(&self) -> Option<&bool> {
    self.force_interface.as_ref()
  }

  pub fn reset_force_interface(&mut self) {
    self.force_interface = None;
  }

  pub fn set_job_delay(&mut self, job_delay: i32) {
    self.job_delay = Some(job_delay);
  }

  pub fn with_job_delay(mut self, job_delay: i32) -> SyncPolicyCreateParams {
    self.job_delay = Some(job_delay);
    self
  }

  pub fn job_delay(&self) -> Option<&i32> {
    self.job_delay.as_ref()
  }

  pub fn reset_job_delay(&mut self) {
    self.job_delay = None;
  }

  pub fn set_log_level(&mut self, log_level: String) {
    self.log_level = Some(log_level);
  }

  pub fn with_log_level(mut self, log_level: String) -> SyncPolicyCreateParams {
    self.log_level = Some(log_level);
    self
  }

  pub fn log_level(&self) -> Option<&String> {
    self.log_level.as_ref()
  }

  pub fn reset_log_level(&mut self) {
    self.log_level = None;
  }

  pub fn set_log_removed_files(&mut self, log_removed_files: bool) {
    self.log_removed_files = Some(log_removed_files);
  }

  pub fn with_log_removed_files(mut self, log_removed_files: bool) -> SyncPolicyCreateParams {
    self.log_removed_files = Some(log_removed_files);
    self
  }

  pub fn log_removed_files(&self) -> Option<&bool> {
    self.log_removed_files.as_ref()
  }

  pub fn reset_log_removed_files(&mut self) {
    self.log_removed_files = None;
  }

  pub fn set_name(&mut self, name: String) {
    self.name = name;
  }

  pub fn with_name(mut self, name: String) -> SyncPolicyCreateParams {
    self.name = name;
    self
  }

  pub fn name(&self) -> &String {
    &self.name
  }


  pub fn set_password(&mut self, password: String) {
    self.password = Some(password);
  }

  pub fn with_password(mut self, password: String) -> SyncPolicyCreateParams {
    self.password = Some(password);
    self
  }

  pub fn password(&self) -> Option<&String> {
    self.password.as_ref()
  }

  pub fn reset_password(&mut self) {
    self.password = None;
  }

  pub fn set_priority(&mut self, priority: i32) {
    self.priority = Some(priority);
  }

  pub fn with_priority(mut self, priority: i32) -> SyncPolicyCreateParams {
    self.priority = Some(priority);
    self
  }

  pub fn priority(&self) -> Option<&i32> {
    self.priority.as_ref()
  }

  pub fn reset_priority(&mut self) {
    self.priority = None;
  }

  pub fn set_report_max_age(&mut self, report_max_age: i32) {
    self.report_max_age = Some(report_max_age);
  }

  pub fn with_report_max_age(mut self, report_max_age: i32) -> SyncPolicyCreateParams {
    self.report_max_age = Some(report_max_age);
    self
  }

  pub fn report_max_age(&self) -> Option<&i32> {
    self.report_max_age.as_ref()
  }

  pub fn reset_report_max_age(&mut self) {
    self.report_max_age = None;
  }

  pub fn set_report_max_count(&mut self, report_max_count: i32) {
    self.report_max_count = Some(report_max_count);
  }

  pub fn with_report_max_count(mut self, report_max_count: i32) -> SyncPolicyCreateParams {
    self.report_max_count = Some(report_max_count);
    self
  }

  pub fn report_max_count(&self) -> Option<&i32> {
    self.report_max_count.as_ref()
  }

  pub fn reset_report_max_count(&mut self) {
    self.report_max_count = None;
  }

  pub fn set_restrict_target_network(&mut self, restrict_target_network: bool) {
    self.restrict_target_network = Some(restrict_target_network);
  }

  pub fn with_restrict_target_network(mut self, restrict_target_network: bool) -> SyncPolicyCreateParams {
    self.restrict_target_network = Some(restrict_target_network);
    self
  }

  pub fn restrict_target_network(&self) -> Option<&bool> {
    self.restrict_target_network.as_ref()
  }

  pub fn reset_restrict_target_network(&mut self) {
    self.restrict_target_network = None;
  }

  pub fn set_rpo_alert(&mut self, rpo_alert: i32) {
    self.rpo_alert = Some(rpo_alert);
  }

  pub fn with_rpo_alert(mut self, rpo_alert: i32) -> SyncPolicyCreateParams {
    self.rpo_alert = Some(rpo_alert);
    self
  }

  pub fn rpo_alert(&self) -> Option<&i32> {
    self.rpo_alert.as_ref()
  }

  pub fn reset_rpo_alert(&mut self) {
    self.rpo_alert = None;
  }

  pub fn set_schedule(&mut self, schedule: String) {
    self.schedule = Some(schedule);
  }

  pub fn with_schedule(mut self, schedule: String) -> SyncPolicyCreateParams {
    self.schedule = Some(schedule);
    self
  }

  pub fn schedule(&self) -> Option<&String> {
    self.schedule.as_ref()
  }

  pub fn reset_schedule(&mut self) {
    self.schedule = None;
  }

  pub fn set_skip_lookup(&mut self, skip_lookup: bool) {
    self.skip_lookup = Some(skip_lookup);
  }

  pub fn with_skip_lookup(mut self, skip_lookup: bool) -> SyncPolicyCreateParams {
    self.skip_lookup = Some(skip_lookup);
    self
  }

  pub fn skip_lookup(&self) -> Option<&bool> {
    self.skip_lookup.as_ref()
  }

  pub fn reset_skip_lookup(&mut self) {
    self.skip_lookup = None;
  }

  pub fn set_skip_when_source_unmodified(&mut self, skip_when_source_unmodified: bool) {
    self.skip_when_source_unmodified = Some(skip_when_source_unmodified);
  }

  pub fn with_skip_when_source_unmodified(mut self, skip_when_source_unmodified: bool) -> SyncPolicyCreateParams {
    self.skip_when_source_unmodified = Some(skip_when_source_unmodified);
    self
  }

  pub fn skip_when_source_unmodified(&self) -> Option<&bool> {
    self.skip_when_source_unmodified.as_ref()
  }

  pub fn reset_skip_when_source_unmodified(&mut self) {
    self.skip_when_source_unmodified = None;
  }

  pub fn set_snapshot_sync_existing(&mut self, snapshot_sync_existing: bool) {
    self.snapshot_sync_existing = Some(snapshot_sync_existing);
  }

  pub fn with_snapshot_sync_existing(mut self, snapshot_sync_existing: bool) -> SyncPolicyCreateParams {
    self.snapshot_sync_existing = Some(snapshot_sync_existing);
    self
  }

  pub fn snapshot_sync_existing(&self) -> Option<&bool> {
    self.snapshot_sync_existing.as_ref()
  }

  pub fn reset_snapshot_sync_existing(&mut self) {
    self.snapshot_sync_existing = None;
  }

  pub fn set_snapshot_sync_pattern(&mut self, snapshot_sync_pattern: String) {
    self.snapshot_sync_pattern = Some(snapshot_sync_pattern);
  }

  pub fn with_snapshot_sync_pattern(mut self, snapshot_sync_pattern: String) -> SyncPolicyCreateParams {
    self.snapshot_sync_pattern = Some(snapshot_sync_pattern);
    self
  }

  pub fn snapshot_sync_pattern(&self) -> Option<&String> {
    self.snapshot_sync_pattern.as_ref()
  }

  pub fn reset_snapshot_sync_pattern(&mut self) {
    self.snapshot_sync_pattern = None;
  }

  pub fn set_source_exclude_directories(&mut self, source_exclude_directories: Vec<String>) {
    self.source_exclude_directories = Some(source_exclude_directories);
  }

  pub fn with_source_exclude_directories(mut self, source_exclude_directories: Vec<String>) -> SyncPolicyCreateParams {
    self.source_exclude_directories = Some(source_exclude_directories);
    self
  }

  pub fn source_exclude_directories(&self) -> Option<&Vec<String>> {
    self.source_exclude_directories.as_ref()
  }

  pub fn reset_source_exclude_directories(&mut self) {
    self.source_exclude_directories = None;
  }

  pub fn set_source_include_directories(&mut self, source_include_directories: Vec<String>) {
    self.source_include_directories = Some(source_include_directories);
  }

  pub fn with_source_include_directories(mut self, source_include_directories: Vec<String>) -> SyncPolicyCreateParams {
    self.source_include_directories = Some(source_include_directories);
    self
  }

  pub fn source_include_directories(&self) -> Option<&Vec<String>> {
    self.source_include_directories.as_ref()
  }

  pub fn reset_source_include_directories(&mut self) {
    self.source_include_directories = None;
  }

  pub fn set_source_network(&mut self, source_network: ::models::SyncPolicySourceNetwork) {
    self.source_network = Some(source_network);
  }

  pub fn with_source_network(mut self, source_network: ::models::SyncPolicySourceNetwork) -> SyncPolicyCreateParams {
    self.source_network = Some(source_network);
    self
  }

  pub fn source_network(&self) -> Option<&::models::SyncPolicySourceNetwork> {
    self.source_network.as_ref()
  }

  pub fn reset_source_network(&mut self) {
    self.source_network = None;
  }

  pub fn set_source_root_path(&mut self, source_root_path: String) {
    self.source_root_path = source_root_path;
  }

  pub fn with_source_root_path(mut self, source_root_path: String) -> SyncPolicyCreateParams {
    self.source_root_path = source_root_path;
    self
  }

  pub fn source_root_path(&self) -> &String {
    &self.source_root_path
  }


  pub fn set_source_snapshot_archive(&mut self, source_snapshot_archive: bool) {
    self.source_snapshot_archive = Some(source_snapshot_archive);
  }

  pub fn with_source_snapshot_archive(mut self, source_snapshot_archive: bool) -> SyncPolicyCreateParams {
    self.source_snapshot_archive = Some(source_snapshot_archive);
    self
  }

  pub fn source_snapshot_archive(&self) -> Option<&bool> {
    self.source_snapshot_archive.as_ref()
  }

  pub fn reset_source_snapshot_archive(&mut self) {
    self.source_snapshot_archive = None;
  }

  pub fn set_source_snapshot_expiration(&mut self, source_snapshot_expiration: i32) {
    self.source_snapshot_expiration = Some(source_snapshot_expiration);
  }

  pub fn with_source_snapshot_expiration(mut self, source_snapshot_expiration: i32) -> SyncPolicyCreateParams {
    self.source_snapshot_expiration = Some(source_snapshot_expiration);
    self
  }

  pub fn source_snapshot_expiration(&self) -> Option<&i32> {
    self.source_snapshot_expiration.as_ref()
  }

  pub fn reset_source_snapshot_expiration(&mut self) {
    self.source_snapshot_expiration = None;
  }

  pub fn set_source_snapshot_pattern(&mut self, source_snapshot_pattern: String) {
    self.source_snapshot_pattern = Some(source_snapshot_pattern);
  }

  pub fn with_source_snapshot_pattern(mut self, source_snapshot_pattern: String) -> SyncPolicyCreateParams {
    self.source_snapshot_pattern = Some(source_snapshot_pattern);
    self
  }

  pub fn source_snapshot_pattern(&self) -> Option<&String> {
    self.source_snapshot_pattern.as_ref()
  }

  pub fn reset_source_snapshot_pattern(&mut self) {
    self.source_snapshot_pattern = None;
  }

  pub fn set_target_compare_initial_sync(&mut self, target_compare_initial_sync: bool) {
    self.target_compare_initial_sync = Some(target_compare_initial_sync);
  }

  pub fn with_target_compare_initial_sync(mut self, target_compare_initial_sync: bool) -> SyncPolicyCreateParams {
    self.target_compare_initial_sync = Some(target_compare_initial_sync);
    self
  }

  pub fn target_compare_initial_sync(&self) -> Option<&bool> {
    self.target_compare_initial_sync.as_ref()
  }

  pub fn reset_target_compare_initial_sync(&mut self) {
    self.target_compare_initial_sync = None;
  }

  pub fn set_target_detect_modifications(&mut self, target_detect_modifications: bool) {
    self.target_detect_modifications = Some(target_detect_modifications);
  }

  pub fn with_target_detect_modifications(mut self, target_detect_modifications: bool) -> SyncPolicyCreateParams {
    self.target_detect_modifications = Some(target_detect_modifications);
    self
  }

  pub fn target_detect_modifications(&self) -> Option<&bool> {
    self.target_detect_modifications.as_ref()
  }

  pub fn reset_target_detect_modifications(&mut self) {
    self.target_detect_modifications = None;
  }

  pub fn set_target_host(&mut self, target_host: String) {
    self.target_host = target_host;
  }

  pub fn with_target_host(mut self, target_host: String) -> SyncPolicyCreateParams {
    self.target_host = target_host;
    self
  }

  pub fn target_host(&self) -> &String {
    &self.target_host
  }


  pub fn set_target_path(&mut self, target_path: String) {
    self.target_path = target_path;
  }

  pub fn with_target_path(mut self, target_path: String) -> SyncPolicyCreateParams {
    self.target_path = target_path;
    self
  }

  pub fn target_path(&self) -> &String {
    &self.target_path
  }


  pub fn set_target_snapshot_alias(&mut self, target_snapshot_alias: String) {
    self.target_snapshot_alias = Some(target_snapshot_alias);
  }

  pub fn with_target_snapshot_alias(mut self, target_snapshot_alias: String) -> SyncPolicyCreateParams {
    self.target_snapshot_alias = Some(target_snapshot_alias);
    self
  }

  pub fn target_snapshot_alias(&self) -> Option<&String> {
    self.target_snapshot_alias.as_ref()
  }

  pub fn reset_target_snapshot_alias(&mut self) {
    self.target_snapshot_alias = None;
  }

  pub fn set_target_snapshot_archive(&mut self, target_snapshot_archive: bool) {
    self.target_snapshot_archive = Some(target_snapshot_archive);
  }

  pub fn with_target_snapshot_archive(mut self, target_snapshot_archive: bool) -> SyncPolicyCreateParams {
    self.target_snapshot_archive = Some(target_snapshot_archive);
    self
  }

  pub fn target_snapshot_archive(&self) -> Option<&bool> {
    self.target_snapshot_archive.as_ref()
  }

  pub fn reset_target_snapshot_archive(&mut self) {
    self.target_snapshot_archive = None;
  }

  pub fn set_target_snapshot_expiration(&mut self, target_snapshot_expiration: i32) {
    self.target_snapshot_expiration = Some(target_snapshot_expiration);
  }

  pub fn with_target_snapshot_expiration(mut self, target_snapshot_expiration: i32) -> SyncPolicyCreateParams {
    self.target_snapshot_expiration = Some(target_snapshot_expiration);
    self
  }

  pub fn target_snapshot_expiration(&self) -> Option<&i32> {
    self.target_snapshot_expiration.as_ref()
  }

  pub fn reset_target_snapshot_expiration(&mut self) {
    self.target_snapshot_expiration = None;
  }

  pub fn set_target_snapshot_pattern(&mut self, target_snapshot_pattern: String) {
    self.target_snapshot_pattern = Some(target_snapshot_pattern);
  }

  pub fn with_target_snapshot_pattern(mut self, target_snapshot_pattern: String) -> SyncPolicyCreateParams {
    self.target_snapshot_pattern = Some(target_snapshot_pattern);
    self
  }

  pub fn target_snapshot_pattern(&self) -> Option<&String> {
    self.target_snapshot_pattern.as_ref()
  }

  pub fn reset_target_snapshot_pattern(&mut self) {
    self.target_snapshot_pattern = None;
  }

  pub fn set_workers_per_node(&mut self, workers_per_node: i32) {
    self.workers_per_node = Some(workers_per_node);
  }

  pub fn with_workers_per_node(mut self, workers_per_node: i32) -> SyncPolicyCreateParams {
    self.workers_per_node = Some(workers_per_node);
    self
  }

  pub fn workers_per_node(&self) -> Option<&i32> {
    self.workers_per_node.as_ref()
  }

  pub fn reset_workers_per_node(&mut self) {
    self.workers_per_node = None;
  }

}



