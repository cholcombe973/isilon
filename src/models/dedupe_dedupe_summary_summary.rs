/* 
 * Isilon SDK
 *
 * Isilon SDK - Language bindings for the OneFS API
 *
 * OpenAPI spec version: 5
 * Contact: sdk@isilon.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */


#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct DedupeDedupeSummarySummary {
  /// Size in bytes of a filesystem block.
  #[serde(rename = "block_size")]
  block_size: f32,
  /// Estimated number of physical blocks deduped.
  #[serde(rename = "estimated_physical_blocks")]
  estimated_physical_blocks: f32,
  /// Estimated number of physical blocks saved by dedupe.
  #[serde(rename = "estimated_saved_blocks")]
  estimated_saved_blocks: f32,
  /// Number of logical blocks deduped.
  #[serde(rename = "logical_blocks")]
  logical_blocks: f32,
  /// Number of logical blocks saved by dedupe.
  #[serde(rename = "saved_logical_blocks")]
  saved_logical_blocks: f32,
  /// Total physical blocks in the cluster.
  #[serde(rename = "total_blocks")]
  total_blocks: f32,
  /// Total physical blocks used in the cluster.
  #[serde(rename = "used_blocks")]
  used_blocks: f32
}

impl DedupeDedupeSummarySummary {
  pub fn new(block_size: f32, estimated_physical_blocks: f32, estimated_saved_blocks: f32, logical_blocks: f32, saved_logical_blocks: f32, total_blocks: f32, used_blocks: f32) -> DedupeDedupeSummarySummary {
    DedupeDedupeSummarySummary {
      block_size: block_size,
      estimated_physical_blocks: estimated_physical_blocks,
      estimated_saved_blocks: estimated_saved_blocks,
      logical_blocks: logical_blocks,
      saved_logical_blocks: saved_logical_blocks,
      total_blocks: total_blocks,
      used_blocks: used_blocks
    }
  }

  pub fn set_block_size(&mut self, block_size: f32) {
    self.block_size = block_size;
  }

  pub fn with_block_size(mut self, block_size: f32) -> DedupeDedupeSummarySummary {
    self.block_size = block_size;
    self
  }

  pub fn block_size(&self) -> &f32 {
    &self.block_size
  }


  pub fn set_estimated_physical_blocks(&mut self, estimated_physical_blocks: f32) {
    self.estimated_physical_blocks = estimated_physical_blocks;
  }

  pub fn with_estimated_physical_blocks(mut self, estimated_physical_blocks: f32) -> DedupeDedupeSummarySummary {
    self.estimated_physical_blocks = estimated_physical_blocks;
    self
  }

  pub fn estimated_physical_blocks(&self) -> &f32 {
    &self.estimated_physical_blocks
  }


  pub fn set_estimated_saved_blocks(&mut self, estimated_saved_blocks: f32) {
    self.estimated_saved_blocks = estimated_saved_blocks;
  }

  pub fn with_estimated_saved_blocks(mut self, estimated_saved_blocks: f32) -> DedupeDedupeSummarySummary {
    self.estimated_saved_blocks = estimated_saved_blocks;
    self
  }

  pub fn estimated_saved_blocks(&self) -> &f32 {
    &self.estimated_saved_blocks
  }


  pub fn set_logical_blocks(&mut self, logical_blocks: f32) {
    self.logical_blocks = logical_blocks;
  }

  pub fn with_logical_blocks(mut self, logical_blocks: f32) -> DedupeDedupeSummarySummary {
    self.logical_blocks = logical_blocks;
    self
  }

  pub fn logical_blocks(&self) -> &f32 {
    &self.logical_blocks
  }


  pub fn set_saved_logical_blocks(&mut self, saved_logical_blocks: f32) {
    self.saved_logical_blocks = saved_logical_blocks;
  }

  pub fn with_saved_logical_blocks(mut self, saved_logical_blocks: f32) -> DedupeDedupeSummarySummary {
    self.saved_logical_blocks = saved_logical_blocks;
    self
  }

  pub fn saved_logical_blocks(&self) -> &f32 {
    &self.saved_logical_blocks
  }


  pub fn set_total_blocks(&mut self, total_blocks: f32) {
    self.total_blocks = total_blocks;
  }

  pub fn with_total_blocks(mut self, total_blocks: f32) -> DedupeDedupeSummarySummary {
    self.total_blocks = total_blocks;
    self
  }

  pub fn total_blocks(&self) -> &f32 {
    &self.total_blocks
  }


  pub fn set_used_blocks(&mut self, used_blocks: f32) {
    self.used_blocks = used_blocks;
  }

  pub fn with_used_blocks(mut self, used_blocks: f32) -> DedupeDedupeSummarySummary {
    self.used_blocks = used_blocks;
    self
  }

  pub fn used_blocks(&self) -> &f32 {
    &self.used_blocks
  }


}



