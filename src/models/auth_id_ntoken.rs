/* 
 * Isilon SDK
 *
 * Isilon SDK - Language bindings for the OneFS API
 *
 * OpenAPI spec version: 5
 * Contact: sdk@isilon.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */


#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct AuthIdNtoken {
  /// Specifies additional UIDs, GIDs, and SIDs.
  #[serde(rename = "additional_id")]
  additional_id: Option<Vec<::models::AuthAccessAccessItemFileGroup>>,
  /// Specifies properties for a persona, which consists of either a 'type' and a 'name' or an 'ID'.
  #[serde(rename = "gid")]
  gid: Option<::models::AuthAccessAccessItemFileGroup>,
  /// Specifies properties for a persona, which consists of either a 'type' and a 'name' or an 'ID'.
  #[serde(rename = "group_sid")]
  group_sid: Option<::models::AuthAccessAccessItemFileGroup>,
  /// Indicates if this user has restricted access to the /ifs file system.
  #[serde(rename = "ifs_restricted")]
  ifs_restricted: Option<bool>,
  #[serde(rename = "local_address")]
  local_address: Option<String>,
  /// Specifies properties for a persona, which consists of either a 'type' and a 'name' or an 'ID'.
  #[serde(rename = "on_disk_group_id")]
  on_disk_group_id: Option<::models::AuthAccessAccessItemFileGroup>,
  /// Specifies properties for a persona, which consists of either a 'type' and a 'name' or an 'ID'.
  #[serde(rename = "on_disk_user_id")]
  on_disk_user_id: Option<::models::AuthAccessAccessItemFileGroup>,
  /// Specifies the privileges granted to the currently authenticated user.
  #[serde(rename = "privilege")]
  privilege: Option<Vec<::models::AuthIdNtokenPrivilegeItem>>,
  #[serde(rename = "protocol")]
  protocol: Option<i32>,
  #[serde(rename = "remote_address")]
  remote_address: Option<String>,
  /// Specifies properties for a persona, which consists of either a 'type' and a 'name' or an 'ID'.
  #[serde(rename = "uid")]
  uid: Option<::models::AuthAccessAccessItemFileGroup>,
  /// Specifies properties for a persona, which consists of either a 'type' and a 'name' or an 'ID'.
  #[serde(rename = "user_sid")]
  user_sid: Option<::models::AuthAccessAccessItemFileGroup>,
  #[serde(rename = "zid")]
  zid: Option<i32>,
  #[serde(rename = "zone_id")]
  zone_id: Option<String>
}

impl AuthIdNtoken {
  pub fn new() -> AuthIdNtoken {
    AuthIdNtoken {
      additional_id: None,
      gid: None,
      group_sid: None,
      ifs_restricted: None,
      local_address: None,
      on_disk_group_id: None,
      on_disk_user_id: None,
      privilege: None,
      protocol: None,
      remote_address: None,
      uid: None,
      user_sid: None,
      zid: None,
      zone_id: None
    }
  }

  pub fn set_additional_id(&mut self, additional_id: Vec<::models::AuthAccessAccessItemFileGroup>) {
    self.additional_id = Some(additional_id);
  }

  pub fn with_additional_id(mut self, additional_id: Vec<::models::AuthAccessAccessItemFileGroup>) -> AuthIdNtoken {
    self.additional_id = Some(additional_id);
    self
  }

  pub fn additional_id(&self) -> Option<&Vec<::models::AuthAccessAccessItemFileGroup>> {
    self.additional_id.as_ref()
  }

  pub fn reset_additional_id(&mut self) {
    self.additional_id = None;
  }

  pub fn set_gid(&mut self, gid: ::models::AuthAccessAccessItemFileGroup) {
    self.gid = Some(gid);
  }

  pub fn with_gid(mut self, gid: ::models::AuthAccessAccessItemFileGroup) -> AuthIdNtoken {
    self.gid = Some(gid);
    self
  }

  pub fn gid(&self) -> Option<&::models::AuthAccessAccessItemFileGroup> {
    self.gid.as_ref()
  }

  pub fn reset_gid(&mut self) {
    self.gid = None;
  }

  pub fn set_group_sid(&mut self, group_sid: ::models::AuthAccessAccessItemFileGroup) {
    self.group_sid = Some(group_sid);
  }

  pub fn with_group_sid(mut self, group_sid: ::models::AuthAccessAccessItemFileGroup) -> AuthIdNtoken {
    self.group_sid = Some(group_sid);
    self
  }

  pub fn group_sid(&self) -> Option<&::models::AuthAccessAccessItemFileGroup> {
    self.group_sid.as_ref()
  }

  pub fn reset_group_sid(&mut self) {
    self.group_sid = None;
  }

  pub fn set_ifs_restricted(&mut self, ifs_restricted: bool) {
    self.ifs_restricted = Some(ifs_restricted);
  }

  pub fn with_ifs_restricted(mut self, ifs_restricted: bool) -> AuthIdNtoken {
    self.ifs_restricted = Some(ifs_restricted);
    self
  }

  pub fn ifs_restricted(&self) -> Option<&bool> {
    self.ifs_restricted.as_ref()
  }

  pub fn reset_ifs_restricted(&mut self) {
    self.ifs_restricted = None;
  }

  pub fn set_local_address(&mut self, local_address: String) {
    self.local_address = Some(local_address);
  }

  pub fn with_local_address(mut self, local_address: String) -> AuthIdNtoken {
    self.local_address = Some(local_address);
    self
  }

  pub fn local_address(&self) -> Option<&String> {
    self.local_address.as_ref()
  }

  pub fn reset_local_address(&mut self) {
    self.local_address = None;
  }

  pub fn set_on_disk_group_id(&mut self, on_disk_group_id: ::models::AuthAccessAccessItemFileGroup) {
    self.on_disk_group_id = Some(on_disk_group_id);
  }

  pub fn with_on_disk_group_id(mut self, on_disk_group_id: ::models::AuthAccessAccessItemFileGroup) -> AuthIdNtoken {
    self.on_disk_group_id = Some(on_disk_group_id);
    self
  }

  pub fn on_disk_group_id(&self) -> Option<&::models::AuthAccessAccessItemFileGroup> {
    self.on_disk_group_id.as_ref()
  }

  pub fn reset_on_disk_group_id(&mut self) {
    self.on_disk_group_id = None;
  }

  pub fn set_on_disk_user_id(&mut self, on_disk_user_id: ::models::AuthAccessAccessItemFileGroup) {
    self.on_disk_user_id = Some(on_disk_user_id);
  }

  pub fn with_on_disk_user_id(mut self, on_disk_user_id: ::models::AuthAccessAccessItemFileGroup) -> AuthIdNtoken {
    self.on_disk_user_id = Some(on_disk_user_id);
    self
  }

  pub fn on_disk_user_id(&self) -> Option<&::models::AuthAccessAccessItemFileGroup> {
    self.on_disk_user_id.as_ref()
  }

  pub fn reset_on_disk_user_id(&mut self) {
    self.on_disk_user_id = None;
  }

  pub fn set_privilege(&mut self, privilege: Vec<::models::AuthIdNtokenPrivilegeItem>) {
    self.privilege = Some(privilege);
  }

  pub fn with_privilege(mut self, privilege: Vec<::models::AuthIdNtokenPrivilegeItem>) -> AuthIdNtoken {
    self.privilege = Some(privilege);
    self
  }

  pub fn privilege(&self) -> Option<&Vec<::models::AuthIdNtokenPrivilegeItem>> {
    self.privilege.as_ref()
  }

  pub fn reset_privilege(&mut self) {
    self.privilege = None;
  }

  pub fn set_protocol(&mut self, protocol: i32) {
    self.protocol = Some(protocol);
  }

  pub fn with_protocol(mut self, protocol: i32) -> AuthIdNtoken {
    self.protocol = Some(protocol);
    self
  }

  pub fn protocol(&self) -> Option<&i32> {
    self.protocol.as_ref()
  }

  pub fn reset_protocol(&mut self) {
    self.protocol = None;
  }

  pub fn set_remote_address(&mut self, remote_address: String) {
    self.remote_address = Some(remote_address);
  }

  pub fn with_remote_address(mut self, remote_address: String) -> AuthIdNtoken {
    self.remote_address = Some(remote_address);
    self
  }

  pub fn remote_address(&self) -> Option<&String> {
    self.remote_address.as_ref()
  }

  pub fn reset_remote_address(&mut self) {
    self.remote_address = None;
  }

  pub fn set_uid(&mut self, uid: ::models::AuthAccessAccessItemFileGroup) {
    self.uid = Some(uid);
  }

  pub fn with_uid(mut self, uid: ::models::AuthAccessAccessItemFileGroup) -> AuthIdNtoken {
    self.uid = Some(uid);
    self
  }

  pub fn uid(&self) -> Option<&::models::AuthAccessAccessItemFileGroup> {
    self.uid.as_ref()
  }

  pub fn reset_uid(&mut self) {
    self.uid = None;
  }

  pub fn set_user_sid(&mut self, user_sid: ::models::AuthAccessAccessItemFileGroup) {
    self.user_sid = Some(user_sid);
  }

  pub fn with_user_sid(mut self, user_sid: ::models::AuthAccessAccessItemFileGroup) -> AuthIdNtoken {
    self.user_sid = Some(user_sid);
    self
  }

  pub fn user_sid(&self) -> Option<&::models::AuthAccessAccessItemFileGroup> {
    self.user_sid.as_ref()
  }

  pub fn reset_user_sid(&mut self) {
    self.user_sid = None;
  }

  pub fn set_zid(&mut self, zid: i32) {
    self.zid = Some(zid);
  }

  pub fn with_zid(mut self, zid: i32) -> AuthIdNtoken {
    self.zid = Some(zid);
    self
  }

  pub fn zid(&self) -> Option<&i32> {
    self.zid.as_ref()
  }

  pub fn reset_zid(&mut self) {
    self.zid = None;
  }

  pub fn set_zone_id(&mut self, zone_id: String) {
    self.zone_id = Some(zone_id);
  }

  pub fn with_zone_id(mut self, zone_id: String) -> AuthIdNtoken {
    self.zone_id = Some(zone_id);
    self
  }

  pub fn zone_id(&self) -> Option<&String> {
    self.zone_id.as_ref()
  }

  pub fn reset_zone_id(&mut self) {
    self.zone_id = None;
  }

}



