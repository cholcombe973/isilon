/* 
 * Isilon SDK
 *
 * Isilon SDK - Language bindings for the OneFS API
 *
 * OpenAPI spec version: 5
 * Contact: sdk@isilon.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */


#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct FsaSettingsSettings {
  /// Name of question template to use for new FSA jobs.
  #[serde(rename = "default_template")]
  default_template: Option<String>,
  /// Maximum directory depth used for disk_usage question if not specified in the question.
  #[serde(rename = "disk_usage_depth")]
  disk_usage_depth: Option<i32>,
  /// Maximum age of non-pinned results in seconds.
  #[serde(rename = "max_age")]
  max_age: Option<i32>,
  /// Maximum number of non-pinned result sets to keep.
  #[serde(rename = "max_count")]
  max_count: Option<i32>,
  /// Squash depth to use for squash binning questions if not specified in the question.
  #[serde(rename = "squash_depth")]
  squash_depth: Option<i32>,
  /// Maximum number of items in a Top-N question result if not specified in the question.
  #[serde(rename = "top_n_max")]
  top_n_max: Option<i32>,
  /// If true, use a snapshot for consistency, otherwise analyze head.
  #[serde(rename = "use_snapshot")]
  use_snapshot: Option<bool>
}

impl FsaSettingsSettings {
  pub fn new() -> FsaSettingsSettings {
    FsaSettingsSettings {
      default_template: None,
      disk_usage_depth: None,
      max_age: None,
      max_count: None,
      squash_depth: None,
      top_n_max: None,
      use_snapshot: None
    }
  }

  pub fn set_default_template(&mut self, default_template: String) {
    self.default_template = Some(default_template);
  }

  pub fn with_default_template(mut self, default_template: String) -> FsaSettingsSettings {
    self.default_template = Some(default_template);
    self
  }

  pub fn default_template(&self) -> Option<&String> {
    self.default_template.as_ref()
  }

  pub fn reset_default_template(&mut self) {
    self.default_template = None;
  }

  pub fn set_disk_usage_depth(&mut self, disk_usage_depth: i32) {
    self.disk_usage_depth = Some(disk_usage_depth);
  }

  pub fn with_disk_usage_depth(mut self, disk_usage_depth: i32) -> FsaSettingsSettings {
    self.disk_usage_depth = Some(disk_usage_depth);
    self
  }

  pub fn disk_usage_depth(&self) -> Option<&i32> {
    self.disk_usage_depth.as_ref()
  }

  pub fn reset_disk_usage_depth(&mut self) {
    self.disk_usage_depth = None;
  }

  pub fn set_max_age(&mut self, max_age: i32) {
    self.max_age = Some(max_age);
  }

  pub fn with_max_age(mut self, max_age: i32) -> FsaSettingsSettings {
    self.max_age = Some(max_age);
    self
  }

  pub fn max_age(&self) -> Option<&i32> {
    self.max_age.as_ref()
  }

  pub fn reset_max_age(&mut self) {
    self.max_age = None;
  }

  pub fn set_max_count(&mut self, max_count: i32) {
    self.max_count = Some(max_count);
  }

  pub fn with_max_count(mut self, max_count: i32) -> FsaSettingsSettings {
    self.max_count = Some(max_count);
    self
  }

  pub fn max_count(&self) -> Option<&i32> {
    self.max_count.as_ref()
  }

  pub fn reset_max_count(&mut self) {
    self.max_count = None;
  }

  pub fn set_squash_depth(&mut self, squash_depth: i32) {
    self.squash_depth = Some(squash_depth);
  }

  pub fn with_squash_depth(mut self, squash_depth: i32) -> FsaSettingsSettings {
    self.squash_depth = Some(squash_depth);
    self
  }

  pub fn squash_depth(&self) -> Option<&i32> {
    self.squash_depth.as_ref()
  }

  pub fn reset_squash_depth(&mut self) {
    self.squash_depth = None;
  }

  pub fn set_top_n_max(&mut self, top_n_max: i32) {
    self.top_n_max = Some(top_n_max);
  }

  pub fn with_top_n_max(mut self, top_n_max: i32) -> FsaSettingsSettings {
    self.top_n_max = Some(top_n_max);
    self
  }

  pub fn top_n_max(&self) -> Option<&i32> {
    self.top_n_max.as_ref()
  }

  pub fn reset_top_n_max(&mut self) {
    self.top_n_max = None;
  }

  pub fn set_use_snapshot(&mut self, use_snapshot: bool) {
    self.use_snapshot = Some(use_snapshot);
  }

  pub fn with_use_snapshot(mut self, use_snapshot: bool) -> FsaSettingsSettings {
    self.use_snapshot = Some(use_snapshot);
    self
  }

  pub fn use_snapshot(&self) -> Option<&bool> {
    self.use_snapshot.as_ref()
  }

  pub fn reset_use_snapshot(&mut self) {
    self.use_snapshot = None;
  }

}



