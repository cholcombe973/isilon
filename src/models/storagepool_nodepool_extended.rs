/* 
 * Isilon SDK
 *
 * Isilon SDK - Language bindings for the OneFS API
 *
 * OpenAPI spec version: 5
 * Contact: sdk@isilon.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */


#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct StoragepoolNodepoolExtended {
  /// Indicates if enabling L3 is possible. L3 cannot be enabled if there are unprovisioned drives.
  #[serde(rename = "can_enable_l3")]
  can_enable_l3: bool,
  /// An array of containing any health issues with this pool.  If the pool is healthy, the list is empty.
  #[serde(rename = "health_flags")]
  health_flags: Option<Vec<String>>,
  /// The system ID given to the node pool.
  #[serde(rename = "id")]
  id: i32,
  /// Use SSDs in this node pool for L3 cache.
  #[serde(rename = "l3")]
  l3: bool,
  /// 'storage' if the 'l3' option is disabled. If the l3 option is enabled, 'migrating' if any SSDs in this node pool have not yet been migrated to L3. If all SSDs have been migrated, 'l3'.
  #[serde(rename = "l3_status")]
  l3_status: String,
  /// The nodes that are part of this node pool.
  #[serde(rename = "lnns")]
  lnns: Vec<i32>,
  /// Whether or not the node pool is manually managed.
  #[serde(rename = "manual")]
  manual: bool,
  /// The node pool name.
  #[serde(rename = "name")]
  name: String,
  /// The underlying protection policy.
  #[serde(rename = "protection_policy")]
  protection_policy: Option<String>,
  /// The name (if named) or system ID of the node pool's tier, if it is in a tier. Otherwise null.
  #[serde(rename = "tier")]
  tier: Option<String>,
  /// Total pool usage.
  #[serde(rename = "usage")]
  usage: ::models::StoragepoolTierUsage
}

impl StoragepoolNodepoolExtended {
  pub fn new(can_enable_l3: bool, id: i32, l3: bool, l3_status: String, lnns: Vec<i32>, manual: bool, name: String, usage: ::models::StoragepoolTierUsage) -> StoragepoolNodepoolExtended {
    StoragepoolNodepoolExtended {
      can_enable_l3: can_enable_l3,
      health_flags: None,
      id: id,
      l3: l3,
      l3_status: l3_status,
      lnns: lnns,
      manual: manual,
      name: name,
      protection_policy: None,
      tier: None,
      usage: usage
    }
  }

  pub fn set_can_enable_l3(&mut self, can_enable_l3: bool) {
    self.can_enable_l3 = can_enable_l3;
  }

  pub fn with_can_enable_l3(mut self, can_enable_l3: bool) -> StoragepoolNodepoolExtended {
    self.can_enable_l3 = can_enable_l3;
    self
  }

  pub fn can_enable_l3(&self) -> &bool {
    &self.can_enable_l3
  }


  pub fn set_health_flags(&mut self, health_flags: Vec<String>) {
    self.health_flags = Some(health_flags);
  }

  pub fn with_health_flags(mut self, health_flags: Vec<String>) -> StoragepoolNodepoolExtended {
    self.health_flags = Some(health_flags);
    self
  }

  pub fn health_flags(&self) -> Option<&Vec<String>> {
    self.health_flags.as_ref()
  }

  pub fn reset_health_flags(&mut self) {
    self.health_flags = None;
  }

  pub fn set_id(&mut self, id: i32) {
    self.id = id;
  }

  pub fn with_id(mut self, id: i32) -> StoragepoolNodepoolExtended {
    self.id = id;
    self
  }

  pub fn id(&self) -> &i32 {
    &self.id
  }


  pub fn set_l3(&mut self, l3: bool) {
    self.l3 = l3;
  }

  pub fn with_l3(mut self, l3: bool) -> StoragepoolNodepoolExtended {
    self.l3 = l3;
    self
  }

  pub fn l3(&self) -> &bool {
    &self.l3
  }


  pub fn set_l3_status(&mut self, l3_status: String) {
    self.l3_status = l3_status;
  }

  pub fn with_l3_status(mut self, l3_status: String) -> StoragepoolNodepoolExtended {
    self.l3_status = l3_status;
    self
  }

  pub fn l3_status(&self) -> &String {
    &self.l3_status
  }


  pub fn set_lnns(&mut self, lnns: Vec<i32>) {
    self.lnns = lnns;
  }

  pub fn with_lnns(mut self, lnns: Vec<i32>) -> StoragepoolNodepoolExtended {
    self.lnns = lnns;
    self
  }

  pub fn lnns(&self) -> &Vec<i32> {
    &self.lnns
  }


  pub fn set_manual(&mut self, manual: bool) {
    self.manual = manual;
  }

  pub fn with_manual(mut self, manual: bool) -> StoragepoolNodepoolExtended {
    self.manual = manual;
    self
  }

  pub fn manual(&self) -> &bool {
    &self.manual
  }


  pub fn set_name(&mut self, name: String) {
    self.name = name;
  }

  pub fn with_name(mut self, name: String) -> StoragepoolNodepoolExtended {
    self.name = name;
    self
  }

  pub fn name(&self) -> &String {
    &self.name
  }


  pub fn set_protection_policy(&mut self, protection_policy: String) {
    self.protection_policy = Some(protection_policy);
  }

  pub fn with_protection_policy(mut self, protection_policy: String) -> StoragepoolNodepoolExtended {
    self.protection_policy = Some(protection_policy);
    self
  }

  pub fn protection_policy(&self) -> Option<&String> {
    self.protection_policy.as_ref()
  }

  pub fn reset_protection_policy(&mut self) {
    self.protection_policy = None;
  }

  pub fn set_tier(&mut self, tier: String) {
    self.tier = Some(tier);
  }

  pub fn with_tier(mut self, tier: String) -> StoragepoolNodepoolExtended {
    self.tier = Some(tier);
    self
  }

  pub fn tier(&self) -> Option<&String> {
    self.tier.as_ref()
  }

  pub fn reset_tier(&mut self) {
    self.tier = None;
  }

  pub fn set_usage(&mut self, usage: ::models::StoragepoolTierUsage) {
    self.usage = usage;
  }

  pub fn with_usage(mut self, usage: ::models::StoragepoolTierUsage) -> StoragepoolNodepoolExtended {
    self.usage = usage;
    self
  }

  pub fn usage(&self) -> &::models::StoragepoolTierUsage {
    &self.usage
  }


}



