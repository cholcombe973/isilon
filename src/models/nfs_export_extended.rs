/* 
 * Isilon SDK
 *
 * Isilon SDK - Language bindings for the OneFS API
 *
 * OpenAPI spec version: 5
 * Contact: sdk@isilon.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */


#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct NfsExportExtended {
  /// True if all directories under the specified paths are mountable.
  #[serde(rename = "all_dirs")]
  all_dirs: Option<bool>,
  /// Specifies the block size returned by the NFS statfs procedure.
  #[serde(rename = "block_size")]
  block_size: Option<i32>,
  /// True if the client can set file times through the NFS set attribute request. This parameter does not affect server behavior, but is included to accommoate legacy client requirements.
  #[serde(rename = "can_set_time")]
  can_set_time: Option<bool>,
  /// True if the case is ignored for file names. This parameter does not affect server behavior, but is included to accommodate legacy client requirements.
  #[serde(rename = "case_insensitive")]
  case_insensitive: Option<bool>,
  /// True if the case is preserved for file names. This parameter does not affect server behavior, but is included to accommodate legacy client requirements.
  #[serde(rename = "case_preserving")]
  case_preserving: Option<bool>,
  /// True if the superuser can change file ownership. This parameter does not affect server behavior, but is included to accommodate legacy client requirements.
  #[serde(rename = "chown_restricted")]
  chown_restricted: Option<bool>,
  /// Specifies the clients with root access to the export.
  #[serde(rename = "clients")]
  clients: Option<Vec<String>>,
  /// True if NFS  commit  requests execute asynchronously.
  #[serde(rename = "commit_asynchronous")]
  commit_asynchronous: Option<bool>,
  /// Specifies the user-defined string that is used to identify the export.
  #[serde(rename = "description")]
  description: Option<String>,
  /// Specifies the preferred size for directory read operations. This value is used to advise the client of optimal settings for the server, but is not enforced.
  #[serde(rename = "directory_transfer_size")]
  directory_transfer_size: Option<i32>,
  /// Specifies the default character set encoding of the clients connecting to the export, unless otherwise specified.
  #[serde(rename = "encoding")]
  encoding: Option<String>,
  /// Specifies the reported maximum number of links to a file. This parameter does not affect server behavior, but is included to accommodate legacy client requirements.
  #[serde(rename = "link_max")]
  link_max: Option<i32>,
  /// User and group mapping.
  #[serde(rename = "map_all")]
  map_all: Option<::models::NfsSettingsExportSettingsMapAll>,
  /// User and group mapping.
  #[serde(rename = "map_failure")]
  map_failure: Option<::models::NfsSettingsExportSettingsMapAll>,
  /// True if user mappings query the OneFS user database. When set to false, user mappings only query local authentication.
  #[serde(rename = "map_full")]
  map_full: Option<bool>,
  /// True if incoming user IDs (UIDs) are mapped to users in the OneFS user database. When set to false, incoming UIDs are applied directly to file operations.
  #[serde(rename = "map_lookup_uid")]
  map_lookup_uid: Option<bool>,
  /// User and group mapping.
  #[serde(rename = "map_non_root")]
  map_non_root: Option<::models::NfsSettingsExportSettingsMapAll>,
  /// Determines whether searches for users specified in 'map_all', 'map_root' or 'map_nonroot' are retried if the search fails.
  #[serde(rename = "map_retry")]
  map_retry: Option<bool>,
  /// User and group mapping.
  #[serde(rename = "map_root")]
  map_root: Option<::models::NfsSettingsExportSettingsMapAll>,
  /// Specifies the maximum file size for any file accessed from the export. This parameter does not affect server behavior, but is included to accommodate legacy client requirements.
  #[serde(rename = "max_file_size")]
  max_file_size: Option<i32>,
  /// Specifies the reported maximum length of a file name. This parameter does not affect server behavior, but is included to accommodate legacy client requirements.
  #[serde(rename = "name_max_size")]
  name_max_size: Option<i32>,
  /// True if long file names result in an error. This parameter does not affect server behavior, but is included to accommodate legacy client requirements.
  #[serde(rename = "no_truncate")]
  no_truncate: Option<bool>,
  /// Specifies the paths under /ifs that are exported.
  #[serde(rename = "paths")]
  paths: Option<Vec<String>>,
  /// True if the export is set to read-only.
  #[serde(rename = "read_only")]
  read_only: Option<bool>,
  /// Specifies the clients with read-only access to the export.
  #[serde(rename = "read_only_clients")]
  read_only_clients: Option<Vec<String>>,
  /// Specifies the maximum buffer size that clients should use on NFS read requests. This value is used to advise the client of optimal settings for the server, but is not enforced.
  #[serde(rename = "read_transfer_max_size")]
  read_transfer_max_size: Option<i32>,
  /// Specifies the preferred multiple size for NFS read requests. This value is used to advise the client of optimal settings for the server, but is not enforced.
  #[serde(rename = "read_transfer_multiple")]
  read_transfer_multiple: Option<i32>,
  /// Specifies the preferred size for NFS read requests. This value is used to advise the client of optimal settings for the server, but is not enforced.
  #[serde(rename = "read_transfer_size")]
  read_transfer_size: Option<i32>,
  /// Specifies the clients with both read and write access to the export, even when the export is set to read-only.
  #[serde(rename = "read_write_clients")]
  read_write_clients: Option<Vec<String>>,
  /// True if 'readdirplus' requests are enabled. Enabling this property might improve network performance and is only available for NFSv3.
  #[serde(rename = "readdirplus")]
  readdirplus: Option<bool>,
  /// Sets the number of directory entries that are prefetched when a 'readdirplus' request is processed. (Deprecated.)
  #[serde(rename = "readdirplus_prefetch")]
  readdirplus_prefetch: Option<i32>,
  /// Limits the size of file identifiers returned by NFSv3+ to 32-bit values (may require remount).
  #[serde(rename = "return_32bit_file_ids")]
  return_32bit_file_ids: Option<bool>,
  /// Clients that have root access to the export.
  #[serde(rename = "root_clients")]
  root_clients: Option<Vec<String>>,
  /// Specifies the authentication types that are supported for this export.
  #[serde(rename = "security_flavors")]
  security_flavors: Option<Vec<String>>,
  /// True if set attribute operations execute asynchronously.
  #[serde(rename = "setattr_asynchronous")]
  setattr_asynchronous: Option<bool>,
  /// Specifies the snapshot for all mounts.
  #[serde(rename = "snapshot")]
  snapshot: Option<String>,
  /// True if symlinks are supported. This value is used to advise the client of optimal settings for the server, but is not enforced.
  #[serde(rename = "symlinks")]
  symlinks: Option<bool>,
  /// Specifies the resolution of all time values that are returned to the clients
  #[serde(rename = "time_delta")]
  time_delta: Option<f32>,
  /// Specifies the synchronization type.
  #[serde(rename = "write_datasync_action")]
  write_datasync_action: Option<String>,
  /// Specifies the synchronization type.
  #[serde(rename = "write_datasync_reply")]
  write_datasync_reply: Option<String>,
  /// Specifies the synchronization type.
  #[serde(rename = "write_filesync_action")]
  write_filesync_action: Option<String>,
  /// Specifies the synchronization type.
  #[serde(rename = "write_filesync_reply")]
  write_filesync_reply: Option<String>,
  /// Specifies the maximum buffer size that clients should use on NFS write requests. This value is used to advise the client of optimal settings for the server, but is not enforced.
  #[serde(rename = "write_transfer_max_size")]
  write_transfer_max_size: Option<i32>,
  /// Specifies the preferred multiple size for NFS write requests. This value is used to advise the client of optimal settings for the server, but is not enforced.
  #[serde(rename = "write_transfer_multiple")]
  write_transfer_multiple: Option<i32>,
  /// Specifies the preferred multiple size for NFS write requests. This value is used to advise the client of optimal settings for the server, but is not enforced.
  #[serde(rename = "write_transfer_size")]
  write_transfer_size: Option<i32>,
  /// Specifies the synchronization type.
  #[serde(rename = "write_unstable_action")]
  write_unstable_action: Option<String>,
  /// Specifies the synchronization type.
  #[serde(rename = "write_unstable_reply")]
  write_unstable_reply: Option<String>,
  /// Specifies the zone in which the export is valid.
  #[serde(rename = "zone")]
  zone: Option<String>,
  /// Reports the paths that conflict with another export.
  #[serde(rename = "conflicting_paths")]
  conflicting_paths: Option<Vec<String>>,
  /// Specifies the system-assigned ID for the export. This ID is returned when an export is created through the POST method.
  #[serde(rename = "id")]
  id: Option<i32>,
  /// Reports clients that cannot be resolved.
  #[serde(rename = "unresolved_clients")]
  unresolved_clients: Option<Vec<String>>
}

impl NfsExportExtended {
  pub fn new() -> NfsExportExtended {
    NfsExportExtended {
      all_dirs: None,
      block_size: None,
      can_set_time: None,
      case_insensitive: None,
      case_preserving: None,
      chown_restricted: None,
      clients: None,
      commit_asynchronous: None,
      description: None,
      directory_transfer_size: None,
      encoding: None,
      link_max: None,
      map_all: None,
      map_failure: None,
      map_full: None,
      map_lookup_uid: None,
      map_non_root: None,
      map_retry: None,
      map_root: None,
      max_file_size: None,
      name_max_size: None,
      no_truncate: None,
      paths: None,
      read_only: None,
      read_only_clients: None,
      read_transfer_max_size: None,
      read_transfer_multiple: None,
      read_transfer_size: None,
      read_write_clients: None,
      readdirplus: None,
      readdirplus_prefetch: None,
      return_32bit_file_ids: None,
      root_clients: None,
      security_flavors: None,
      setattr_asynchronous: None,
      snapshot: None,
      symlinks: None,
      time_delta: None,
      write_datasync_action: None,
      write_datasync_reply: None,
      write_filesync_action: None,
      write_filesync_reply: None,
      write_transfer_max_size: None,
      write_transfer_multiple: None,
      write_transfer_size: None,
      write_unstable_action: None,
      write_unstable_reply: None,
      zone: None,
      conflicting_paths: None,
      id: None,
      unresolved_clients: None
    }
  }

  pub fn set_all_dirs(&mut self, all_dirs: bool) {
    self.all_dirs = Some(all_dirs);
  }

  pub fn with_all_dirs(mut self, all_dirs: bool) -> NfsExportExtended {
    self.all_dirs = Some(all_dirs);
    self
  }

  pub fn all_dirs(&self) -> Option<&bool> {
    self.all_dirs.as_ref()
  }

  pub fn reset_all_dirs(&mut self) {
    self.all_dirs = None;
  }

  pub fn set_block_size(&mut self, block_size: i32) {
    self.block_size = Some(block_size);
  }

  pub fn with_block_size(mut self, block_size: i32) -> NfsExportExtended {
    self.block_size = Some(block_size);
    self
  }

  pub fn block_size(&self) -> Option<&i32> {
    self.block_size.as_ref()
  }

  pub fn reset_block_size(&mut self) {
    self.block_size = None;
  }

  pub fn set_can_set_time(&mut self, can_set_time: bool) {
    self.can_set_time = Some(can_set_time);
  }

  pub fn with_can_set_time(mut self, can_set_time: bool) -> NfsExportExtended {
    self.can_set_time = Some(can_set_time);
    self
  }

  pub fn can_set_time(&self) -> Option<&bool> {
    self.can_set_time.as_ref()
  }

  pub fn reset_can_set_time(&mut self) {
    self.can_set_time = None;
  }

  pub fn set_case_insensitive(&mut self, case_insensitive: bool) {
    self.case_insensitive = Some(case_insensitive);
  }

  pub fn with_case_insensitive(mut self, case_insensitive: bool) -> NfsExportExtended {
    self.case_insensitive = Some(case_insensitive);
    self
  }

  pub fn case_insensitive(&self) -> Option<&bool> {
    self.case_insensitive.as_ref()
  }

  pub fn reset_case_insensitive(&mut self) {
    self.case_insensitive = None;
  }

  pub fn set_case_preserving(&mut self, case_preserving: bool) {
    self.case_preserving = Some(case_preserving);
  }

  pub fn with_case_preserving(mut self, case_preserving: bool) -> NfsExportExtended {
    self.case_preserving = Some(case_preserving);
    self
  }

  pub fn case_preserving(&self) -> Option<&bool> {
    self.case_preserving.as_ref()
  }

  pub fn reset_case_preserving(&mut self) {
    self.case_preserving = None;
  }

  pub fn set_chown_restricted(&mut self, chown_restricted: bool) {
    self.chown_restricted = Some(chown_restricted);
  }

  pub fn with_chown_restricted(mut self, chown_restricted: bool) -> NfsExportExtended {
    self.chown_restricted = Some(chown_restricted);
    self
  }

  pub fn chown_restricted(&self) -> Option<&bool> {
    self.chown_restricted.as_ref()
  }

  pub fn reset_chown_restricted(&mut self) {
    self.chown_restricted = None;
  }

  pub fn set_clients(&mut self, clients: Vec<String>) {
    self.clients = Some(clients);
  }

  pub fn with_clients(mut self, clients: Vec<String>) -> NfsExportExtended {
    self.clients = Some(clients);
    self
  }

  pub fn clients(&self) -> Option<&Vec<String>> {
    self.clients.as_ref()
  }

  pub fn reset_clients(&mut self) {
    self.clients = None;
  }

  pub fn set_commit_asynchronous(&mut self, commit_asynchronous: bool) {
    self.commit_asynchronous = Some(commit_asynchronous);
  }

  pub fn with_commit_asynchronous(mut self, commit_asynchronous: bool) -> NfsExportExtended {
    self.commit_asynchronous = Some(commit_asynchronous);
    self
  }

  pub fn commit_asynchronous(&self) -> Option<&bool> {
    self.commit_asynchronous.as_ref()
  }

  pub fn reset_commit_asynchronous(&mut self) {
    self.commit_asynchronous = None;
  }

  pub fn set_description(&mut self, description: String) {
    self.description = Some(description);
  }

  pub fn with_description(mut self, description: String) -> NfsExportExtended {
    self.description = Some(description);
    self
  }

  pub fn description(&self) -> Option<&String> {
    self.description.as_ref()
  }

  pub fn reset_description(&mut self) {
    self.description = None;
  }

  pub fn set_directory_transfer_size(&mut self, directory_transfer_size: i32) {
    self.directory_transfer_size = Some(directory_transfer_size);
  }

  pub fn with_directory_transfer_size(mut self, directory_transfer_size: i32) -> NfsExportExtended {
    self.directory_transfer_size = Some(directory_transfer_size);
    self
  }

  pub fn directory_transfer_size(&self) -> Option<&i32> {
    self.directory_transfer_size.as_ref()
  }

  pub fn reset_directory_transfer_size(&mut self) {
    self.directory_transfer_size = None;
  }

  pub fn set_encoding(&mut self, encoding: String) {
    self.encoding = Some(encoding);
  }

  pub fn with_encoding(mut self, encoding: String) -> NfsExportExtended {
    self.encoding = Some(encoding);
    self
  }

  pub fn encoding(&self) -> Option<&String> {
    self.encoding.as_ref()
  }

  pub fn reset_encoding(&mut self) {
    self.encoding = None;
  }

  pub fn set_link_max(&mut self, link_max: i32) {
    self.link_max = Some(link_max);
  }

  pub fn with_link_max(mut self, link_max: i32) -> NfsExportExtended {
    self.link_max = Some(link_max);
    self
  }

  pub fn link_max(&self) -> Option<&i32> {
    self.link_max.as_ref()
  }

  pub fn reset_link_max(&mut self) {
    self.link_max = None;
  }

  pub fn set_map_all(&mut self, map_all: ::models::NfsSettingsExportSettingsMapAll) {
    self.map_all = Some(map_all);
  }

  pub fn with_map_all(mut self, map_all: ::models::NfsSettingsExportSettingsMapAll) -> NfsExportExtended {
    self.map_all = Some(map_all);
    self
  }

  pub fn map_all(&self) -> Option<&::models::NfsSettingsExportSettingsMapAll> {
    self.map_all.as_ref()
  }

  pub fn reset_map_all(&mut self) {
    self.map_all = None;
  }

  pub fn set_map_failure(&mut self, map_failure: ::models::NfsSettingsExportSettingsMapAll) {
    self.map_failure = Some(map_failure);
  }

  pub fn with_map_failure(mut self, map_failure: ::models::NfsSettingsExportSettingsMapAll) -> NfsExportExtended {
    self.map_failure = Some(map_failure);
    self
  }

  pub fn map_failure(&self) -> Option<&::models::NfsSettingsExportSettingsMapAll> {
    self.map_failure.as_ref()
  }

  pub fn reset_map_failure(&mut self) {
    self.map_failure = None;
  }

  pub fn set_map_full(&mut self, map_full: bool) {
    self.map_full = Some(map_full);
  }

  pub fn with_map_full(mut self, map_full: bool) -> NfsExportExtended {
    self.map_full = Some(map_full);
    self
  }

  pub fn map_full(&self) -> Option<&bool> {
    self.map_full.as_ref()
  }

  pub fn reset_map_full(&mut self) {
    self.map_full = None;
  }

  pub fn set_map_lookup_uid(&mut self, map_lookup_uid: bool) {
    self.map_lookup_uid = Some(map_lookup_uid);
  }

  pub fn with_map_lookup_uid(mut self, map_lookup_uid: bool) -> NfsExportExtended {
    self.map_lookup_uid = Some(map_lookup_uid);
    self
  }

  pub fn map_lookup_uid(&self) -> Option<&bool> {
    self.map_lookup_uid.as_ref()
  }

  pub fn reset_map_lookup_uid(&mut self) {
    self.map_lookup_uid = None;
  }

  pub fn set_map_non_root(&mut self, map_non_root: ::models::NfsSettingsExportSettingsMapAll) {
    self.map_non_root = Some(map_non_root);
  }

  pub fn with_map_non_root(mut self, map_non_root: ::models::NfsSettingsExportSettingsMapAll) -> NfsExportExtended {
    self.map_non_root = Some(map_non_root);
    self
  }

  pub fn map_non_root(&self) -> Option<&::models::NfsSettingsExportSettingsMapAll> {
    self.map_non_root.as_ref()
  }

  pub fn reset_map_non_root(&mut self) {
    self.map_non_root = None;
  }

  pub fn set_map_retry(&mut self, map_retry: bool) {
    self.map_retry = Some(map_retry);
  }

  pub fn with_map_retry(mut self, map_retry: bool) -> NfsExportExtended {
    self.map_retry = Some(map_retry);
    self
  }

  pub fn map_retry(&self) -> Option<&bool> {
    self.map_retry.as_ref()
  }

  pub fn reset_map_retry(&mut self) {
    self.map_retry = None;
  }

  pub fn set_map_root(&mut self, map_root: ::models::NfsSettingsExportSettingsMapAll) {
    self.map_root = Some(map_root);
  }

  pub fn with_map_root(mut self, map_root: ::models::NfsSettingsExportSettingsMapAll) -> NfsExportExtended {
    self.map_root = Some(map_root);
    self
  }

  pub fn map_root(&self) -> Option<&::models::NfsSettingsExportSettingsMapAll> {
    self.map_root.as_ref()
  }

  pub fn reset_map_root(&mut self) {
    self.map_root = None;
  }

  pub fn set_max_file_size(&mut self, max_file_size: i32) {
    self.max_file_size = Some(max_file_size);
  }

  pub fn with_max_file_size(mut self, max_file_size: i32) -> NfsExportExtended {
    self.max_file_size = Some(max_file_size);
    self
  }

  pub fn max_file_size(&self) -> Option<&i32> {
    self.max_file_size.as_ref()
  }

  pub fn reset_max_file_size(&mut self) {
    self.max_file_size = None;
  }

  pub fn set_name_max_size(&mut self, name_max_size: i32) {
    self.name_max_size = Some(name_max_size);
  }

  pub fn with_name_max_size(mut self, name_max_size: i32) -> NfsExportExtended {
    self.name_max_size = Some(name_max_size);
    self
  }

  pub fn name_max_size(&self) -> Option<&i32> {
    self.name_max_size.as_ref()
  }

  pub fn reset_name_max_size(&mut self) {
    self.name_max_size = None;
  }

  pub fn set_no_truncate(&mut self, no_truncate: bool) {
    self.no_truncate = Some(no_truncate);
  }

  pub fn with_no_truncate(mut self, no_truncate: bool) -> NfsExportExtended {
    self.no_truncate = Some(no_truncate);
    self
  }

  pub fn no_truncate(&self) -> Option<&bool> {
    self.no_truncate.as_ref()
  }

  pub fn reset_no_truncate(&mut self) {
    self.no_truncate = None;
  }

  pub fn set_paths(&mut self, paths: Vec<String>) {
    self.paths = Some(paths);
  }

  pub fn with_paths(mut self, paths: Vec<String>) -> NfsExportExtended {
    self.paths = Some(paths);
    self
  }

  pub fn paths(&self) -> Option<&Vec<String>> {
    self.paths.as_ref()
  }

  pub fn reset_paths(&mut self) {
    self.paths = None;
  }

  pub fn set_read_only(&mut self, read_only: bool) {
    self.read_only = Some(read_only);
  }

  pub fn with_read_only(mut self, read_only: bool) -> NfsExportExtended {
    self.read_only = Some(read_only);
    self
  }

  pub fn read_only(&self) -> Option<&bool> {
    self.read_only.as_ref()
  }

  pub fn reset_read_only(&mut self) {
    self.read_only = None;
  }

  pub fn set_read_only_clients(&mut self, read_only_clients: Vec<String>) {
    self.read_only_clients = Some(read_only_clients);
  }

  pub fn with_read_only_clients(mut self, read_only_clients: Vec<String>) -> NfsExportExtended {
    self.read_only_clients = Some(read_only_clients);
    self
  }

  pub fn read_only_clients(&self) -> Option<&Vec<String>> {
    self.read_only_clients.as_ref()
  }

  pub fn reset_read_only_clients(&mut self) {
    self.read_only_clients = None;
  }

  pub fn set_read_transfer_max_size(&mut self, read_transfer_max_size: i32) {
    self.read_transfer_max_size = Some(read_transfer_max_size);
  }

  pub fn with_read_transfer_max_size(mut self, read_transfer_max_size: i32) -> NfsExportExtended {
    self.read_transfer_max_size = Some(read_transfer_max_size);
    self
  }

  pub fn read_transfer_max_size(&self) -> Option<&i32> {
    self.read_transfer_max_size.as_ref()
  }

  pub fn reset_read_transfer_max_size(&mut self) {
    self.read_transfer_max_size = None;
  }

  pub fn set_read_transfer_multiple(&mut self, read_transfer_multiple: i32) {
    self.read_transfer_multiple = Some(read_transfer_multiple);
  }

  pub fn with_read_transfer_multiple(mut self, read_transfer_multiple: i32) -> NfsExportExtended {
    self.read_transfer_multiple = Some(read_transfer_multiple);
    self
  }

  pub fn read_transfer_multiple(&self) -> Option<&i32> {
    self.read_transfer_multiple.as_ref()
  }

  pub fn reset_read_transfer_multiple(&mut self) {
    self.read_transfer_multiple = None;
  }

  pub fn set_read_transfer_size(&mut self, read_transfer_size: i32) {
    self.read_transfer_size = Some(read_transfer_size);
  }

  pub fn with_read_transfer_size(mut self, read_transfer_size: i32) -> NfsExportExtended {
    self.read_transfer_size = Some(read_transfer_size);
    self
  }

  pub fn read_transfer_size(&self) -> Option<&i32> {
    self.read_transfer_size.as_ref()
  }

  pub fn reset_read_transfer_size(&mut self) {
    self.read_transfer_size = None;
  }

  pub fn set_read_write_clients(&mut self, read_write_clients: Vec<String>) {
    self.read_write_clients = Some(read_write_clients);
  }

  pub fn with_read_write_clients(mut self, read_write_clients: Vec<String>) -> NfsExportExtended {
    self.read_write_clients = Some(read_write_clients);
    self
  }

  pub fn read_write_clients(&self) -> Option<&Vec<String>> {
    self.read_write_clients.as_ref()
  }

  pub fn reset_read_write_clients(&mut self) {
    self.read_write_clients = None;
  }

  pub fn set_readdirplus(&mut self, readdirplus: bool) {
    self.readdirplus = Some(readdirplus);
  }

  pub fn with_readdirplus(mut self, readdirplus: bool) -> NfsExportExtended {
    self.readdirplus = Some(readdirplus);
    self
  }

  pub fn readdirplus(&self) -> Option<&bool> {
    self.readdirplus.as_ref()
  }

  pub fn reset_readdirplus(&mut self) {
    self.readdirplus = None;
  }

  pub fn set_readdirplus_prefetch(&mut self, readdirplus_prefetch: i32) {
    self.readdirplus_prefetch = Some(readdirplus_prefetch);
  }

  pub fn with_readdirplus_prefetch(mut self, readdirplus_prefetch: i32) -> NfsExportExtended {
    self.readdirplus_prefetch = Some(readdirplus_prefetch);
    self
  }

  pub fn readdirplus_prefetch(&self) -> Option<&i32> {
    self.readdirplus_prefetch.as_ref()
  }

  pub fn reset_readdirplus_prefetch(&mut self) {
    self.readdirplus_prefetch = None;
  }

  pub fn set_return_32bit_file_ids(&mut self, return_32bit_file_ids: bool) {
    self.return_32bit_file_ids = Some(return_32bit_file_ids);
  }

  pub fn with_return_32bit_file_ids(mut self, return_32bit_file_ids: bool) -> NfsExportExtended {
    self.return_32bit_file_ids = Some(return_32bit_file_ids);
    self
  }

  pub fn return_32bit_file_ids(&self) -> Option<&bool> {
    self.return_32bit_file_ids.as_ref()
  }

  pub fn reset_return_32bit_file_ids(&mut self) {
    self.return_32bit_file_ids = None;
  }

  pub fn set_root_clients(&mut self, root_clients: Vec<String>) {
    self.root_clients = Some(root_clients);
  }

  pub fn with_root_clients(mut self, root_clients: Vec<String>) -> NfsExportExtended {
    self.root_clients = Some(root_clients);
    self
  }

  pub fn root_clients(&self) -> Option<&Vec<String>> {
    self.root_clients.as_ref()
  }

  pub fn reset_root_clients(&mut self) {
    self.root_clients = None;
  }

  pub fn set_security_flavors(&mut self, security_flavors: Vec<String>) {
    self.security_flavors = Some(security_flavors);
  }

  pub fn with_security_flavors(mut self, security_flavors: Vec<String>) -> NfsExportExtended {
    self.security_flavors = Some(security_flavors);
    self
  }

  pub fn security_flavors(&self) -> Option<&Vec<String>> {
    self.security_flavors.as_ref()
  }

  pub fn reset_security_flavors(&mut self) {
    self.security_flavors = None;
  }

  pub fn set_setattr_asynchronous(&mut self, setattr_asynchronous: bool) {
    self.setattr_asynchronous = Some(setattr_asynchronous);
  }

  pub fn with_setattr_asynchronous(mut self, setattr_asynchronous: bool) -> NfsExportExtended {
    self.setattr_asynchronous = Some(setattr_asynchronous);
    self
  }

  pub fn setattr_asynchronous(&self) -> Option<&bool> {
    self.setattr_asynchronous.as_ref()
  }

  pub fn reset_setattr_asynchronous(&mut self) {
    self.setattr_asynchronous = None;
  }

  pub fn set_snapshot(&mut self, snapshot: String) {
    self.snapshot = Some(snapshot);
  }

  pub fn with_snapshot(mut self, snapshot: String) -> NfsExportExtended {
    self.snapshot = Some(snapshot);
    self
  }

  pub fn snapshot(&self) -> Option<&String> {
    self.snapshot.as_ref()
  }

  pub fn reset_snapshot(&mut self) {
    self.snapshot = None;
  }

  pub fn set_symlinks(&mut self, symlinks: bool) {
    self.symlinks = Some(symlinks);
  }

  pub fn with_symlinks(mut self, symlinks: bool) -> NfsExportExtended {
    self.symlinks = Some(symlinks);
    self
  }

  pub fn symlinks(&self) -> Option<&bool> {
    self.symlinks.as_ref()
  }

  pub fn reset_symlinks(&mut self) {
    self.symlinks = None;
  }

  pub fn set_time_delta(&mut self, time_delta: f32) {
    self.time_delta = Some(time_delta);
  }

  pub fn with_time_delta(mut self, time_delta: f32) -> NfsExportExtended {
    self.time_delta = Some(time_delta);
    self
  }

  pub fn time_delta(&self) -> Option<&f32> {
    self.time_delta.as_ref()
  }

  pub fn reset_time_delta(&mut self) {
    self.time_delta = None;
  }

  pub fn set_write_datasync_action(&mut self, write_datasync_action: String) {
    self.write_datasync_action = Some(write_datasync_action);
  }

  pub fn with_write_datasync_action(mut self, write_datasync_action: String) -> NfsExportExtended {
    self.write_datasync_action = Some(write_datasync_action);
    self
  }

  pub fn write_datasync_action(&self) -> Option<&String> {
    self.write_datasync_action.as_ref()
  }

  pub fn reset_write_datasync_action(&mut self) {
    self.write_datasync_action = None;
  }

  pub fn set_write_datasync_reply(&mut self, write_datasync_reply: String) {
    self.write_datasync_reply = Some(write_datasync_reply);
  }

  pub fn with_write_datasync_reply(mut self, write_datasync_reply: String) -> NfsExportExtended {
    self.write_datasync_reply = Some(write_datasync_reply);
    self
  }

  pub fn write_datasync_reply(&self) -> Option<&String> {
    self.write_datasync_reply.as_ref()
  }

  pub fn reset_write_datasync_reply(&mut self) {
    self.write_datasync_reply = None;
  }

  pub fn set_write_filesync_action(&mut self, write_filesync_action: String) {
    self.write_filesync_action = Some(write_filesync_action);
  }

  pub fn with_write_filesync_action(mut self, write_filesync_action: String) -> NfsExportExtended {
    self.write_filesync_action = Some(write_filesync_action);
    self
  }

  pub fn write_filesync_action(&self) -> Option<&String> {
    self.write_filesync_action.as_ref()
  }

  pub fn reset_write_filesync_action(&mut self) {
    self.write_filesync_action = None;
  }

  pub fn set_write_filesync_reply(&mut self, write_filesync_reply: String) {
    self.write_filesync_reply = Some(write_filesync_reply);
  }

  pub fn with_write_filesync_reply(mut self, write_filesync_reply: String) -> NfsExportExtended {
    self.write_filesync_reply = Some(write_filesync_reply);
    self
  }

  pub fn write_filesync_reply(&self) -> Option<&String> {
    self.write_filesync_reply.as_ref()
  }

  pub fn reset_write_filesync_reply(&mut self) {
    self.write_filesync_reply = None;
  }

  pub fn set_write_transfer_max_size(&mut self, write_transfer_max_size: i32) {
    self.write_transfer_max_size = Some(write_transfer_max_size);
  }

  pub fn with_write_transfer_max_size(mut self, write_transfer_max_size: i32) -> NfsExportExtended {
    self.write_transfer_max_size = Some(write_transfer_max_size);
    self
  }

  pub fn write_transfer_max_size(&self) -> Option<&i32> {
    self.write_transfer_max_size.as_ref()
  }

  pub fn reset_write_transfer_max_size(&mut self) {
    self.write_transfer_max_size = None;
  }

  pub fn set_write_transfer_multiple(&mut self, write_transfer_multiple: i32) {
    self.write_transfer_multiple = Some(write_transfer_multiple);
  }

  pub fn with_write_transfer_multiple(mut self, write_transfer_multiple: i32) -> NfsExportExtended {
    self.write_transfer_multiple = Some(write_transfer_multiple);
    self
  }

  pub fn write_transfer_multiple(&self) -> Option<&i32> {
    self.write_transfer_multiple.as_ref()
  }

  pub fn reset_write_transfer_multiple(&mut self) {
    self.write_transfer_multiple = None;
  }

  pub fn set_write_transfer_size(&mut self, write_transfer_size: i32) {
    self.write_transfer_size = Some(write_transfer_size);
  }

  pub fn with_write_transfer_size(mut self, write_transfer_size: i32) -> NfsExportExtended {
    self.write_transfer_size = Some(write_transfer_size);
    self
  }

  pub fn write_transfer_size(&self) -> Option<&i32> {
    self.write_transfer_size.as_ref()
  }

  pub fn reset_write_transfer_size(&mut self) {
    self.write_transfer_size = None;
  }

  pub fn set_write_unstable_action(&mut self, write_unstable_action: String) {
    self.write_unstable_action = Some(write_unstable_action);
  }

  pub fn with_write_unstable_action(mut self, write_unstable_action: String) -> NfsExportExtended {
    self.write_unstable_action = Some(write_unstable_action);
    self
  }

  pub fn write_unstable_action(&self) -> Option<&String> {
    self.write_unstable_action.as_ref()
  }

  pub fn reset_write_unstable_action(&mut self) {
    self.write_unstable_action = None;
  }

  pub fn set_write_unstable_reply(&mut self, write_unstable_reply: String) {
    self.write_unstable_reply = Some(write_unstable_reply);
  }

  pub fn with_write_unstable_reply(mut self, write_unstable_reply: String) -> NfsExportExtended {
    self.write_unstable_reply = Some(write_unstable_reply);
    self
  }

  pub fn write_unstable_reply(&self) -> Option<&String> {
    self.write_unstable_reply.as_ref()
  }

  pub fn reset_write_unstable_reply(&mut self) {
    self.write_unstable_reply = None;
  }

  pub fn set_zone(&mut self, zone: String) {
    self.zone = Some(zone);
  }

  pub fn with_zone(mut self, zone: String) -> NfsExportExtended {
    self.zone = Some(zone);
    self
  }

  pub fn zone(&self) -> Option<&String> {
    self.zone.as_ref()
  }

  pub fn reset_zone(&mut self) {
    self.zone = None;
  }

  pub fn set_conflicting_paths(&mut self, conflicting_paths: Vec<String>) {
    self.conflicting_paths = Some(conflicting_paths);
  }

  pub fn with_conflicting_paths(mut self, conflicting_paths: Vec<String>) -> NfsExportExtended {
    self.conflicting_paths = Some(conflicting_paths);
    self
  }

  pub fn conflicting_paths(&self) -> Option<&Vec<String>> {
    self.conflicting_paths.as_ref()
  }

  pub fn reset_conflicting_paths(&mut self) {
    self.conflicting_paths = None;
  }

  pub fn set_id(&mut self, id: i32) {
    self.id = Some(id);
  }

  pub fn with_id(mut self, id: i32) -> NfsExportExtended {
    self.id = Some(id);
    self
  }

  pub fn id(&self) -> Option<&i32> {
    self.id.as_ref()
  }

  pub fn reset_id(&mut self) {
    self.id = None;
  }

  pub fn set_unresolved_clients(&mut self, unresolved_clients: Vec<String>) {
    self.unresolved_clients = Some(unresolved_clients);
  }

  pub fn with_unresolved_clients(mut self, unresolved_clients: Vec<String>) -> NfsExportExtended {
    self.unresolved_clients = Some(unresolved_clients);
    self
  }

  pub fn unresolved_clients(&self) -> Option<&Vec<String>> {
    self.unresolved_clients.as_ref()
  }

  pub fn reset_unresolved_clients(&mut self) {
    self.unresolved_clients = None;
  }

}



