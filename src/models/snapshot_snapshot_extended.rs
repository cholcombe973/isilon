/* 
 * Isilon SDK
 *
 * Isilon SDK - Language bindings for the OneFS API
 *
 * OpenAPI spec version: 5
 * Contact: sdk@isilon.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */


#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct SnapshotSnapshotExtended {
  /// Alias name to create for this snapshot. If null, remove any alias.
  #[serde(rename = "alias")]
  alias: Option<String>,
  /// The Unix Epoch time the snapshot will expire and be eligible for automatic deletion.
  #[serde(rename = "expires")]
  expires: Option<i32>,
  /// The user or system supplied snapshot name. This will be null for snapshots pending delete.
  #[serde(rename = "name")]
  name: Option<String>,
  /// The Unix Epoch time the snapshot was created.
  #[serde(rename = "created")]
  created: i32,
  /// True if the snapshot has one or more locks present see, see the locks subresource of a snapshot for a list of locks.
  #[serde(rename = "has_locks")]
  has_locks: bool,
  /// The system ID given to the snapshot. This is useful for tracking the status of delete pending snapshots.
  #[serde(rename = "id")]
  id: i32,
  /// The /ifs path snapshotted.
  #[serde(rename = "path")]
  path: Option<String>,
  /// Percentage of /ifs used for storing this snapshot.
  #[serde(rename = "pct_filesystem")]
  pct_filesystem: f32,
  /// Percentage of configured snapshot reserved used for storing this snapshot.
  #[serde(rename = "pct_reserve")]
  pct_reserve: f32,
  /// The name of the schedule used to create this snapshot, if applicable.
  #[serde(rename = "schedule")]
  schedule: Option<String>,
  /// The amount of shadow bytes referred to by this snapshot.
  #[serde(rename = "shadow_bytes")]
  shadow_bytes: i32,
  /// The amount of storage in bytes used to store this snapshot.
  #[serde(rename = "size")]
  size: i32,
  /// Snapshot state.
  #[serde(rename = "state")]
  state: String,
  /// The ID of the snapshot pointed to if this is an alias.
  #[serde(rename = "target_id")]
  target_id: Option<i32>,
  /// The name of the snapshot pointed to if this is an alias.
  #[serde(rename = "target_name")]
  target_name: Option<String>
}

impl SnapshotSnapshotExtended {
  pub fn new(created: i32, has_locks: bool, id: i32, pct_filesystem: f32, pct_reserve: f32, shadow_bytes: i32, size: i32, state: String) -> SnapshotSnapshotExtended {
    SnapshotSnapshotExtended {
      alias: None,
      expires: None,
      name: None,
      created: created,
      has_locks: has_locks,
      id: id,
      path: None,
      pct_filesystem: pct_filesystem,
      pct_reserve: pct_reserve,
      schedule: None,
      shadow_bytes: shadow_bytes,
      size: size,
      state: state,
      target_id: None,
      target_name: None
    }
  }

  pub fn set_alias(&mut self, alias: String) {
    self.alias = Some(alias);
  }

  pub fn with_alias(mut self, alias: String) -> SnapshotSnapshotExtended {
    self.alias = Some(alias);
    self
  }

  pub fn alias(&self) -> Option<&String> {
    self.alias.as_ref()
  }

  pub fn reset_alias(&mut self) {
    self.alias = None;
  }

  pub fn set_expires(&mut self, expires: i32) {
    self.expires = Some(expires);
  }

  pub fn with_expires(mut self, expires: i32) -> SnapshotSnapshotExtended {
    self.expires = Some(expires);
    self
  }

  pub fn expires(&self) -> Option<&i32> {
    self.expires.as_ref()
  }

  pub fn reset_expires(&mut self) {
    self.expires = None;
  }

  pub fn set_name(&mut self, name: String) {
    self.name = Some(name);
  }

  pub fn with_name(mut self, name: String) -> SnapshotSnapshotExtended {
    self.name = Some(name);
    self
  }

  pub fn name(&self) -> Option<&String> {
    self.name.as_ref()
  }

  pub fn reset_name(&mut self) {
    self.name = None;
  }

  pub fn set_created(&mut self, created: i32) {
    self.created = created;
  }

  pub fn with_created(mut self, created: i32) -> SnapshotSnapshotExtended {
    self.created = created;
    self
  }

  pub fn created(&self) -> &i32 {
    &self.created
  }


  pub fn set_has_locks(&mut self, has_locks: bool) {
    self.has_locks = has_locks;
  }

  pub fn with_has_locks(mut self, has_locks: bool) -> SnapshotSnapshotExtended {
    self.has_locks = has_locks;
    self
  }

  pub fn has_locks(&self) -> &bool {
    &self.has_locks
  }


  pub fn set_id(&mut self, id: i32) {
    self.id = id;
  }

  pub fn with_id(mut self, id: i32) -> SnapshotSnapshotExtended {
    self.id = id;
    self
  }

  pub fn id(&self) -> &i32 {
    &self.id
  }


  pub fn set_path(&mut self, path: String) {
    self.path = Some(path);
  }

  pub fn with_path(mut self, path: String) -> SnapshotSnapshotExtended {
    self.path = Some(path);
    self
  }

  pub fn path(&self) -> Option<&String> {
    self.path.as_ref()
  }

  pub fn reset_path(&mut self) {
    self.path = None;
  }

  pub fn set_pct_filesystem(&mut self, pct_filesystem: f32) {
    self.pct_filesystem = pct_filesystem;
  }

  pub fn with_pct_filesystem(mut self, pct_filesystem: f32) -> SnapshotSnapshotExtended {
    self.pct_filesystem = pct_filesystem;
    self
  }

  pub fn pct_filesystem(&self) -> &f32 {
    &self.pct_filesystem
  }


  pub fn set_pct_reserve(&mut self, pct_reserve: f32) {
    self.pct_reserve = pct_reserve;
  }

  pub fn with_pct_reserve(mut self, pct_reserve: f32) -> SnapshotSnapshotExtended {
    self.pct_reserve = pct_reserve;
    self
  }

  pub fn pct_reserve(&self) -> &f32 {
    &self.pct_reserve
  }


  pub fn set_schedule(&mut self, schedule: String) {
    self.schedule = Some(schedule);
  }

  pub fn with_schedule(mut self, schedule: String) -> SnapshotSnapshotExtended {
    self.schedule = Some(schedule);
    self
  }

  pub fn schedule(&self) -> Option<&String> {
    self.schedule.as_ref()
  }

  pub fn reset_schedule(&mut self) {
    self.schedule = None;
  }

  pub fn set_shadow_bytes(&mut self, shadow_bytes: i32) {
    self.shadow_bytes = shadow_bytes;
  }

  pub fn with_shadow_bytes(mut self, shadow_bytes: i32) -> SnapshotSnapshotExtended {
    self.shadow_bytes = shadow_bytes;
    self
  }

  pub fn shadow_bytes(&self) -> &i32 {
    &self.shadow_bytes
  }


  pub fn set_size(&mut self, size: i32) {
    self.size = size;
  }

  pub fn with_size(mut self, size: i32) -> SnapshotSnapshotExtended {
    self.size = size;
    self
  }

  pub fn size(&self) -> &i32 {
    &self.size
  }


  pub fn set_state(&mut self, state: String) {
    self.state = state;
  }

  pub fn with_state(mut self, state: String) -> SnapshotSnapshotExtended {
    self.state = state;
    self
  }

  pub fn state(&self) -> &String {
    &self.state
  }


  pub fn set_target_id(&mut self, target_id: i32) {
    self.target_id = Some(target_id);
  }

  pub fn with_target_id(mut self, target_id: i32) -> SnapshotSnapshotExtended {
    self.target_id = Some(target_id);
    self
  }

  pub fn target_id(&self) -> Option<&i32> {
    self.target_id.as_ref()
  }

  pub fn reset_target_id(&mut self) {
    self.target_id = None;
  }

  pub fn set_target_name(&mut self, target_name: String) {
    self.target_name = Some(target_name);
  }

  pub fn with_target_name(mut self, target_name: String) -> SnapshotSnapshotExtended {
    self.target_name = Some(target_name);
    self
  }

  pub fn target_name(&self) -> Option<&String> {
    self.target_name.as_ref()
  }

  pub fn reset_target_name(&mut self) {
    self.target_name = None;
  }

}



