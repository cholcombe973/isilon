/* 
 * Isilon SDK
 *
 * Isilon SDK - Language bindings for the OneFS API
 *
 * OpenAPI spec version: 5
 * Contact: sdk@isilon.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */


#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct AuthUserCreateParams {
  /// Specifies an email address for the user.
  #[serde(rename = "email")]
  email: Option<String>,
  /// If true, the authenticated user is enabled.
  #[serde(rename = "enabled")]
  enabled: Option<bool>,
  /// Specifies the Unix Epoch time when the auth user will expire.
  #[serde(rename = "expiry")]
  expiry: Option<i32>,
  /// Specifies the GECOS value, which is usually the full name.
  #[serde(rename = "gecos")]
  gecos: Option<String>,
  /// Specifies a home directory for the user.
  #[serde(rename = "home_directory")]
  home_directory: Option<String>,
  /// Changes the password for the user.
  #[serde(rename = "password")]
  password: Option<String>,
  /// If true, the password should expire.
  #[serde(rename = "password_expires")]
  password_expires: Option<bool>,
  /// Specifies properties for a persona, which consists of either a 'type' and a 'name' or an 'ID'.
  #[serde(rename = "primary_group")]
  primary_group: Option<::models::AuthAccessAccessItemFileGroup>,
  /// If true, prompts the user to change their password at the next login.
  #[serde(rename = "prompt_password_change")]
  prompt_password_change: Option<bool>,
  /// Specifies the shell for the user.
  #[serde(rename = "shell")]
  shell: Option<String>,
  /// Specifies a security identifier.
  #[serde(rename = "sid")]
  sid: Option<String>,
  /// Specifies a numeric user identifier.
  #[serde(rename = "uid")]
  uid: Option<i32>,
  /// If true, the user account should be unlocked.
  #[serde(rename = "unlock")]
  unlock: Option<bool>,
  /// Specifies a user name.
  #[serde(rename = "name")]
  name: String
}

impl AuthUserCreateParams {
  pub fn new(name: String) -> AuthUserCreateParams {
    AuthUserCreateParams {
      email: None,
      enabled: None,
      expiry: None,
      gecos: None,
      home_directory: None,
      password: None,
      password_expires: None,
      primary_group: None,
      prompt_password_change: None,
      shell: None,
      sid: None,
      uid: None,
      unlock: None,
      name: name
    }
  }

  pub fn set_email(&mut self, email: String) {
    self.email = Some(email);
  }

  pub fn with_email(mut self, email: String) -> AuthUserCreateParams {
    self.email = Some(email);
    self
  }

  pub fn email(&self) -> Option<&String> {
    self.email.as_ref()
  }

  pub fn reset_email(&mut self) {
    self.email = None;
  }

  pub fn set_enabled(&mut self, enabled: bool) {
    self.enabled = Some(enabled);
  }

  pub fn with_enabled(mut self, enabled: bool) -> AuthUserCreateParams {
    self.enabled = Some(enabled);
    self
  }

  pub fn enabled(&self) -> Option<&bool> {
    self.enabled.as_ref()
  }

  pub fn reset_enabled(&mut self) {
    self.enabled = None;
  }

  pub fn set_expiry(&mut self, expiry: i32) {
    self.expiry = Some(expiry);
  }

  pub fn with_expiry(mut self, expiry: i32) -> AuthUserCreateParams {
    self.expiry = Some(expiry);
    self
  }

  pub fn expiry(&self) -> Option<&i32> {
    self.expiry.as_ref()
  }

  pub fn reset_expiry(&mut self) {
    self.expiry = None;
  }

  pub fn set_gecos(&mut self, gecos: String) {
    self.gecos = Some(gecos);
  }

  pub fn with_gecos(mut self, gecos: String) -> AuthUserCreateParams {
    self.gecos = Some(gecos);
    self
  }

  pub fn gecos(&self) -> Option<&String> {
    self.gecos.as_ref()
  }

  pub fn reset_gecos(&mut self) {
    self.gecos = None;
  }

  pub fn set_home_directory(&mut self, home_directory: String) {
    self.home_directory = Some(home_directory);
  }

  pub fn with_home_directory(mut self, home_directory: String) -> AuthUserCreateParams {
    self.home_directory = Some(home_directory);
    self
  }

  pub fn home_directory(&self) -> Option<&String> {
    self.home_directory.as_ref()
  }

  pub fn reset_home_directory(&mut self) {
    self.home_directory = None;
  }

  pub fn set_password(&mut self, password: String) {
    self.password = Some(password);
  }

  pub fn with_password(mut self, password: String) -> AuthUserCreateParams {
    self.password = Some(password);
    self
  }

  pub fn password(&self) -> Option<&String> {
    self.password.as_ref()
  }

  pub fn reset_password(&mut self) {
    self.password = None;
  }

  pub fn set_password_expires(&mut self, password_expires: bool) {
    self.password_expires = Some(password_expires);
  }

  pub fn with_password_expires(mut self, password_expires: bool) -> AuthUserCreateParams {
    self.password_expires = Some(password_expires);
    self
  }

  pub fn password_expires(&self) -> Option<&bool> {
    self.password_expires.as_ref()
  }

  pub fn reset_password_expires(&mut self) {
    self.password_expires = None;
  }

  pub fn set_primary_group(&mut self, primary_group: ::models::AuthAccessAccessItemFileGroup) {
    self.primary_group = Some(primary_group);
  }

  pub fn with_primary_group(mut self, primary_group: ::models::AuthAccessAccessItemFileGroup) -> AuthUserCreateParams {
    self.primary_group = Some(primary_group);
    self
  }

  pub fn primary_group(&self) -> Option<&::models::AuthAccessAccessItemFileGroup> {
    self.primary_group.as_ref()
  }

  pub fn reset_primary_group(&mut self) {
    self.primary_group = None;
  }

  pub fn set_prompt_password_change(&mut self, prompt_password_change: bool) {
    self.prompt_password_change = Some(prompt_password_change);
  }

  pub fn with_prompt_password_change(mut self, prompt_password_change: bool) -> AuthUserCreateParams {
    self.prompt_password_change = Some(prompt_password_change);
    self
  }

  pub fn prompt_password_change(&self) -> Option<&bool> {
    self.prompt_password_change.as_ref()
  }

  pub fn reset_prompt_password_change(&mut self) {
    self.prompt_password_change = None;
  }

  pub fn set_shell(&mut self, shell: String) {
    self.shell = Some(shell);
  }

  pub fn with_shell(mut self, shell: String) -> AuthUserCreateParams {
    self.shell = Some(shell);
    self
  }

  pub fn shell(&self) -> Option<&String> {
    self.shell.as_ref()
  }

  pub fn reset_shell(&mut self) {
    self.shell = None;
  }

  pub fn set_sid(&mut self, sid: String) {
    self.sid = Some(sid);
  }

  pub fn with_sid(mut self, sid: String) -> AuthUserCreateParams {
    self.sid = Some(sid);
    self
  }

  pub fn sid(&self) -> Option<&String> {
    self.sid.as_ref()
  }

  pub fn reset_sid(&mut self) {
    self.sid = None;
  }

  pub fn set_uid(&mut self, uid: i32) {
    self.uid = Some(uid);
  }

  pub fn with_uid(mut self, uid: i32) -> AuthUserCreateParams {
    self.uid = Some(uid);
    self
  }

  pub fn uid(&self) -> Option<&i32> {
    self.uid.as_ref()
  }

  pub fn reset_uid(&mut self) {
    self.uid = None;
  }

  pub fn set_unlock(&mut self, unlock: bool) {
    self.unlock = Some(unlock);
  }

  pub fn with_unlock(mut self, unlock: bool) -> AuthUserCreateParams {
    self.unlock = Some(unlock);
    self
  }

  pub fn unlock(&self) -> Option<&bool> {
    self.unlock.as_ref()
  }

  pub fn reset_unlock(&mut self) {
    self.unlock = None;
  }

  pub fn set_name(&mut self, name: String) {
    self.name = name;
  }

  pub fn with_name(mut self, name: String) -> AuthUserCreateParams {
    self.name = name;
    self
  }

  pub fn name(&self) -> &String {
    &self.name
  }


}



