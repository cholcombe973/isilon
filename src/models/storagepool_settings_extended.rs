/* 
 * Isilon SDK
 *
 * Isilon SDK - Language bindings for the OneFS API
 *
 * OpenAPI spec version: 5
 * Contact: sdk@isilon.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */


#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct StoragepoolSettingsExtended {
  /// Automatically manage IO optimization settings on files.
  #[serde(rename = "automatically_manage_io_optimization")]
  automatically_manage_io_optimization: Option<String>,
  /// Automatically manage protection settings on files.
  #[serde(rename = "automatically_manage_protection")]
  automatically_manage_protection: Option<String>,
  /// Optimize namespace operations by storing metadata on SSDs.
  #[serde(rename = "global_namespace_acceleration_enabled")]
  global_namespace_acceleration_enabled: Option<bool>,
  /// Automatically add additional protection level to all directories.
  #[serde(rename = "protect_directories_one_level_higher")]
  protect_directories_one_level_higher: Option<bool>,
  /// Spill writes into other pools as needed.
  #[serde(rename = "spillover_enabled")]
  spillover_enabled: Option<bool>,
  /// Target pool for spilled writes.
  #[serde(rename = "spillover_target")]
  spillover_target: Option<::models::StoragepoolSettingsSpilloverTarget>,
  /// The L3 Cache default enabled state. This specifies whether L3 Cache should be enabled on new node pools
  #[serde(rename = "ssd_l3_cache_default_enabled")]
  ssd_l3_cache_default_enabled: Option<bool>,
  /// Controls number of mirrors of QAB blocks to place on SSDs.
  #[serde(rename = "ssd_qab_mirrors")]
  ssd_qab_mirrors: Option<String>,
  /// Controls number of mirrors of system B-tree blocks to place on SSDs.
  #[serde(rename = "ssd_system_btree_mirrors")]
  ssd_system_btree_mirrors: Option<String>,
  /// Controls number of mirrors of system delta blocks to place on SSDs.
  #[serde(rename = "ssd_system_delta_mirrors")]
  ssd_system_delta_mirrors: Option<String>,
  /// Deny writes into reserved virtual hot spare space.
  #[serde(rename = "virtual_hot_spare_deny_writes")]
  virtual_hot_spare_deny_writes: Option<bool>,
  /// Hide reserved virtual hot spare space from free space counts.
  #[serde(rename = "virtual_hot_spare_hide_spare")]
  virtual_hot_spare_hide_spare: Option<bool>,
  /// The number of drives to reserve for the virtual hot spare, from 0-4.
  #[serde(rename = "virtual_hot_spare_limit_drives")]
  virtual_hot_spare_limit_drives: Option<i32>,
  /// The percent space to reserve for the virtual hot spare, from 0-20.
  #[serde(rename = "virtual_hot_spare_limit_percent")]
  virtual_hot_spare_limit_percent: Option<i32>
}

impl StoragepoolSettingsExtended {
  pub fn new() -> StoragepoolSettingsExtended {
    StoragepoolSettingsExtended {
      automatically_manage_io_optimization: None,
      automatically_manage_protection: None,
      global_namespace_acceleration_enabled: None,
      protect_directories_one_level_higher: None,
      spillover_enabled: None,
      spillover_target: None,
      ssd_l3_cache_default_enabled: None,
      ssd_qab_mirrors: None,
      ssd_system_btree_mirrors: None,
      ssd_system_delta_mirrors: None,
      virtual_hot_spare_deny_writes: None,
      virtual_hot_spare_hide_spare: None,
      virtual_hot_spare_limit_drives: None,
      virtual_hot_spare_limit_percent: None
    }
  }

  pub fn set_automatically_manage_io_optimization(&mut self, automatically_manage_io_optimization: String) {
    self.automatically_manage_io_optimization = Some(automatically_manage_io_optimization);
  }

  pub fn with_automatically_manage_io_optimization(mut self, automatically_manage_io_optimization: String) -> StoragepoolSettingsExtended {
    self.automatically_manage_io_optimization = Some(automatically_manage_io_optimization);
    self
  }

  pub fn automatically_manage_io_optimization(&self) -> Option<&String> {
    self.automatically_manage_io_optimization.as_ref()
  }

  pub fn reset_automatically_manage_io_optimization(&mut self) {
    self.automatically_manage_io_optimization = None;
  }

  pub fn set_automatically_manage_protection(&mut self, automatically_manage_protection: String) {
    self.automatically_manage_protection = Some(automatically_manage_protection);
  }

  pub fn with_automatically_manage_protection(mut self, automatically_manage_protection: String) -> StoragepoolSettingsExtended {
    self.automatically_manage_protection = Some(automatically_manage_protection);
    self
  }

  pub fn automatically_manage_protection(&self) -> Option<&String> {
    self.automatically_manage_protection.as_ref()
  }

  pub fn reset_automatically_manage_protection(&mut self) {
    self.automatically_manage_protection = None;
  }

  pub fn set_global_namespace_acceleration_enabled(&mut self, global_namespace_acceleration_enabled: bool) {
    self.global_namespace_acceleration_enabled = Some(global_namespace_acceleration_enabled);
  }

  pub fn with_global_namespace_acceleration_enabled(mut self, global_namespace_acceleration_enabled: bool) -> StoragepoolSettingsExtended {
    self.global_namespace_acceleration_enabled = Some(global_namespace_acceleration_enabled);
    self
  }

  pub fn global_namespace_acceleration_enabled(&self) -> Option<&bool> {
    self.global_namespace_acceleration_enabled.as_ref()
  }

  pub fn reset_global_namespace_acceleration_enabled(&mut self) {
    self.global_namespace_acceleration_enabled = None;
  }

  pub fn set_protect_directories_one_level_higher(&mut self, protect_directories_one_level_higher: bool) {
    self.protect_directories_one_level_higher = Some(protect_directories_one_level_higher);
  }

  pub fn with_protect_directories_one_level_higher(mut self, protect_directories_one_level_higher: bool) -> StoragepoolSettingsExtended {
    self.protect_directories_one_level_higher = Some(protect_directories_one_level_higher);
    self
  }

  pub fn protect_directories_one_level_higher(&self) -> Option<&bool> {
    self.protect_directories_one_level_higher.as_ref()
  }

  pub fn reset_protect_directories_one_level_higher(&mut self) {
    self.protect_directories_one_level_higher = None;
  }

  pub fn set_spillover_enabled(&mut self, spillover_enabled: bool) {
    self.spillover_enabled = Some(spillover_enabled);
  }

  pub fn with_spillover_enabled(mut self, spillover_enabled: bool) -> StoragepoolSettingsExtended {
    self.spillover_enabled = Some(spillover_enabled);
    self
  }

  pub fn spillover_enabled(&self) -> Option<&bool> {
    self.spillover_enabled.as_ref()
  }

  pub fn reset_spillover_enabled(&mut self) {
    self.spillover_enabled = None;
  }

  pub fn set_spillover_target(&mut self, spillover_target: ::models::StoragepoolSettingsSpilloverTarget) {
    self.spillover_target = Some(spillover_target);
  }

  pub fn with_spillover_target(mut self, spillover_target: ::models::StoragepoolSettingsSpilloverTarget) -> StoragepoolSettingsExtended {
    self.spillover_target = Some(spillover_target);
    self
  }

  pub fn spillover_target(&self) -> Option<&::models::StoragepoolSettingsSpilloverTarget> {
    self.spillover_target.as_ref()
  }

  pub fn reset_spillover_target(&mut self) {
    self.spillover_target = None;
  }

  pub fn set_ssd_l3_cache_default_enabled(&mut self, ssd_l3_cache_default_enabled: bool) {
    self.ssd_l3_cache_default_enabled = Some(ssd_l3_cache_default_enabled);
  }

  pub fn with_ssd_l3_cache_default_enabled(mut self, ssd_l3_cache_default_enabled: bool) -> StoragepoolSettingsExtended {
    self.ssd_l3_cache_default_enabled = Some(ssd_l3_cache_default_enabled);
    self
  }

  pub fn ssd_l3_cache_default_enabled(&self) -> Option<&bool> {
    self.ssd_l3_cache_default_enabled.as_ref()
  }

  pub fn reset_ssd_l3_cache_default_enabled(&mut self) {
    self.ssd_l3_cache_default_enabled = None;
  }

  pub fn set_ssd_qab_mirrors(&mut self, ssd_qab_mirrors: String) {
    self.ssd_qab_mirrors = Some(ssd_qab_mirrors);
  }

  pub fn with_ssd_qab_mirrors(mut self, ssd_qab_mirrors: String) -> StoragepoolSettingsExtended {
    self.ssd_qab_mirrors = Some(ssd_qab_mirrors);
    self
  }

  pub fn ssd_qab_mirrors(&self) -> Option<&String> {
    self.ssd_qab_mirrors.as_ref()
  }

  pub fn reset_ssd_qab_mirrors(&mut self) {
    self.ssd_qab_mirrors = None;
  }

  pub fn set_ssd_system_btree_mirrors(&mut self, ssd_system_btree_mirrors: String) {
    self.ssd_system_btree_mirrors = Some(ssd_system_btree_mirrors);
  }

  pub fn with_ssd_system_btree_mirrors(mut self, ssd_system_btree_mirrors: String) -> StoragepoolSettingsExtended {
    self.ssd_system_btree_mirrors = Some(ssd_system_btree_mirrors);
    self
  }

  pub fn ssd_system_btree_mirrors(&self) -> Option<&String> {
    self.ssd_system_btree_mirrors.as_ref()
  }

  pub fn reset_ssd_system_btree_mirrors(&mut self) {
    self.ssd_system_btree_mirrors = None;
  }

  pub fn set_ssd_system_delta_mirrors(&mut self, ssd_system_delta_mirrors: String) {
    self.ssd_system_delta_mirrors = Some(ssd_system_delta_mirrors);
  }

  pub fn with_ssd_system_delta_mirrors(mut self, ssd_system_delta_mirrors: String) -> StoragepoolSettingsExtended {
    self.ssd_system_delta_mirrors = Some(ssd_system_delta_mirrors);
    self
  }

  pub fn ssd_system_delta_mirrors(&self) -> Option<&String> {
    self.ssd_system_delta_mirrors.as_ref()
  }

  pub fn reset_ssd_system_delta_mirrors(&mut self) {
    self.ssd_system_delta_mirrors = None;
  }

  pub fn set_virtual_hot_spare_deny_writes(&mut self, virtual_hot_spare_deny_writes: bool) {
    self.virtual_hot_spare_deny_writes = Some(virtual_hot_spare_deny_writes);
  }

  pub fn with_virtual_hot_spare_deny_writes(mut self, virtual_hot_spare_deny_writes: bool) -> StoragepoolSettingsExtended {
    self.virtual_hot_spare_deny_writes = Some(virtual_hot_spare_deny_writes);
    self
  }

  pub fn virtual_hot_spare_deny_writes(&self) -> Option<&bool> {
    self.virtual_hot_spare_deny_writes.as_ref()
  }

  pub fn reset_virtual_hot_spare_deny_writes(&mut self) {
    self.virtual_hot_spare_deny_writes = None;
  }

  pub fn set_virtual_hot_spare_hide_spare(&mut self, virtual_hot_spare_hide_spare: bool) {
    self.virtual_hot_spare_hide_spare = Some(virtual_hot_spare_hide_spare);
  }

  pub fn with_virtual_hot_spare_hide_spare(mut self, virtual_hot_spare_hide_spare: bool) -> StoragepoolSettingsExtended {
    self.virtual_hot_spare_hide_spare = Some(virtual_hot_spare_hide_spare);
    self
  }

  pub fn virtual_hot_spare_hide_spare(&self) -> Option<&bool> {
    self.virtual_hot_spare_hide_spare.as_ref()
  }

  pub fn reset_virtual_hot_spare_hide_spare(&mut self) {
    self.virtual_hot_spare_hide_spare = None;
  }

  pub fn set_virtual_hot_spare_limit_drives(&mut self, virtual_hot_spare_limit_drives: i32) {
    self.virtual_hot_spare_limit_drives = Some(virtual_hot_spare_limit_drives);
  }

  pub fn with_virtual_hot_spare_limit_drives(mut self, virtual_hot_spare_limit_drives: i32) -> StoragepoolSettingsExtended {
    self.virtual_hot_spare_limit_drives = Some(virtual_hot_spare_limit_drives);
    self
  }

  pub fn virtual_hot_spare_limit_drives(&self) -> Option<&i32> {
    self.virtual_hot_spare_limit_drives.as_ref()
  }

  pub fn reset_virtual_hot_spare_limit_drives(&mut self) {
    self.virtual_hot_spare_limit_drives = None;
  }

  pub fn set_virtual_hot_spare_limit_percent(&mut self, virtual_hot_spare_limit_percent: i32) {
    self.virtual_hot_spare_limit_percent = Some(virtual_hot_spare_limit_percent);
  }

  pub fn with_virtual_hot_spare_limit_percent(mut self, virtual_hot_spare_limit_percent: i32) -> StoragepoolSettingsExtended {
    self.virtual_hot_spare_limit_percent = Some(virtual_hot_spare_limit_percent);
    self
  }

  pub fn virtual_hot_spare_limit_percent(&self) -> Option<&i32> {
    self.virtual_hot_spare_limit_percent.as_ref()
  }

  pub fn reset_virtual_hot_spare_limit_percent(&mut self) {
    self.virtual_hot_spare_limit_percent = None;
  }

}



