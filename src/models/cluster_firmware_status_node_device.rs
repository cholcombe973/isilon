/* 
 * Isilon SDK
 *
 * Isilon SDK - Language bindings for the OneFS API
 *
 * OpenAPI spec version: 5
 * Contact: sdk@isilon.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */


#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct ClusterFirmwareStatusNodeDevice {
  /// The name of the device.
  #[serde(rename = "device")]
  device: Option<String>,
  /// Is the firmware up-to-date for this component.
  #[serde(rename = "mismatch")]
  mismatch: Option<bool>,
  /// The target firmware version.
  #[serde(rename = "target_version")]
  target_version: Option<String>,
  /// The device type.
  #[serde(rename = "type")]
  _type: Option<String>,
  /// The current state of the firmware upgrade for this component. One of the following values: 'queued', 'upgrading', 'upgraded', 'error'. or 'null'.'null' indicates that the upgrade status is unknown.
  #[serde(rename = "upgrade_status")]
  upgrade_status: Option<String>,
  /// The current firmware version.
  #[serde(rename = "version")]
  version: Option<String>
}

impl ClusterFirmwareStatusNodeDevice {
  pub fn new() -> ClusterFirmwareStatusNodeDevice {
    ClusterFirmwareStatusNodeDevice {
      device: None,
      mismatch: None,
      target_version: None,
      _type: None,
      upgrade_status: None,
      version: None
    }
  }

  pub fn set_device(&mut self, device: String) {
    self.device = Some(device);
  }

  pub fn with_device(mut self, device: String) -> ClusterFirmwareStatusNodeDevice {
    self.device = Some(device);
    self
  }

  pub fn device(&self) -> Option<&String> {
    self.device.as_ref()
  }

  pub fn reset_device(&mut self) {
    self.device = None;
  }

  pub fn set_mismatch(&mut self, mismatch: bool) {
    self.mismatch = Some(mismatch);
  }

  pub fn with_mismatch(mut self, mismatch: bool) -> ClusterFirmwareStatusNodeDevice {
    self.mismatch = Some(mismatch);
    self
  }

  pub fn mismatch(&self) -> Option<&bool> {
    self.mismatch.as_ref()
  }

  pub fn reset_mismatch(&mut self) {
    self.mismatch = None;
  }

  pub fn set_target_version(&mut self, target_version: String) {
    self.target_version = Some(target_version);
  }

  pub fn with_target_version(mut self, target_version: String) -> ClusterFirmwareStatusNodeDevice {
    self.target_version = Some(target_version);
    self
  }

  pub fn target_version(&self) -> Option<&String> {
    self.target_version.as_ref()
  }

  pub fn reset_target_version(&mut self) {
    self.target_version = None;
  }

  pub fn set__type(&mut self, _type: String) {
    self._type = Some(_type);
  }

  pub fn with__type(mut self, _type: String) -> ClusterFirmwareStatusNodeDevice {
    self._type = Some(_type);
    self
  }

  pub fn _type(&self) -> Option<&String> {
    self._type.as_ref()
  }

  pub fn reset__type(&mut self) {
    self._type = None;
  }

  pub fn set_upgrade_status(&mut self, upgrade_status: String) {
    self.upgrade_status = Some(upgrade_status);
  }

  pub fn with_upgrade_status(mut self, upgrade_status: String) -> ClusterFirmwareStatusNodeDevice {
    self.upgrade_status = Some(upgrade_status);
    self
  }

  pub fn upgrade_status(&self) -> Option<&String> {
    self.upgrade_status.as_ref()
  }

  pub fn reset_upgrade_status(&mut self) {
    self.upgrade_status = None;
  }

  pub fn set_version(&mut self, version: String) {
    self.version = Some(version);
  }

  pub fn with_version(mut self, version: String) -> ClusterFirmwareStatusNodeDevice {
    self.version = Some(version);
    self
  }

  pub fn version(&self) -> Option<&String> {
    self.version.as_ref()
  }

  pub fn reset_version(&mut self) {
    self.version = None;
  }

}



