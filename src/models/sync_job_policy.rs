/* 
 * Isilon SDK
 *
 * Isilon SDK - Language bindings for the OneFS API
 *
 * OpenAPI spec version: 5
 * Contact: sdk@isilon.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */


#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct SyncJobPolicy {
  /// If 'copy', source files will be copied to the target cluster.  If 'sync', the target directory will be made an image of the source directory:  Files and directories that have been deleted on the source, have been moved within the target directory, or no longer match the selection criteria will be deleted from the target directory.
  #[serde(rename = "action")]
  action: Option<String>,
  /// A file matching pattern, organized as an OR'ed set of AND'ed file criteria, for example ((a AND b) OR (x AND y)) used to define a set of files with specific properties.  Policies of type 'sync' cannot use 'path' or time criteria in their matching patterns, but policies of type 'copy' can use all listed criteria.
  #[serde(rename = "file_matching_pattern")]
  file_matching_pattern: Option<::models::SyncJobPolicyFileMatchingPattern>,
  /// User-assigned name of this sync policy.
  #[serde(rename = "name")]
  name: Option<String>,
  /// Directories that will be excluded from the sync.  Modifying this field will result in a full synchronization of all data.
  #[serde(rename = "source_exclude_directories")]
  source_exclude_directories: Option<Vec<String>>,
  /// Directories that will be included in the sync.  Modifying this field will result in a full synchronization of all data.
  #[serde(rename = "source_include_directories")]
  source_include_directories: Option<Vec<String>>,
  /// The root directory on the source cluster the files will be synced from.  Modifying this field will result in a full synchronization of all data.
  #[serde(rename = "source_root_path")]
  source_root_path: Option<String>,
  /// Hostname or IP address of sync target cluster.  Modifying the target cluster host can result in the policy being unrunnable if the new target does not match the current target association.
  #[serde(rename = "target_host")]
  target_host: Option<String>,
  /// Absolute filesystem path on the target cluster for the sync destination.
  #[serde(rename = "target_path")]
  target_path: Option<String>
}

impl SyncJobPolicy {
  pub fn new() -> SyncJobPolicy {
    SyncJobPolicy {
      action: None,
      file_matching_pattern: None,
      name: None,
      source_exclude_directories: None,
      source_include_directories: None,
      source_root_path: None,
      target_host: None,
      target_path: None
    }
  }

  pub fn set_action(&mut self, action: String) {
    self.action = Some(action);
  }

  pub fn with_action(mut self, action: String) -> SyncJobPolicy {
    self.action = Some(action);
    self
  }

  pub fn action(&self) -> Option<&String> {
    self.action.as_ref()
  }

  pub fn reset_action(&mut self) {
    self.action = None;
  }

  pub fn set_file_matching_pattern(&mut self, file_matching_pattern: ::models::SyncJobPolicyFileMatchingPattern) {
    self.file_matching_pattern = Some(file_matching_pattern);
  }

  pub fn with_file_matching_pattern(mut self, file_matching_pattern: ::models::SyncJobPolicyFileMatchingPattern) -> SyncJobPolicy {
    self.file_matching_pattern = Some(file_matching_pattern);
    self
  }

  pub fn file_matching_pattern(&self) -> Option<&::models::SyncJobPolicyFileMatchingPattern> {
    self.file_matching_pattern.as_ref()
  }

  pub fn reset_file_matching_pattern(&mut self) {
    self.file_matching_pattern = None;
  }

  pub fn set_name(&mut self, name: String) {
    self.name = Some(name);
  }

  pub fn with_name(mut self, name: String) -> SyncJobPolicy {
    self.name = Some(name);
    self
  }

  pub fn name(&self) -> Option<&String> {
    self.name.as_ref()
  }

  pub fn reset_name(&mut self) {
    self.name = None;
  }

  pub fn set_source_exclude_directories(&mut self, source_exclude_directories: Vec<String>) {
    self.source_exclude_directories = Some(source_exclude_directories);
  }

  pub fn with_source_exclude_directories(mut self, source_exclude_directories: Vec<String>) -> SyncJobPolicy {
    self.source_exclude_directories = Some(source_exclude_directories);
    self
  }

  pub fn source_exclude_directories(&self) -> Option<&Vec<String>> {
    self.source_exclude_directories.as_ref()
  }

  pub fn reset_source_exclude_directories(&mut self) {
    self.source_exclude_directories = None;
  }

  pub fn set_source_include_directories(&mut self, source_include_directories: Vec<String>) {
    self.source_include_directories = Some(source_include_directories);
  }

  pub fn with_source_include_directories(mut self, source_include_directories: Vec<String>) -> SyncJobPolicy {
    self.source_include_directories = Some(source_include_directories);
    self
  }

  pub fn source_include_directories(&self) -> Option<&Vec<String>> {
    self.source_include_directories.as_ref()
  }

  pub fn reset_source_include_directories(&mut self) {
    self.source_include_directories = None;
  }

  pub fn set_source_root_path(&mut self, source_root_path: String) {
    self.source_root_path = Some(source_root_path);
  }

  pub fn with_source_root_path(mut self, source_root_path: String) -> SyncJobPolicy {
    self.source_root_path = Some(source_root_path);
    self
  }

  pub fn source_root_path(&self) -> Option<&String> {
    self.source_root_path.as_ref()
  }

  pub fn reset_source_root_path(&mut self) {
    self.source_root_path = None;
  }

  pub fn set_target_host(&mut self, target_host: String) {
    self.target_host = Some(target_host);
  }

  pub fn with_target_host(mut self, target_host: String) -> SyncJobPolicy {
    self.target_host = Some(target_host);
    self
  }

  pub fn target_host(&self) -> Option<&String> {
    self.target_host.as_ref()
  }

  pub fn reset_target_host(&mut self) {
    self.target_host = None;
  }

  pub fn set_target_path(&mut self, target_path: String) {
    self.target_path = Some(target_path);
  }

  pub fn with_target_path(mut self, target_path: String) -> SyncJobPolicy {
    self.target_path = Some(target_path);
    self
  }

  pub fn target_path(&self) -> Option<&String> {
    self.target_path.as_ref()
  }

  pub fn reset_target_path(&mut self) {
    self.target_path = None;
  }

}



