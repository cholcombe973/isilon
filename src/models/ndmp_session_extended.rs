/* 
 * Isilon SDK
 *
 * Isilon SDK - Language bindings for the OneFS API
 *
 * OpenAPI spec version: 5
 * Contact: sdk@isilon.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */


#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct NdmpSessionExtended {
  /// Bytes transferred to/from the filesystem
  #[serde(rename = "data_bytes_transferred")]
  data_bytes_transferred: i32,
  /// State of the NDMP Data Service
  #[serde(rename = "data_state")]
  data_state: String,
  /// The path being recovered to
  #[serde(rename = "dest_path")]
  dest_path: String,
  /// IP address of the DMA
  #[serde(rename = "dma_ip_addr")]
  dma_ip_addr: String,
  /// Number of seconds elapsed since the backup was started
  #[serde(rename = "elapsed_time")]
  elapsed_time: i32,
  /// Unique display ID.
  #[serde(rename = "id")]
  id: String,
  /// Bytes transferred to/from tape or remote writer
  #[serde(rename = "mover_bytes_transferred")]
  mover_bytes_transferred: i32,
  /// State of the NDMP Mover Service
  #[serde(rename = "mover_state")]
  mover_state: String,
  /// The type of backup session
  #[serde(rename = "operation")]
  operation: String,
  /// IP address of the remote NDMP participant
  #[serde(rename = "remote_ip_addr")]
  remote_ip_addr: String,
  /// Name of the media changer device used if any
  #[serde(rename = "scsi_device")]
  scsi_device: String,
  /// Session ID in form <lnn>.<pid>.
  #[serde(rename = "session")]
  session: String,
  /// The path being backed up
  #[serde(rename = "source_path")]
  source_path: String,
  /// Time backup was started in seconds since epoch
  #[serde(rename = "start_time")]
  start_time: i32,
  /// Name of the tape device used if any
  #[serde(rename = "tape_device")]
  tape_device: String,
  /// Describes the mode in which the tape is opened
  #[serde(rename = "tape_open_mode")]
  tape_open_mode: String,
  /// The throughput in MB/s
  #[serde(rename = "throughput")]
  throughput: i32
}

impl NdmpSessionExtended {
  pub fn new(data_bytes_transferred: i32, data_state: String, dest_path: String, dma_ip_addr: String, elapsed_time: i32, id: String, mover_bytes_transferred: i32, mover_state: String, operation: String, remote_ip_addr: String, scsi_device: String, session: String, source_path: String, start_time: i32, tape_device: String, tape_open_mode: String, throughput: i32) -> NdmpSessionExtended {
    NdmpSessionExtended {
      data_bytes_transferred: data_bytes_transferred,
      data_state: data_state,
      dest_path: dest_path,
      dma_ip_addr: dma_ip_addr,
      elapsed_time: elapsed_time,
      id: id,
      mover_bytes_transferred: mover_bytes_transferred,
      mover_state: mover_state,
      operation: operation,
      remote_ip_addr: remote_ip_addr,
      scsi_device: scsi_device,
      session: session,
      source_path: source_path,
      start_time: start_time,
      tape_device: tape_device,
      tape_open_mode: tape_open_mode,
      throughput: throughput
    }
  }

  pub fn set_data_bytes_transferred(&mut self, data_bytes_transferred: i32) {
    self.data_bytes_transferred = data_bytes_transferred;
  }

  pub fn with_data_bytes_transferred(mut self, data_bytes_transferred: i32) -> NdmpSessionExtended {
    self.data_bytes_transferred = data_bytes_transferred;
    self
  }

  pub fn data_bytes_transferred(&self) -> &i32 {
    &self.data_bytes_transferred
  }


  pub fn set_data_state(&mut self, data_state: String) {
    self.data_state = data_state;
  }

  pub fn with_data_state(mut self, data_state: String) -> NdmpSessionExtended {
    self.data_state = data_state;
    self
  }

  pub fn data_state(&self) -> &String {
    &self.data_state
  }


  pub fn set_dest_path(&mut self, dest_path: String) {
    self.dest_path = dest_path;
  }

  pub fn with_dest_path(mut self, dest_path: String) -> NdmpSessionExtended {
    self.dest_path = dest_path;
    self
  }

  pub fn dest_path(&self) -> &String {
    &self.dest_path
  }


  pub fn set_dma_ip_addr(&mut self, dma_ip_addr: String) {
    self.dma_ip_addr = dma_ip_addr;
  }

  pub fn with_dma_ip_addr(mut self, dma_ip_addr: String) -> NdmpSessionExtended {
    self.dma_ip_addr = dma_ip_addr;
    self
  }

  pub fn dma_ip_addr(&self) -> &String {
    &self.dma_ip_addr
  }


  pub fn set_elapsed_time(&mut self, elapsed_time: i32) {
    self.elapsed_time = elapsed_time;
  }

  pub fn with_elapsed_time(mut self, elapsed_time: i32) -> NdmpSessionExtended {
    self.elapsed_time = elapsed_time;
    self
  }

  pub fn elapsed_time(&self) -> &i32 {
    &self.elapsed_time
  }


  pub fn set_id(&mut self, id: String) {
    self.id = id;
  }

  pub fn with_id(mut self, id: String) -> NdmpSessionExtended {
    self.id = id;
    self
  }

  pub fn id(&self) -> &String {
    &self.id
  }


  pub fn set_mover_bytes_transferred(&mut self, mover_bytes_transferred: i32) {
    self.mover_bytes_transferred = mover_bytes_transferred;
  }

  pub fn with_mover_bytes_transferred(mut self, mover_bytes_transferred: i32) -> NdmpSessionExtended {
    self.mover_bytes_transferred = mover_bytes_transferred;
    self
  }

  pub fn mover_bytes_transferred(&self) -> &i32 {
    &self.mover_bytes_transferred
  }


  pub fn set_mover_state(&mut self, mover_state: String) {
    self.mover_state = mover_state;
  }

  pub fn with_mover_state(mut self, mover_state: String) -> NdmpSessionExtended {
    self.mover_state = mover_state;
    self
  }

  pub fn mover_state(&self) -> &String {
    &self.mover_state
  }


  pub fn set_operation(&mut self, operation: String) {
    self.operation = operation;
  }

  pub fn with_operation(mut self, operation: String) -> NdmpSessionExtended {
    self.operation = operation;
    self
  }

  pub fn operation(&self) -> &String {
    &self.operation
  }


  pub fn set_remote_ip_addr(&mut self, remote_ip_addr: String) {
    self.remote_ip_addr = remote_ip_addr;
  }

  pub fn with_remote_ip_addr(mut self, remote_ip_addr: String) -> NdmpSessionExtended {
    self.remote_ip_addr = remote_ip_addr;
    self
  }

  pub fn remote_ip_addr(&self) -> &String {
    &self.remote_ip_addr
  }


  pub fn set_scsi_device(&mut self, scsi_device: String) {
    self.scsi_device = scsi_device;
  }

  pub fn with_scsi_device(mut self, scsi_device: String) -> NdmpSessionExtended {
    self.scsi_device = scsi_device;
    self
  }

  pub fn scsi_device(&self) -> &String {
    &self.scsi_device
  }


  pub fn set_session(&mut self, session: String) {
    self.session = session;
  }

  pub fn with_session(mut self, session: String) -> NdmpSessionExtended {
    self.session = session;
    self
  }

  pub fn session(&self) -> &String {
    &self.session
  }


  pub fn set_source_path(&mut self, source_path: String) {
    self.source_path = source_path;
  }

  pub fn with_source_path(mut self, source_path: String) -> NdmpSessionExtended {
    self.source_path = source_path;
    self
  }

  pub fn source_path(&self) -> &String {
    &self.source_path
  }


  pub fn set_start_time(&mut self, start_time: i32) {
    self.start_time = start_time;
  }

  pub fn with_start_time(mut self, start_time: i32) -> NdmpSessionExtended {
    self.start_time = start_time;
    self
  }

  pub fn start_time(&self) -> &i32 {
    &self.start_time
  }


  pub fn set_tape_device(&mut self, tape_device: String) {
    self.tape_device = tape_device;
  }

  pub fn with_tape_device(mut self, tape_device: String) -> NdmpSessionExtended {
    self.tape_device = tape_device;
    self
  }

  pub fn tape_device(&self) -> &String {
    &self.tape_device
  }


  pub fn set_tape_open_mode(&mut self, tape_open_mode: String) {
    self.tape_open_mode = tape_open_mode;
  }

  pub fn with_tape_open_mode(mut self, tape_open_mode: String) -> NdmpSessionExtended {
    self.tape_open_mode = tape_open_mode;
    self
  }

  pub fn tape_open_mode(&self) -> &String {
    &self.tape_open_mode
  }


  pub fn set_throughput(&mut self, throughput: i32) {
    self.throughput = throughput;
  }

  pub fn with_throughput(mut self, throughput: i32) -> NdmpSessionExtended {
    self.throughput = throughput;
    self
  }

  pub fn throughput(&self) -> &i32 {
    &self.throughput
  }


}



