/* 
 * Isilon SDK
 *
 * Isilon SDK - Language bindings for the OneFS API
 *
 * OpenAPI spec version: 5
 * Contact: sdk@isilon.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */


#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct SmbShareExtended {
  /// Only enumerate files and folders the requesting user has access to.
  #[serde(rename = "access_based_enumeration")]
  access_based_enumeration: Option<bool>,
  /// Access-based enumeration on only the root directory of the share.
  #[serde(rename = "access_based_enumeration_root_only")]
  access_based_enumeration_root_only: Option<bool>,
  /// Allow deletion of read-only files in the share.
  #[serde(rename = "allow_delete_readonly")]
  allow_delete_readonly: Option<bool>,
  /// Allows users to execute files they have read rights for.
  #[serde(rename = "allow_execute_always")]
  allow_execute_always: Option<bool>,
  /// Allow automatic expansion of variables for home directories.
  #[serde(rename = "allow_variable_expansion")]
  allow_variable_expansion: Option<bool>,
  /// Automatically create home directories.
  #[serde(rename = "auto_create_directory")]
  auto_create_directory: Option<bool>,
  /// Share is visible in net view and the browse list.
  #[serde(rename = "browsable")]
  browsable: Option<bool>,
  /// Persistent open timeout for the share.
  #[serde(rename = "ca_timeout")]
  ca_timeout: Option<i32>,
  /// Specify the level of write-integrity on continuously available shares.
  #[serde(rename = "ca_write_integrity")]
  ca_write_integrity: Option<String>,
  /// Level of change notification alerts on the share.
  #[serde(rename = "change_notify")]
  change_notify: Option<String>,
  /// Specify if persistent opens are allowed on the share.
  #[serde(rename = "continuously_available")]
  continuously_available: Option<bool>,
  /// Create permissions for new files and directories in share.
  #[serde(rename = "create_permissions")]
  create_permissions: Option<String>,
  /// Client-side caching policy for the shares.
  #[serde(rename = "csc_policy")]
  csc_policy: Option<String>,
  /// Description for this SMB share.
  #[serde(rename = "description")]
  description: Option<String>,
  /// Directory create mask bits.
  #[serde(rename = "directory_create_mask")]
  directory_create_mask: Option<i32>,
  /// Directory create mode bits.
  #[serde(rename = "directory_create_mode")]
  directory_create_mode: Option<i32>,
  /// File create mask bits.
  #[serde(rename = "file_create_mask")]
  file_create_mask: Option<i32>,
  /// File create mode bits.
  #[serde(rename = "file_create_mode")]
  file_create_mode: Option<i32>,
  /// Specifies the list of file extensions.
  #[serde(rename = "file_filter_extensions")]
  file_filter_extensions: Option<Vec<String>>,
  /// Specifies if filter list is for deny or allow. Default is deny.
  #[serde(rename = "file_filter_type")]
  file_filter_type: Option<String>,
  /// Enables file filtering on this zone.
  #[serde(rename = "file_filtering_enabled")]
  file_filtering_enabled: Option<bool>,
  /// Hide files and directories that begin with a period '.'.
  #[serde(rename = "hide_dot_files")]
  hide_dot_files: Option<bool>,
  /// An ACL expressing which hosts are allowed access. A deny clause must be the final entry.
  #[serde(rename = "host_acl")]
  host_acl: Option<Vec<String>>,
  /// Share ID.
  #[serde(rename = "id")]
  id: Option<String>,
  /// Specify the condition in which user access is done as the guest account.
  #[serde(rename = "impersonate_guest")]
  impersonate_guest: Option<String>,
  /// User account to be used as guest account.
  #[serde(rename = "impersonate_user")]
  impersonate_user: Option<String>,
  /// Set the inheritable ACL on the share path.
  #[serde(rename = "inheritable_path_acl")]
  inheritable_path_acl: Option<bool>,
  /// Specifies the wchar_t starting point for automatic byte mangling.
  #[serde(rename = "mangle_byte_start")]
  mangle_byte_start: Option<i32>,
  /// Character mangle map.
  #[serde(rename = "mangle_map")]
  mangle_map: Option<Vec<String>>,
  /// Share name.
  #[serde(rename = "name")]
  name: Option<String>,
  /// Support NTFS ACLs on files and directories.
  #[serde(rename = "ntfs_acl_support")]
  ntfs_acl_support: Option<bool>,
  /// Support oplocks.
  #[serde(rename = "oplocks")]
  oplocks: Option<bool>,
  /// Path of share within /ifs.
  #[serde(rename = "path")]
  path: Option<String>,
  /// Specifies an ordered list of permission modifications.
  #[serde(rename = "permissions")]
  permissions: Option<Vec<::models::SmbSharePermission>>,
  /// Allow account to run as root.
  #[serde(rename = "run_as_root")]
  run_as_root: Option<Vec<::models::AuthAccessAccessItemFileGroup>>,
  /// Specifies if persistent opens would do strict lockout on the share.
  #[serde(rename = "strict_ca_lockout")]
  strict_ca_lockout: Option<bool>,
  /// Handle SMB flush operations.
  #[serde(rename = "strict_flush")]
  strict_flush: Option<bool>,
  /// Specifies whether byte range locks contend against SMB I/O.
  #[serde(rename = "strict_locking")]
  strict_locking: Option<bool>,
  /// Numeric ID of the access zone which contains this SMB share
  #[serde(rename = "zid")]
  zid: i32
}

impl SmbShareExtended {
  pub fn new(zid: i32) -> SmbShareExtended {
    SmbShareExtended {
      access_based_enumeration: None,
      access_based_enumeration_root_only: None,
      allow_delete_readonly: None,
      allow_execute_always: None,
      allow_variable_expansion: None,
      auto_create_directory: None,
      browsable: None,
      ca_timeout: None,
      ca_write_integrity: None,
      change_notify: None,
      continuously_available: None,
      create_permissions: None,
      csc_policy: None,
      description: None,
      directory_create_mask: None,
      directory_create_mode: None,
      file_create_mask: None,
      file_create_mode: None,
      file_filter_extensions: None,
      file_filter_type: None,
      file_filtering_enabled: None,
      hide_dot_files: None,
      host_acl: None,
      id: None,
      impersonate_guest: None,
      impersonate_user: None,
      inheritable_path_acl: None,
      mangle_byte_start: None,
      mangle_map: None,
      name: None,
      ntfs_acl_support: None,
      oplocks: None,
      path: None,
      permissions: None,
      run_as_root: None,
      strict_ca_lockout: None,
      strict_flush: None,
      strict_locking: None,
      zid: zid
    }
  }

  pub fn set_access_based_enumeration(&mut self, access_based_enumeration: bool) {
    self.access_based_enumeration = Some(access_based_enumeration);
  }

  pub fn with_access_based_enumeration(mut self, access_based_enumeration: bool) -> SmbShareExtended {
    self.access_based_enumeration = Some(access_based_enumeration);
    self
  }

  pub fn access_based_enumeration(&self) -> Option<&bool> {
    self.access_based_enumeration.as_ref()
  }

  pub fn reset_access_based_enumeration(&mut self) {
    self.access_based_enumeration = None;
  }

  pub fn set_access_based_enumeration_root_only(&mut self, access_based_enumeration_root_only: bool) {
    self.access_based_enumeration_root_only = Some(access_based_enumeration_root_only);
  }

  pub fn with_access_based_enumeration_root_only(mut self, access_based_enumeration_root_only: bool) -> SmbShareExtended {
    self.access_based_enumeration_root_only = Some(access_based_enumeration_root_only);
    self
  }

  pub fn access_based_enumeration_root_only(&self) -> Option<&bool> {
    self.access_based_enumeration_root_only.as_ref()
  }

  pub fn reset_access_based_enumeration_root_only(&mut self) {
    self.access_based_enumeration_root_only = None;
  }

  pub fn set_allow_delete_readonly(&mut self, allow_delete_readonly: bool) {
    self.allow_delete_readonly = Some(allow_delete_readonly);
  }

  pub fn with_allow_delete_readonly(mut self, allow_delete_readonly: bool) -> SmbShareExtended {
    self.allow_delete_readonly = Some(allow_delete_readonly);
    self
  }

  pub fn allow_delete_readonly(&self) -> Option<&bool> {
    self.allow_delete_readonly.as_ref()
  }

  pub fn reset_allow_delete_readonly(&mut self) {
    self.allow_delete_readonly = None;
  }

  pub fn set_allow_execute_always(&mut self, allow_execute_always: bool) {
    self.allow_execute_always = Some(allow_execute_always);
  }

  pub fn with_allow_execute_always(mut self, allow_execute_always: bool) -> SmbShareExtended {
    self.allow_execute_always = Some(allow_execute_always);
    self
  }

  pub fn allow_execute_always(&self) -> Option<&bool> {
    self.allow_execute_always.as_ref()
  }

  pub fn reset_allow_execute_always(&mut self) {
    self.allow_execute_always = None;
  }

  pub fn set_allow_variable_expansion(&mut self, allow_variable_expansion: bool) {
    self.allow_variable_expansion = Some(allow_variable_expansion);
  }

  pub fn with_allow_variable_expansion(mut self, allow_variable_expansion: bool) -> SmbShareExtended {
    self.allow_variable_expansion = Some(allow_variable_expansion);
    self
  }

  pub fn allow_variable_expansion(&self) -> Option<&bool> {
    self.allow_variable_expansion.as_ref()
  }

  pub fn reset_allow_variable_expansion(&mut self) {
    self.allow_variable_expansion = None;
  }

  pub fn set_auto_create_directory(&mut self, auto_create_directory: bool) {
    self.auto_create_directory = Some(auto_create_directory);
  }

  pub fn with_auto_create_directory(mut self, auto_create_directory: bool) -> SmbShareExtended {
    self.auto_create_directory = Some(auto_create_directory);
    self
  }

  pub fn auto_create_directory(&self) -> Option<&bool> {
    self.auto_create_directory.as_ref()
  }

  pub fn reset_auto_create_directory(&mut self) {
    self.auto_create_directory = None;
  }

  pub fn set_browsable(&mut self, browsable: bool) {
    self.browsable = Some(browsable);
  }

  pub fn with_browsable(mut self, browsable: bool) -> SmbShareExtended {
    self.browsable = Some(browsable);
    self
  }

  pub fn browsable(&self) -> Option<&bool> {
    self.browsable.as_ref()
  }

  pub fn reset_browsable(&mut self) {
    self.browsable = None;
  }

  pub fn set_ca_timeout(&mut self, ca_timeout: i32) {
    self.ca_timeout = Some(ca_timeout);
  }

  pub fn with_ca_timeout(mut self, ca_timeout: i32) -> SmbShareExtended {
    self.ca_timeout = Some(ca_timeout);
    self
  }

  pub fn ca_timeout(&self) -> Option<&i32> {
    self.ca_timeout.as_ref()
  }

  pub fn reset_ca_timeout(&mut self) {
    self.ca_timeout = None;
  }

  pub fn set_ca_write_integrity(&mut self, ca_write_integrity: String) {
    self.ca_write_integrity = Some(ca_write_integrity);
  }

  pub fn with_ca_write_integrity(mut self, ca_write_integrity: String) -> SmbShareExtended {
    self.ca_write_integrity = Some(ca_write_integrity);
    self
  }

  pub fn ca_write_integrity(&self) -> Option<&String> {
    self.ca_write_integrity.as_ref()
  }

  pub fn reset_ca_write_integrity(&mut self) {
    self.ca_write_integrity = None;
  }

  pub fn set_change_notify(&mut self, change_notify: String) {
    self.change_notify = Some(change_notify);
  }

  pub fn with_change_notify(mut self, change_notify: String) -> SmbShareExtended {
    self.change_notify = Some(change_notify);
    self
  }

  pub fn change_notify(&self) -> Option<&String> {
    self.change_notify.as_ref()
  }

  pub fn reset_change_notify(&mut self) {
    self.change_notify = None;
  }

  pub fn set_continuously_available(&mut self, continuously_available: bool) {
    self.continuously_available = Some(continuously_available);
  }

  pub fn with_continuously_available(mut self, continuously_available: bool) -> SmbShareExtended {
    self.continuously_available = Some(continuously_available);
    self
  }

  pub fn continuously_available(&self) -> Option<&bool> {
    self.continuously_available.as_ref()
  }

  pub fn reset_continuously_available(&mut self) {
    self.continuously_available = None;
  }

  pub fn set_create_permissions(&mut self, create_permissions: String) {
    self.create_permissions = Some(create_permissions);
  }

  pub fn with_create_permissions(mut self, create_permissions: String) -> SmbShareExtended {
    self.create_permissions = Some(create_permissions);
    self
  }

  pub fn create_permissions(&self) -> Option<&String> {
    self.create_permissions.as_ref()
  }

  pub fn reset_create_permissions(&mut self) {
    self.create_permissions = None;
  }

  pub fn set_csc_policy(&mut self, csc_policy: String) {
    self.csc_policy = Some(csc_policy);
  }

  pub fn with_csc_policy(mut self, csc_policy: String) -> SmbShareExtended {
    self.csc_policy = Some(csc_policy);
    self
  }

  pub fn csc_policy(&self) -> Option<&String> {
    self.csc_policy.as_ref()
  }

  pub fn reset_csc_policy(&mut self) {
    self.csc_policy = None;
  }

  pub fn set_description(&mut self, description: String) {
    self.description = Some(description);
  }

  pub fn with_description(mut self, description: String) -> SmbShareExtended {
    self.description = Some(description);
    self
  }

  pub fn description(&self) -> Option<&String> {
    self.description.as_ref()
  }

  pub fn reset_description(&mut self) {
    self.description = None;
  }

  pub fn set_directory_create_mask(&mut self, directory_create_mask: i32) {
    self.directory_create_mask = Some(directory_create_mask);
  }

  pub fn with_directory_create_mask(mut self, directory_create_mask: i32) -> SmbShareExtended {
    self.directory_create_mask = Some(directory_create_mask);
    self
  }

  pub fn directory_create_mask(&self) -> Option<&i32> {
    self.directory_create_mask.as_ref()
  }

  pub fn reset_directory_create_mask(&mut self) {
    self.directory_create_mask = None;
  }

  pub fn set_directory_create_mode(&mut self, directory_create_mode: i32) {
    self.directory_create_mode = Some(directory_create_mode);
  }

  pub fn with_directory_create_mode(mut self, directory_create_mode: i32) -> SmbShareExtended {
    self.directory_create_mode = Some(directory_create_mode);
    self
  }

  pub fn directory_create_mode(&self) -> Option<&i32> {
    self.directory_create_mode.as_ref()
  }

  pub fn reset_directory_create_mode(&mut self) {
    self.directory_create_mode = None;
  }

  pub fn set_file_create_mask(&mut self, file_create_mask: i32) {
    self.file_create_mask = Some(file_create_mask);
  }

  pub fn with_file_create_mask(mut self, file_create_mask: i32) -> SmbShareExtended {
    self.file_create_mask = Some(file_create_mask);
    self
  }

  pub fn file_create_mask(&self) -> Option<&i32> {
    self.file_create_mask.as_ref()
  }

  pub fn reset_file_create_mask(&mut self) {
    self.file_create_mask = None;
  }

  pub fn set_file_create_mode(&mut self, file_create_mode: i32) {
    self.file_create_mode = Some(file_create_mode);
  }

  pub fn with_file_create_mode(mut self, file_create_mode: i32) -> SmbShareExtended {
    self.file_create_mode = Some(file_create_mode);
    self
  }

  pub fn file_create_mode(&self) -> Option<&i32> {
    self.file_create_mode.as_ref()
  }

  pub fn reset_file_create_mode(&mut self) {
    self.file_create_mode = None;
  }

  pub fn set_file_filter_extensions(&mut self, file_filter_extensions: Vec<String>) {
    self.file_filter_extensions = Some(file_filter_extensions);
  }

  pub fn with_file_filter_extensions(mut self, file_filter_extensions: Vec<String>) -> SmbShareExtended {
    self.file_filter_extensions = Some(file_filter_extensions);
    self
  }

  pub fn file_filter_extensions(&self) -> Option<&Vec<String>> {
    self.file_filter_extensions.as_ref()
  }

  pub fn reset_file_filter_extensions(&mut self) {
    self.file_filter_extensions = None;
  }

  pub fn set_file_filter_type(&mut self, file_filter_type: String) {
    self.file_filter_type = Some(file_filter_type);
  }

  pub fn with_file_filter_type(mut self, file_filter_type: String) -> SmbShareExtended {
    self.file_filter_type = Some(file_filter_type);
    self
  }

  pub fn file_filter_type(&self) -> Option<&String> {
    self.file_filter_type.as_ref()
  }

  pub fn reset_file_filter_type(&mut self) {
    self.file_filter_type = None;
  }

  pub fn set_file_filtering_enabled(&mut self, file_filtering_enabled: bool) {
    self.file_filtering_enabled = Some(file_filtering_enabled);
  }

  pub fn with_file_filtering_enabled(mut self, file_filtering_enabled: bool) -> SmbShareExtended {
    self.file_filtering_enabled = Some(file_filtering_enabled);
    self
  }

  pub fn file_filtering_enabled(&self) -> Option<&bool> {
    self.file_filtering_enabled.as_ref()
  }

  pub fn reset_file_filtering_enabled(&mut self) {
    self.file_filtering_enabled = None;
  }

  pub fn set_hide_dot_files(&mut self, hide_dot_files: bool) {
    self.hide_dot_files = Some(hide_dot_files);
  }

  pub fn with_hide_dot_files(mut self, hide_dot_files: bool) -> SmbShareExtended {
    self.hide_dot_files = Some(hide_dot_files);
    self
  }

  pub fn hide_dot_files(&self) -> Option<&bool> {
    self.hide_dot_files.as_ref()
  }

  pub fn reset_hide_dot_files(&mut self) {
    self.hide_dot_files = None;
  }

  pub fn set_host_acl(&mut self, host_acl: Vec<String>) {
    self.host_acl = Some(host_acl);
  }

  pub fn with_host_acl(mut self, host_acl: Vec<String>) -> SmbShareExtended {
    self.host_acl = Some(host_acl);
    self
  }

  pub fn host_acl(&self) -> Option<&Vec<String>> {
    self.host_acl.as_ref()
  }

  pub fn reset_host_acl(&mut self) {
    self.host_acl = None;
  }

  pub fn set_id(&mut self, id: String) {
    self.id = Some(id);
  }

  pub fn with_id(mut self, id: String) -> SmbShareExtended {
    self.id = Some(id);
    self
  }

  pub fn id(&self) -> Option<&String> {
    self.id.as_ref()
  }

  pub fn reset_id(&mut self) {
    self.id = None;
  }

  pub fn set_impersonate_guest(&mut self, impersonate_guest: String) {
    self.impersonate_guest = Some(impersonate_guest);
  }

  pub fn with_impersonate_guest(mut self, impersonate_guest: String) -> SmbShareExtended {
    self.impersonate_guest = Some(impersonate_guest);
    self
  }

  pub fn impersonate_guest(&self) -> Option<&String> {
    self.impersonate_guest.as_ref()
  }

  pub fn reset_impersonate_guest(&mut self) {
    self.impersonate_guest = None;
  }

  pub fn set_impersonate_user(&mut self, impersonate_user: String) {
    self.impersonate_user = Some(impersonate_user);
  }

  pub fn with_impersonate_user(mut self, impersonate_user: String) -> SmbShareExtended {
    self.impersonate_user = Some(impersonate_user);
    self
  }

  pub fn impersonate_user(&self) -> Option<&String> {
    self.impersonate_user.as_ref()
  }

  pub fn reset_impersonate_user(&mut self) {
    self.impersonate_user = None;
  }

  pub fn set_inheritable_path_acl(&mut self, inheritable_path_acl: bool) {
    self.inheritable_path_acl = Some(inheritable_path_acl);
  }

  pub fn with_inheritable_path_acl(mut self, inheritable_path_acl: bool) -> SmbShareExtended {
    self.inheritable_path_acl = Some(inheritable_path_acl);
    self
  }

  pub fn inheritable_path_acl(&self) -> Option<&bool> {
    self.inheritable_path_acl.as_ref()
  }

  pub fn reset_inheritable_path_acl(&mut self) {
    self.inheritable_path_acl = None;
  }

  pub fn set_mangle_byte_start(&mut self, mangle_byte_start: i32) {
    self.mangle_byte_start = Some(mangle_byte_start);
  }

  pub fn with_mangle_byte_start(mut self, mangle_byte_start: i32) -> SmbShareExtended {
    self.mangle_byte_start = Some(mangle_byte_start);
    self
  }

  pub fn mangle_byte_start(&self) -> Option<&i32> {
    self.mangle_byte_start.as_ref()
  }

  pub fn reset_mangle_byte_start(&mut self) {
    self.mangle_byte_start = None;
  }

  pub fn set_mangle_map(&mut self, mangle_map: Vec<String>) {
    self.mangle_map = Some(mangle_map);
  }

  pub fn with_mangle_map(mut self, mangle_map: Vec<String>) -> SmbShareExtended {
    self.mangle_map = Some(mangle_map);
    self
  }

  pub fn mangle_map(&self) -> Option<&Vec<String>> {
    self.mangle_map.as_ref()
  }

  pub fn reset_mangle_map(&mut self) {
    self.mangle_map = None;
  }

  pub fn set_name(&mut self, name: String) {
    self.name = Some(name);
  }

  pub fn with_name(mut self, name: String) -> SmbShareExtended {
    self.name = Some(name);
    self
  }

  pub fn name(&self) -> Option<&String> {
    self.name.as_ref()
  }

  pub fn reset_name(&mut self) {
    self.name = None;
  }

  pub fn set_ntfs_acl_support(&mut self, ntfs_acl_support: bool) {
    self.ntfs_acl_support = Some(ntfs_acl_support);
  }

  pub fn with_ntfs_acl_support(mut self, ntfs_acl_support: bool) -> SmbShareExtended {
    self.ntfs_acl_support = Some(ntfs_acl_support);
    self
  }

  pub fn ntfs_acl_support(&self) -> Option<&bool> {
    self.ntfs_acl_support.as_ref()
  }

  pub fn reset_ntfs_acl_support(&mut self) {
    self.ntfs_acl_support = None;
  }

  pub fn set_oplocks(&mut self, oplocks: bool) {
    self.oplocks = Some(oplocks);
  }

  pub fn with_oplocks(mut self, oplocks: bool) -> SmbShareExtended {
    self.oplocks = Some(oplocks);
    self
  }

  pub fn oplocks(&self) -> Option<&bool> {
    self.oplocks.as_ref()
  }

  pub fn reset_oplocks(&mut self) {
    self.oplocks = None;
  }

  pub fn set_path(&mut self, path: String) {
    self.path = Some(path);
  }

  pub fn with_path(mut self, path: String) -> SmbShareExtended {
    self.path = Some(path);
    self
  }

  pub fn path(&self) -> Option<&String> {
    self.path.as_ref()
  }

  pub fn reset_path(&mut self) {
    self.path = None;
  }

  pub fn set_permissions(&mut self, permissions: Vec<::models::SmbSharePermission>) {
    self.permissions = Some(permissions);
  }

  pub fn with_permissions(mut self, permissions: Vec<::models::SmbSharePermission>) -> SmbShareExtended {
    self.permissions = Some(permissions);
    self
  }

  pub fn permissions(&self) -> Option<&Vec<::models::SmbSharePermission>> {
    self.permissions.as_ref()
  }

  pub fn reset_permissions(&mut self) {
    self.permissions = None;
  }

  pub fn set_run_as_root(&mut self, run_as_root: Vec<::models::AuthAccessAccessItemFileGroup>) {
    self.run_as_root = Some(run_as_root);
  }

  pub fn with_run_as_root(mut self, run_as_root: Vec<::models::AuthAccessAccessItemFileGroup>) -> SmbShareExtended {
    self.run_as_root = Some(run_as_root);
    self
  }

  pub fn run_as_root(&self) -> Option<&Vec<::models::AuthAccessAccessItemFileGroup>> {
    self.run_as_root.as_ref()
  }

  pub fn reset_run_as_root(&mut self) {
    self.run_as_root = None;
  }

  pub fn set_strict_ca_lockout(&mut self, strict_ca_lockout: bool) {
    self.strict_ca_lockout = Some(strict_ca_lockout);
  }

  pub fn with_strict_ca_lockout(mut self, strict_ca_lockout: bool) -> SmbShareExtended {
    self.strict_ca_lockout = Some(strict_ca_lockout);
    self
  }

  pub fn strict_ca_lockout(&self) -> Option<&bool> {
    self.strict_ca_lockout.as_ref()
  }

  pub fn reset_strict_ca_lockout(&mut self) {
    self.strict_ca_lockout = None;
  }

  pub fn set_strict_flush(&mut self, strict_flush: bool) {
    self.strict_flush = Some(strict_flush);
  }

  pub fn with_strict_flush(mut self, strict_flush: bool) -> SmbShareExtended {
    self.strict_flush = Some(strict_flush);
    self
  }

  pub fn strict_flush(&self) -> Option<&bool> {
    self.strict_flush.as_ref()
  }

  pub fn reset_strict_flush(&mut self) {
    self.strict_flush = None;
  }

  pub fn set_strict_locking(&mut self, strict_locking: bool) {
    self.strict_locking = Some(strict_locking);
  }

  pub fn with_strict_locking(mut self, strict_locking: bool) -> SmbShareExtended {
    self.strict_locking = Some(strict_locking);
    self
  }

  pub fn strict_locking(&self) -> Option<&bool> {
    self.strict_locking.as_ref()
  }

  pub fn reset_strict_locking(&mut self) {
    self.strict_locking = None;
  }

  pub fn set_zid(&mut self, zid: i32) {
    self.zid = zid;
  }

  pub fn with_zid(mut self, zid: i32) -> SmbShareExtended {
    self.zid = zid;
    self
  }

  pub fn zid(&self) -> &i32 {
    &self.zid
  }


}



