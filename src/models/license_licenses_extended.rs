/* 
 * Isilon SDK
 *
 * Isilon SDK - Language bindings for the OneFS API
 *
 * OpenAPI spec version: 5
 * Contact: sdk@isilon.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */


#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct LicenseLicensesExtended {
  #[serde(rename = "licenses")]
  licenses: Option<Vec<::models::LicenseLicense>>,
  /// True when we are generating an activation incomplete alert. An activation incomplete alert is generated if we do not have a signed license file 90 days after OneFS is upgraded.
  #[serde(rename = "activation_incomplete_alert")]
  activation_incomplete_alert: bool,
  #[serde(rename = "base_only_licenses")]
  base_only_licenses: Vec<String>,
  #[serde(rename = "evaluatable")]
  evaluatable: Vec<String>,
  /// Software license identifier. SWID will be absent if not yet obtained from a license file.
  #[serde(rename = "swid")]
  swid: Option<String>,
  /// True if license file contains a valid signature.
  #[serde(rename = "valid_signature")]
  valid_signature: bool
}

impl LicenseLicensesExtended {
  pub fn new(activation_incomplete_alert: bool, base_only_licenses: Vec<String>, evaluatable: Vec<String>, valid_signature: bool) -> LicenseLicensesExtended {
    LicenseLicensesExtended {
      licenses: None,
      activation_incomplete_alert: activation_incomplete_alert,
      base_only_licenses: base_only_licenses,
      evaluatable: evaluatable,
      swid: None,
      valid_signature: valid_signature
    }
  }

  pub fn set_licenses(&mut self, licenses: Vec<::models::LicenseLicense>) {
    self.licenses = Some(licenses);
  }

  pub fn with_licenses(mut self, licenses: Vec<::models::LicenseLicense>) -> LicenseLicensesExtended {
    self.licenses = Some(licenses);
    self
  }

  pub fn licenses(&self) -> Option<&Vec<::models::LicenseLicense>> {
    self.licenses.as_ref()
  }

  pub fn reset_licenses(&mut self) {
    self.licenses = None;
  }

  pub fn set_activation_incomplete_alert(&mut self, activation_incomplete_alert: bool) {
    self.activation_incomplete_alert = activation_incomplete_alert;
  }

  pub fn with_activation_incomplete_alert(mut self, activation_incomplete_alert: bool) -> LicenseLicensesExtended {
    self.activation_incomplete_alert = activation_incomplete_alert;
    self
  }

  pub fn activation_incomplete_alert(&self) -> &bool {
    &self.activation_incomplete_alert
  }


  pub fn set_base_only_licenses(&mut self, base_only_licenses: Vec<String>) {
    self.base_only_licenses = base_only_licenses;
  }

  pub fn with_base_only_licenses(mut self, base_only_licenses: Vec<String>) -> LicenseLicensesExtended {
    self.base_only_licenses = base_only_licenses;
    self
  }

  pub fn base_only_licenses(&self) -> &Vec<String> {
    &self.base_only_licenses
  }


  pub fn set_evaluatable(&mut self, evaluatable: Vec<String>) {
    self.evaluatable = evaluatable;
  }

  pub fn with_evaluatable(mut self, evaluatable: Vec<String>) -> LicenseLicensesExtended {
    self.evaluatable = evaluatable;
    self
  }

  pub fn evaluatable(&self) -> &Vec<String> {
    &self.evaluatable
  }


  pub fn set_swid(&mut self, swid: String) {
    self.swid = Some(swid);
  }

  pub fn with_swid(mut self, swid: String) -> LicenseLicensesExtended {
    self.swid = Some(swid);
    self
  }

  pub fn swid(&self) -> Option<&String> {
    self.swid.as_ref()
  }

  pub fn reset_swid(&mut self) {
    self.swid = None;
  }

  pub fn set_valid_signature(&mut self, valid_signature: bool) {
    self.valid_signature = valid_signature;
  }

  pub fn with_valid_signature(mut self, valid_signature: bool) -> LicenseLicensesExtended {
    self.valid_signature = valid_signature;
    self
  }

  pub fn valid_signature(&self) -> &bool {
    &self.valid_signature
  }


}



