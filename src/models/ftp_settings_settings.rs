/* 
 * Isilon SDK
 *
 * Isilon SDK - Language bindings for the OneFS API
 *
 * OpenAPI spec version: 5
 * Contact: sdk@isilon.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */


#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct FtpSettingsSettings {
  /// The timeout, in seconds, for a remote client to establish a PASV style data connection.
  #[serde(rename = "accept_timeout")]
  accept_timeout: Option<i32>,
  /// Controls whether anonymous logins are permitted or not.
  #[serde(rename = "allow_anon_access")]
  allow_anon_access: Option<bool>,
  /// Controls whether anonymous users will be permitted to upload files.
  #[serde(rename = "allow_anon_upload")]
  allow_anon_upload: Option<bool>,
  /// If set to false, all directory list commands will return a permission denied error.
  #[serde(rename = "allow_dirlists")]
  allow_dirlists: Option<bool>,
  /// If set to false, all downloads requests will return a permission denied error.
  #[serde(rename = "allow_downloads")]
  allow_downloads: Option<bool>,
  /// Controls whether local logins are permitted or not.
  #[serde(rename = "allow_local_access")]
  allow_local_access: Option<bool>,
  /// This controls whether any FTP commands which change the filesystem are allowed or not.
  #[serde(rename = "allow_writes")]
  allow_writes: Option<bool>,
  /// This controls whether FTP will always initially change directories to the home directory of the user, regardless of whether it is chroot-ing.
  #[serde(rename = "always_chdir_homedir")]
  always_chdir_homedir: Option<bool>,
  /// This is the name of the user who is given ownership of anonymously uploaded files.
  #[serde(rename = "anon_chown_username")]
  anon_chown_username: Option<String>,
  /// A list of passwords for anonymous users.
  #[serde(rename = "anon_password_list")]
  anon_password_list: Option<Vec<String>>,
  /// This option represents a directory in /ifs which vsftpd will try to change into after an anonymous login.
  #[serde(rename = "anon_root_path")]
  anon_root_path: Option<String>,
  /// The value that the umask for file creation is set to for anonymous users.
  #[serde(rename = "anon_umask")]
  anon_umask: Option<i32>,
  /// Controls whether ascii mode data transfers are honored for various types of requests.
  #[serde(rename = "ascii_mode")]
  ascii_mode: Option<String>,
  /// A list of users that are not chrooted when logging in.
  #[serde(rename = "chroot_exception_list")]
  chroot_exception_list: Option<Vec<String>>,
  /// If set to 'all', all local users will be (by default) placed in a chroot() jail in their home directory after login. If set to 'all-with-exceptions', all local users except those listed in the chroot exception list (isi ftp chroot-exception-list) will be placed in a chroot() jail in their home directory after login. If set to 'none', no local users will be chrooted by default. If set to 'none-with-exceptions', only the local users listed in the chroot exception list (isi ftp chroot-exception-list) will be place in a chroot() jail in their home directory after login.
  #[serde(rename = "chroot_local_mode")]
  chroot_local_mode: Option<String>,
  /// The timeout, in seconds, for a remote client to respond to our PORT style data connection.
  #[serde(rename = "connect_timeout")]
  connect_timeout: Option<i32>,
  /// The timeout, in seconds, which is roughly the maximum time we permit data transfers to stall for with no progress. If the timeout triggers, the remote client is kicked off.
  #[serde(rename = "data_timeout")]
  data_timeout: Option<i32>,
  /// A list of uses that will be denied access.
  #[serde(rename = "denied_user_list")]
  denied_user_list: Option<Vec<String>>,
  /// If enabled, display directory listings with the time in your local time zone. The default is to display GMT. The times returned by the MDTM FTP command are also affected by this option.
  #[serde(rename = "dirlist_localtime")]
  dirlist_localtime: Option<bool>,
  /// When set to 'hide',  all user and group information in directory listings will be displayed as 'ftp'. When set to 'textual', textual names are shown in the user and group fields of directory listings. When set to 'numeric', numeric IDs are show in the user and group fields of directory listings.
  #[serde(rename = "dirlist_names")]
  dirlist_names: Option<String>,
  /// The permissions with which uploaded files are created. Umasks are applied on top of this value.
  #[serde(rename = "file_create_perm")]
  file_create_perm: Option<i32>,
  /// This field determines whether the anon_password_list is used.
  #[serde(rename = "limit_anon_passwords")]
  limit_anon_passwords: Option<bool>,
  /// This option represents a directory in /ifs which vsftpd will try to change into after a local login.
  #[serde(rename = "local_root_path")]
  local_root_path: Option<String>,
  /// The value that the umask for file creation is set to for local users.
  #[serde(rename = "local_umask")]
  local_umask: Option<i32>,
  /// If enabled, allow server-to-server (FXP) transfers.
  #[serde(rename = "server_to_server")]
  server_to_server: Option<bool>,
  /// This field controls whether the FTP daemon is running.
  #[serde(rename = "service")]
  service: Option<bool>,
  /// If enabled, maintain login sessions for each user through Pluggable Authentication Modules (PAM). Disabling this option prevents the ability to do automatic home directory creation if that functionality were otherwise available.
  #[serde(rename = "session_support")]
  session_support: Option<bool>,
  /// The timeout, in seconds, which is roughly the maximum time we permit data transfers to stall for with no progress. If the timeout triggers, the remote client is kicked off.
  #[serde(rename = "session_timeout")]
  session_timeout: Option<i32>,
  /// Specifies the directory where per-user config overrides can be found.
  #[serde(rename = "user_config_dir")]
  user_config_dir: Option<String>
}

impl FtpSettingsSettings {
  pub fn new() -> FtpSettingsSettings {
    FtpSettingsSettings {
      accept_timeout: None,
      allow_anon_access: None,
      allow_anon_upload: None,
      allow_dirlists: None,
      allow_downloads: None,
      allow_local_access: None,
      allow_writes: None,
      always_chdir_homedir: None,
      anon_chown_username: None,
      anon_password_list: None,
      anon_root_path: None,
      anon_umask: None,
      ascii_mode: None,
      chroot_exception_list: None,
      chroot_local_mode: None,
      connect_timeout: None,
      data_timeout: None,
      denied_user_list: None,
      dirlist_localtime: None,
      dirlist_names: None,
      file_create_perm: None,
      limit_anon_passwords: None,
      local_root_path: None,
      local_umask: None,
      server_to_server: None,
      service: None,
      session_support: None,
      session_timeout: None,
      user_config_dir: None
    }
  }

  pub fn set_accept_timeout(&mut self, accept_timeout: i32) {
    self.accept_timeout = Some(accept_timeout);
  }

  pub fn with_accept_timeout(mut self, accept_timeout: i32) -> FtpSettingsSettings {
    self.accept_timeout = Some(accept_timeout);
    self
  }

  pub fn accept_timeout(&self) -> Option<&i32> {
    self.accept_timeout.as_ref()
  }

  pub fn reset_accept_timeout(&mut self) {
    self.accept_timeout = None;
  }

  pub fn set_allow_anon_access(&mut self, allow_anon_access: bool) {
    self.allow_anon_access = Some(allow_anon_access);
  }

  pub fn with_allow_anon_access(mut self, allow_anon_access: bool) -> FtpSettingsSettings {
    self.allow_anon_access = Some(allow_anon_access);
    self
  }

  pub fn allow_anon_access(&self) -> Option<&bool> {
    self.allow_anon_access.as_ref()
  }

  pub fn reset_allow_anon_access(&mut self) {
    self.allow_anon_access = None;
  }

  pub fn set_allow_anon_upload(&mut self, allow_anon_upload: bool) {
    self.allow_anon_upload = Some(allow_anon_upload);
  }

  pub fn with_allow_anon_upload(mut self, allow_anon_upload: bool) -> FtpSettingsSettings {
    self.allow_anon_upload = Some(allow_anon_upload);
    self
  }

  pub fn allow_anon_upload(&self) -> Option<&bool> {
    self.allow_anon_upload.as_ref()
  }

  pub fn reset_allow_anon_upload(&mut self) {
    self.allow_anon_upload = None;
  }

  pub fn set_allow_dirlists(&mut self, allow_dirlists: bool) {
    self.allow_dirlists = Some(allow_dirlists);
  }

  pub fn with_allow_dirlists(mut self, allow_dirlists: bool) -> FtpSettingsSettings {
    self.allow_dirlists = Some(allow_dirlists);
    self
  }

  pub fn allow_dirlists(&self) -> Option<&bool> {
    self.allow_dirlists.as_ref()
  }

  pub fn reset_allow_dirlists(&mut self) {
    self.allow_dirlists = None;
  }

  pub fn set_allow_downloads(&mut self, allow_downloads: bool) {
    self.allow_downloads = Some(allow_downloads);
  }

  pub fn with_allow_downloads(mut self, allow_downloads: bool) -> FtpSettingsSettings {
    self.allow_downloads = Some(allow_downloads);
    self
  }

  pub fn allow_downloads(&self) -> Option<&bool> {
    self.allow_downloads.as_ref()
  }

  pub fn reset_allow_downloads(&mut self) {
    self.allow_downloads = None;
  }

  pub fn set_allow_local_access(&mut self, allow_local_access: bool) {
    self.allow_local_access = Some(allow_local_access);
  }

  pub fn with_allow_local_access(mut self, allow_local_access: bool) -> FtpSettingsSettings {
    self.allow_local_access = Some(allow_local_access);
    self
  }

  pub fn allow_local_access(&self) -> Option<&bool> {
    self.allow_local_access.as_ref()
  }

  pub fn reset_allow_local_access(&mut self) {
    self.allow_local_access = None;
  }

  pub fn set_allow_writes(&mut self, allow_writes: bool) {
    self.allow_writes = Some(allow_writes);
  }

  pub fn with_allow_writes(mut self, allow_writes: bool) -> FtpSettingsSettings {
    self.allow_writes = Some(allow_writes);
    self
  }

  pub fn allow_writes(&self) -> Option<&bool> {
    self.allow_writes.as_ref()
  }

  pub fn reset_allow_writes(&mut self) {
    self.allow_writes = None;
  }

  pub fn set_always_chdir_homedir(&mut self, always_chdir_homedir: bool) {
    self.always_chdir_homedir = Some(always_chdir_homedir);
  }

  pub fn with_always_chdir_homedir(mut self, always_chdir_homedir: bool) -> FtpSettingsSettings {
    self.always_chdir_homedir = Some(always_chdir_homedir);
    self
  }

  pub fn always_chdir_homedir(&self) -> Option<&bool> {
    self.always_chdir_homedir.as_ref()
  }

  pub fn reset_always_chdir_homedir(&mut self) {
    self.always_chdir_homedir = None;
  }

  pub fn set_anon_chown_username(&mut self, anon_chown_username: String) {
    self.anon_chown_username = Some(anon_chown_username);
  }

  pub fn with_anon_chown_username(mut self, anon_chown_username: String) -> FtpSettingsSettings {
    self.anon_chown_username = Some(anon_chown_username);
    self
  }

  pub fn anon_chown_username(&self) -> Option<&String> {
    self.anon_chown_username.as_ref()
  }

  pub fn reset_anon_chown_username(&mut self) {
    self.anon_chown_username = None;
  }

  pub fn set_anon_password_list(&mut self, anon_password_list: Vec<String>) {
    self.anon_password_list = Some(anon_password_list);
  }

  pub fn with_anon_password_list(mut self, anon_password_list: Vec<String>) -> FtpSettingsSettings {
    self.anon_password_list = Some(anon_password_list);
    self
  }

  pub fn anon_password_list(&self) -> Option<&Vec<String>> {
    self.anon_password_list.as_ref()
  }

  pub fn reset_anon_password_list(&mut self) {
    self.anon_password_list = None;
  }

  pub fn set_anon_root_path(&mut self, anon_root_path: String) {
    self.anon_root_path = Some(anon_root_path);
  }

  pub fn with_anon_root_path(mut self, anon_root_path: String) -> FtpSettingsSettings {
    self.anon_root_path = Some(anon_root_path);
    self
  }

  pub fn anon_root_path(&self) -> Option<&String> {
    self.anon_root_path.as_ref()
  }

  pub fn reset_anon_root_path(&mut self) {
    self.anon_root_path = None;
  }

  pub fn set_anon_umask(&mut self, anon_umask: i32) {
    self.anon_umask = Some(anon_umask);
  }

  pub fn with_anon_umask(mut self, anon_umask: i32) -> FtpSettingsSettings {
    self.anon_umask = Some(anon_umask);
    self
  }

  pub fn anon_umask(&self) -> Option<&i32> {
    self.anon_umask.as_ref()
  }

  pub fn reset_anon_umask(&mut self) {
    self.anon_umask = None;
  }

  pub fn set_ascii_mode(&mut self, ascii_mode: String) {
    self.ascii_mode = Some(ascii_mode);
  }

  pub fn with_ascii_mode(mut self, ascii_mode: String) -> FtpSettingsSettings {
    self.ascii_mode = Some(ascii_mode);
    self
  }

  pub fn ascii_mode(&self) -> Option<&String> {
    self.ascii_mode.as_ref()
  }

  pub fn reset_ascii_mode(&mut self) {
    self.ascii_mode = None;
  }

  pub fn set_chroot_exception_list(&mut self, chroot_exception_list: Vec<String>) {
    self.chroot_exception_list = Some(chroot_exception_list);
  }

  pub fn with_chroot_exception_list(mut self, chroot_exception_list: Vec<String>) -> FtpSettingsSettings {
    self.chroot_exception_list = Some(chroot_exception_list);
    self
  }

  pub fn chroot_exception_list(&self) -> Option<&Vec<String>> {
    self.chroot_exception_list.as_ref()
  }

  pub fn reset_chroot_exception_list(&mut self) {
    self.chroot_exception_list = None;
  }

  pub fn set_chroot_local_mode(&mut self, chroot_local_mode: String) {
    self.chroot_local_mode = Some(chroot_local_mode);
  }

  pub fn with_chroot_local_mode(mut self, chroot_local_mode: String) -> FtpSettingsSettings {
    self.chroot_local_mode = Some(chroot_local_mode);
    self
  }

  pub fn chroot_local_mode(&self) -> Option<&String> {
    self.chroot_local_mode.as_ref()
  }

  pub fn reset_chroot_local_mode(&mut self) {
    self.chroot_local_mode = None;
  }

  pub fn set_connect_timeout(&mut self, connect_timeout: i32) {
    self.connect_timeout = Some(connect_timeout);
  }

  pub fn with_connect_timeout(mut self, connect_timeout: i32) -> FtpSettingsSettings {
    self.connect_timeout = Some(connect_timeout);
    self
  }

  pub fn connect_timeout(&self) -> Option<&i32> {
    self.connect_timeout.as_ref()
  }

  pub fn reset_connect_timeout(&mut self) {
    self.connect_timeout = None;
  }

  pub fn set_data_timeout(&mut self, data_timeout: i32) {
    self.data_timeout = Some(data_timeout);
  }

  pub fn with_data_timeout(mut self, data_timeout: i32) -> FtpSettingsSettings {
    self.data_timeout = Some(data_timeout);
    self
  }

  pub fn data_timeout(&self) -> Option<&i32> {
    self.data_timeout.as_ref()
  }

  pub fn reset_data_timeout(&mut self) {
    self.data_timeout = None;
  }

  pub fn set_denied_user_list(&mut self, denied_user_list: Vec<String>) {
    self.denied_user_list = Some(denied_user_list);
  }

  pub fn with_denied_user_list(mut self, denied_user_list: Vec<String>) -> FtpSettingsSettings {
    self.denied_user_list = Some(denied_user_list);
    self
  }

  pub fn denied_user_list(&self) -> Option<&Vec<String>> {
    self.denied_user_list.as_ref()
  }

  pub fn reset_denied_user_list(&mut self) {
    self.denied_user_list = None;
  }

  pub fn set_dirlist_localtime(&mut self, dirlist_localtime: bool) {
    self.dirlist_localtime = Some(dirlist_localtime);
  }

  pub fn with_dirlist_localtime(mut self, dirlist_localtime: bool) -> FtpSettingsSettings {
    self.dirlist_localtime = Some(dirlist_localtime);
    self
  }

  pub fn dirlist_localtime(&self) -> Option<&bool> {
    self.dirlist_localtime.as_ref()
  }

  pub fn reset_dirlist_localtime(&mut self) {
    self.dirlist_localtime = None;
  }

  pub fn set_dirlist_names(&mut self, dirlist_names: String) {
    self.dirlist_names = Some(dirlist_names);
  }

  pub fn with_dirlist_names(mut self, dirlist_names: String) -> FtpSettingsSettings {
    self.dirlist_names = Some(dirlist_names);
    self
  }

  pub fn dirlist_names(&self) -> Option<&String> {
    self.dirlist_names.as_ref()
  }

  pub fn reset_dirlist_names(&mut self) {
    self.dirlist_names = None;
  }

  pub fn set_file_create_perm(&mut self, file_create_perm: i32) {
    self.file_create_perm = Some(file_create_perm);
  }

  pub fn with_file_create_perm(mut self, file_create_perm: i32) -> FtpSettingsSettings {
    self.file_create_perm = Some(file_create_perm);
    self
  }

  pub fn file_create_perm(&self) -> Option<&i32> {
    self.file_create_perm.as_ref()
  }

  pub fn reset_file_create_perm(&mut self) {
    self.file_create_perm = None;
  }

  pub fn set_limit_anon_passwords(&mut self, limit_anon_passwords: bool) {
    self.limit_anon_passwords = Some(limit_anon_passwords);
  }

  pub fn with_limit_anon_passwords(mut self, limit_anon_passwords: bool) -> FtpSettingsSettings {
    self.limit_anon_passwords = Some(limit_anon_passwords);
    self
  }

  pub fn limit_anon_passwords(&self) -> Option<&bool> {
    self.limit_anon_passwords.as_ref()
  }

  pub fn reset_limit_anon_passwords(&mut self) {
    self.limit_anon_passwords = None;
  }

  pub fn set_local_root_path(&mut self, local_root_path: String) {
    self.local_root_path = Some(local_root_path);
  }

  pub fn with_local_root_path(mut self, local_root_path: String) -> FtpSettingsSettings {
    self.local_root_path = Some(local_root_path);
    self
  }

  pub fn local_root_path(&self) -> Option<&String> {
    self.local_root_path.as_ref()
  }

  pub fn reset_local_root_path(&mut self) {
    self.local_root_path = None;
  }

  pub fn set_local_umask(&mut self, local_umask: i32) {
    self.local_umask = Some(local_umask);
  }

  pub fn with_local_umask(mut self, local_umask: i32) -> FtpSettingsSettings {
    self.local_umask = Some(local_umask);
    self
  }

  pub fn local_umask(&self) -> Option<&i32> {
    self.local_umask.as_ref()
  }

  pub fn reset_local_umask(&mut self) {
    self.local_umask = None;
  }

  pub fn set_server_to_server(&mut self, server_to_server: bool) {
    self.server_to_server = Some(server_to_server);
  }

  pub fn with_server_to_server(mut self, server_to_server: bool) -> FtpSettingsSettings {
    self.server_to_server = Some(server_to_server);
    self
  }

  pub fn server_to_server(&self) -> Option<&bool> {
    self.server_to_server.as_ref()
  }

  pub fn reset_server_to_server(&mut self) {
    self.server_to_server = None;
  }

  pub fn set_service(&mut self, service: bool) {
    self.service = Some(service);
  }

  pub fn with_service(mut self, service: bool) -> FtpSettingsSettings {
    self.service = Some(service);
    self
  }

  pub fn service(&self) -> Option<&bool> {
    self.service.as_ref()
  }

  pub fn reset_service(&mut self) {
    self.service = None;
  }

  pub fn set_session_support(&mut self, session_support: bool) {
    self.session_support = Some(session_support);
  }

  pub fn with_session_support(mut self, session_support: bool) -> FtpSettingsSettings {
    self.session_support = Some(session_support);
    self
  }

  pub fn session_support(&self) -> Option<&bool> {
    self.session_support.as_ref()
  }

  pub fn reset_session_support(&mut self) {
    self.session_support = None;
  }

  pub fn set_session_timeout(&mut self, session_timeout: i32) {
    self.session_timeout = Some(session_timeout);
  }

  pub fn with_session_timeout(mut self, session_timeout: i32) -> FtpSettingsSettings {
    self.session_timeout = Some(session_timeout);
    self
  }

  pub fn session_timeout(&self) -> Option<&i32> {
    self.session_timeout.as_ref()
  }

  pub fn reset_session_timeout(&mut self) {
    self.session_timeout = None;
  }

  pub fn set_user_config_dir(&mut self, user_config_dir: String) {
    self.user_config_dir = Some(user_config_dir);
  }

  pub fn with_user_config_dir(mut self, user_config_dir: String) -> FtpSettingsSettings {
    self.user_config_dir = Some(user_config_dir);
    self
  }

  pub fn user_config_dir(&self) -> Option<&String> {
    self.user_config_dir.as_ref()
  }

  pub fn reset_user_config_dir(&mut self) {
    self.user_config_dir = None;
  }

}



