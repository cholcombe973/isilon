/* 
 * Isilon SDK
 *
 * Isilon SDK - Language bindings for the OneFS API
 *
 * OpenAPI spec version: 5
 * Contact: sdk@isilon.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */


#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct SummaryWorkloadWorkloadItem {
  /// The number (across all cores) of micro-seconds per second.
  #[serde(rename = "cpu")]
  cpu: f32,
  /// The canonical name for the job followed by phase in brackets, ie. 'AVscan[1]', etc...
  #[serde(rename = "job_type")]
  job_type: Option<String>,
  /// L2 cache hits per second.
  #[serde(rename = "l2")]
  l2: f32,
  /// L3 cache hits per second.
  #[serde(rename = "l3")]
  l3: f32,
  /// The node on which the operation was performed.
  #[serde(rename = "node")]
  node: f32,
  /// Disk read operations per second.
  #[serde(rename = "reads")]
  reads: f32,
  /// The process name, job ID, etc...
  #[serde(rename = "system_name")]
  system_name: Option<String>,
  /// Disk write operations per second.
  #[serde(rename = "writes")]
  writes: f32
}

impl SummaryWorkloadWorkloadItem {
  pub fn new(cpu: f32, l2: f32, l3: f32, node: f32, reads: f32, writes: f32) -> SummaryWorkloadWorkloadItem {
    SummaryWorkloadWorkloadItem {
      cpu: cpu,
      job_type: None,
      l2: l2,
      l3: l3,
      node: node,
      reads: reads,
      system_name: None,
      writes: writes
    }
  }

  pub fn set_cpu(&mut self, cpu: f32) {
    self.cpu = cpu;
  }

  pub fn with_cpu(mut self, cpu: f32) -> SummaryWorkloadWorkloadItem {
    self.cpu = cpu;
    self
  }

  pub fn cpu(&self) -> &f32 {
    &self.cpu
  }


  pub fn set_job_type(&mut self, job_type: String) {
    self.job_type = Some(job_type);
  }

  pub fn with_job_type(mut self, job_type: String) -> SummaryWorkloadWorkloadItem {
    self.job_type = Some(job_type);
    self
  }

  pub fn job_type(&self) -> Option<&String> {
    self.job_type.as_ref()
  }

  pub fn reset_job_type(&mut self) {
    self.job_type = None;
  }

  pub fn set_l2(&mut self, l2: f32) {
    self.l2 = l2;
  }

  pub fn with_l2(mut self, l2: f32) -> SummaryWorkloadWorkloadItem {
    self.l2 = l2;
    self
  }

  pub fn l2(&self) -> &f32 {
    &self.l2
  }


  pub fn set_l3(&mut self, l3: f32) {
    self.l3 = l3;
  }

  pub fn with_l3(mut self, l3: f32) -> SummaryWorkloadWorkloadItem {
    self.l3 = l3;
    self
  }

  pub fn l3(&self) -> &f32 {
    &self.l3
  }


  pub fn set_node(&mut self, node: f32) {
    self.node = node;
  }

  pub fn with_node(mut self, node: f32) -> SummaryWorkloadWorkloadItem {
    self.node = node;
    self
  }

  pub fn node(&self) -> &f32 {
    &self.node
  }


  pub fn set_reads(&mut self, reads: f32) {
    self.reads = reads;
  }

  pub fn with_reads(mut self, reads: f32) -> SummaryWorkloadWorkloadItem {
    self.reads = reads;
    self
  }

  pub fn reads(&self) -> &f32 {
    &self.reads
  }


  pub fn set_system_name(&mut self, system_name: String) {
    self.system_name = Some(system_name);
  }

  pub fn with_system_name(mut self, system_name: String) -> SummaryWorkloadWorkloadItem {
    self.system_name = Some(system_name);
    self
  }

  pub fn system_name(&self) -> Option<&String> {
    self.system_name.as_ref()
  }

  pub fn reset_system_name(&mut self) {
    self.system_name = None;
  }

  pub fn set_writes(&mut self, writes: f32) {
    self.writes = writes;
  }

  pub fn with_writes(mut self, writes: f32) -> SummaryWorkloadWorkloadItem {
    self.writes = writes;
    self
  }

  pub fn writes(&self) -> &f32 {
    &self.writes
  }


}



