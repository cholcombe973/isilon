/* 
 * Isilon SDK
 *
 * Isilon SDK - Language bindings for the OneFS API
 *
 * OpenAPI spec version: 5
 * Contact: sdk@isilon.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */


#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct SubnetsSubnetPoolsPool {
  /// Name of a valid access zone to map IP address pool to the zone.
  #[serde(rename = "access_zone")]
  access_zone: String,
  /// IP address format.
  #[serde(rename = "addr_family")]
  addr_family: String,
  /// OneFS supports the following NIC aggregation modes.
  #[serde(rename = "aggregation_mode")]
  aggregation_mode: String,
  /// Specifies how IP address allocation is done among pool members.
  #[serde(rename = "alloc_method")]
  alloc_method: String,
  /// A description of the pool.
  #[serde(rename = "description")]
  description: String,
  /// Name of the groupnet this pool belongs to.
  #[serde(rename = "groupnet")]
  groupnet: String,
  /// Unique Pool ID.
  #[serde(rename = "id")]
  id: String,
  /// List of interface members in this pool.
  #[serde(rename = "ifaces")]
  ifaces: Vec<::models::SubnetsSubnetPoolIface>,
  /// The name of the pool. It must be unique throughout the given subnet.It's a required field with POST method.
  #[serde(rename = "name")]
  name: String,
  /// List of IP address ranges in this pool.
  #[serde(rename = "ranges")]
  ranges: Vec<::models::SubnetsSubnetPoolRange>,
  /// Rebalance policy..
  #[serde(rename = "rebalance_policy")]
  rebalance_policy: String,
  /// Names of the rules in this pool.
  #[serde(rename = "rules")]
  rules: Vec<String>,
  /// Time delay in seconds before a node which has been                 automatically unsuspended becomes usable in SmartConnect                responses for pool zones.
  #[serde(rename = "sc_auto_unsuspend_delay")]
  sc_auto_unsuspend_delay: i32,
  /// SmartConnect client connection balancing policy.
  #[serde(rename = "sc_connect_policy")]
  sc_connect_policy: String,
  /// SmartConnect zone name for the pool.
  #[serde(rename = "sc_dns_zone")]
  sc_dns_zone: String,
  /// List of SmartConnect zone aliases (DNS names) to the pool.
  #[serde(rename = "sc_dns_zone_aliases")]
  sc_dns_zone_aliases: Vec<String>,
  /// SmartConnect IP failover policy.
  #[serde(rename = "sc_failover_policy")]
  sc_failover_policy: String,
  /// Name of SmartConnect service subnet for this pool.
  #[serde(rename = "sc_subnet")]
  sc_subnet: String,
  /// List of LNNs showing currently suspended nodes in SmartConnect.
  #[serde(rename = "sc_suspended_nodes")]
  sc_suspended_nodes: Vec<i32>,
  /// Time to live value for SmartConnect DNS query responses in seconds.
  #[serde(rename = "sc_ttl")]
  sc_ttl: i32,
  /// List of interface members in this pool.
  #[serde(rename = "static_routes")]
  static_routes: Vec<::models::SubnetsSubnetPoolStaticRoute>,
  /// The name of the subnet.
  #[serde(rename = "subnet")]
  subnet: String
}

impl SubnetsSubnetPoolsPool {
  pub fn new(access_zone: String, addr_family: String, aggregation_mode: String, alloc_method: String, description: String, groupnet: String, id: String, ifaces: Vec<::models::SubnetsSubnetPoolIface>, name: String, ranges: Vec<::models::SubnetsSubnetPoolRange>, rebalance_policy: String, rules: Vec<String>, sc_auto_unsuspend_delay: i32, sc_connect_policy: String, sc_dns_zone: String, sc_dns_zone_aliases: Vec<String>, sc_failover_policy: String, sc_subnet: String, sc_suspended_nodes: Vec<i32>, sc_ttl: i32, static_routes: Vec<::models::SubnetsSubnetPoolStaticRoute>, subnet: String) -> SubnetsSubnetPoolsPool {
    SubnetsSubnetPoolsPool {
      access_zone: access_zone,
      addr_family: addr_family,
      aggregation_mode: aggregation_mode,
      alloc_method: alloc_method,
      description: description,
      groupnet: groupnet,
      id: id,
      ifaces: ifaces,
      name: name,
      ranges: ranges,
      rebalance_policy: rebalance_policy,
      rules: rules,
      sc_auto_unsuspend_delay: sc_auto_unsuspend_delay,
      sc_connect_policy: sc_connect_policy,
      sc_dns_zone: sc_dns_zone,
      sc_dns_zone_aliases: sc_dns_zone_aliases,
      sc_failover_policy: sc_failover_policy,
      sc_subnet: sc_subnet,
      sc_suspended_nodes: sc_suspended_nodes,
      sc_ttl: sc_ttl,
      static_routes: static_routes,
      subnet: subnet
    }
  }

  pub fn set_access_zone(&mut self, access_zone: String) {
    self.access_zone = access_zone;
  }

  pub fn with_access_zone(mut self, access_zone: String) -> SubnetsSubnetPoolsPool {
    self.access_zone = access_zone;
    self
  }

  pub fn access_zone(&self) -> &String {
    &self.access_zone
  }


  pub fn set_addr_family(&mut self, addr_family: String) {
    self.addr_family = addr_family;
  }

  pub fn with_addr_family(mut self, addr_family: String) -> SubnetsSubnetPoolsPool {
    self.addr_family = addr_family;
    self
  }

  pub fn addr_family(&self) -> &String {
    &self.addr_family
  }


  pub fn set_aggregation_mode(&mut self, aggregation_mode: String) {
    self.aggregation_mode = aggregation_mode;
  }

  pub fn with_aggregation_mode(mut self, aggregation_mode: String) -> SubnetsSubnetPoolsPool {
    self.aggregation_mode = aggregation_mode;
    self
  }

  pub fn aggregation_mode(&self) -> &String {
    &self.aggregation_mode
  }


  pub fn set_alloc_method(&mut self, alloc_method: String) {
    self.alloc_method = alloc_method;
  }

  pub fn with_alloc_method(mut self, alloc_method: String) -> SubnetsSubnetPoolsPool {
    self.alloc_method = alloc_method;
    self
  }

  pub fn alloc_method(&self) -> &String {
    &self.alloc_method
  }


  pub fn set_description(&mut self, description: String) {
    self.description = description;
  }

  pub fn with_description(mut self, description: String) -> SubnetsSubnetPoolsPool {
    self.description = description;
    self
  }

  pub fn description(&self) -> &String {
    &self.description
  }


  pub fn set_groupnet(&mut self, groupnet: String) {
    self.groupnet = groupnet;
  }

  pub fn with_groupnet(mut self, groupnet: String) -> SubnetsSubnetPoolsPool {
    self.groupnet = groupnet;
    self
  }

  pub fn groupnet(&self) -> &String {
    &self.groupnet
  }


  pub fn set_id(&mut self, id: String) {
    self.id = id;
  }

  pub fn with_id(mut self, id: String) -> SubnetsSubnetPoolsPool {
    self.id = id;
    self
  }

  pub fn id(&self) -> &String {
    &self.id
  }


  pub fn set_ifaces(&mut self, ifaces: Vec<::models::SubnetsSubnetPoolIface>) {
    self.ifaces = ifaces;
  }

  pub fn with_ifaces(mut self, ifaces: Vec<::models::SubnetsSubnetPoolIface>) -> SubnetsSubnetPoolsPool {
    self.ifaces = ifaces;
    self
  }

  pub fn ifaces(&self) -> &Vec<::models::SubnetsSubnetPoolIface> {
    &self.ifaces
  }


  pub fn set_name(&mut self, name: String) {
    self.name = name;
  }

  pub fn with_name(mut self, name: String) -> SubnetsSubnetPoolsPool {
    self.name = name;
    self
  }

  pub fn name(&self) -> &String {
    &self.name
  }


  pub fn set_ranges(&mut self, ranges: Vec<::models::SubnetsSubnetPoolRange>) {
    self.ranges = ranges;
  }

  pub fn with_ranges(mut self, ranges: Vec<::models::SubnetsSubnetPoolRange>) -> SubnetsSubnetPoolsPool {
    self.ranges = ranges;
    self
  }

  pub fn ranges(&self) -> &Vec<::models::SubnetsSubnetPoolRange> {
    &self.ranges
  }


  pub fn set_rebalance_policy(&mut self, rebalance_policy: String) {
    self.rebalance_policy = rebalance_policy;
  }

  pub fn with_rebalance_policy(mut self, rebalance_policy: String) -> SubnetsSubnetPoolsPool {
    self.rebalance_policy = rebalance_policy;
    self
  }

  pub fn rebalance_policy(&self) -> &String {
    &self.rebalance_policy
  }


  pub fn set_rules(&mut self, rules: Vec<String>) {
    self.rules = rules;
  }

  pub fn with_rules(mut self, rules: Vec<String>) -> SubnetsSubnetPoolsPool {
    self.rules = rules;
    self
  }

  pub fn rules(&self) -> &Vec<String> {
    &self.rules
  }


  pub fn set_sc_auto_unsuspend_delay(&mut self, sc_auto_unsuspend_delay: i32) {
    self.sc_auto_unsuspend_delay = sc_auto_unsuspend_delay;
  }

  pub fn with_sc_auto_unsuspend_delay(mut self, sc_auto_unsuspend_delay: i32) -> SubnetsSubnetPoolsPool {
    self.sc_auto_unsuspend_delay = sc_auto_unsuspend_delay;
    self
  }

  pub fn sc_auto_unsuspend_delay(&self) -> &i32 {
    &self.sc_auto_unsuspend_delay
  }


  pub fn set_sc_connect_policy(&mut self, sc_connect_policy: String) {
    self.sc_connect_policy = sc_connect_policy;
  }

  pub fn with_sc_connect_policy(mut self, sc_connect_policy: String) -> SubnetsSubnetPoolsPool {
    self.sc_connect_policy = sc_connect_policy;
    self
  }

  pub fn sc_connect_policy(&self) -> &String {
    &self.sc_connect_policy
  }


  pub fn set_sc_dns_zone(&mut self, sc_dns_zone: String) {
    self.sc_dns_zone = sc_dns_zone;
  }

  pub fn with_sc_dns_zone(mut self, sc_dns_zone: String) -> SubnetsSubnetPoolsPool {
    self.sc_dns_zone = sc_dns_zone;
    self
  }

  pub fn sc_dns_zone(&self) -> &String {
    &self.sc_dns_zone
  }


  pub fn set_sc_dns_zone_aliases(&mut self, sc_dns_zone_aliases: Vec<String>) {
    self.sc_dns_zone_aliases = sc_dns_zone_aliases;
  }

  pub fn with_sc_dns_zone_aliases(mut self, sc_dns_zone_aliases: Vec<String>) -> SubnetsSubnetPoolsPool {
    self.sc_dns_zone_aliases = sc_dns_zone_aliases;
    self
  }

  pub fn sc_dns_zone_aliases(&self) -> &Vec<String> {
    &self.sc_dns_zone_aliases
  }


  pub fn set_sc_failover_policy(&mut self, sc_failover_policy: String) {
    self.sc_failover_policy = sc_failover_policy;
  }

  pub fn with_sc_failover_policy(mut self, sc_failover_policy: String) -> SubnetsSubnetPoolsPool {
    self.sc_failover_policy = sc_failover_policy;
    self
  }

  pub fn sc_failover_policy(&self) -> &String {
    &self.sc_failover_policy
  }


  pub fn set_sc_subnet(&mut self, sc_subnet: String) {
    self.sc_subnet = sc_subnet;
  }

  pub fn with_sc_subnet(mut self, sc_subnet: String) -> SubnetsSubnetPoolsPool {
    self.sc_subnet = sc_subnet;
    self
  }

  pub fn sc_subnet(&self) -> &String {
    &self.sc_subnet
  }


  pub fn set_sc_suspended_nodes(&mut self, sc_suspended_nodes: Vec<i32>) {
    self.sc_suspended_nodes = sc_suspended_nodes;
  }

  pub fn with_sc_suspended_nodes(mut self, sc_suspended_nodes: Vec<i32>) -> SubnetsSubnetPoolsPool {
    self.sc_suspended_nodes = sc_suspended_nodes;
    self
  }

  pub fn sc_suspended_nodes(&self) -> &Vec<i32> {
    &self.sc_suspended_nodes
  }


  pub fn set_sc_ttl(&mut self, sc_ttl: i32) {
    self.sc_ttl = sc_ttl;
  }

  pub fn with_sc_ttl(mut self, sc_ttl: i32) -> SubnetsSubnetPoolsPool {
    self.sc_ttl = sc_ttl;
    self
  }

  pub fn sc_ttl(&self) -> &i32 {
    &self.sc_ttl
  }


  pub fn set_static_routes(&mut self, static_routes: Vec<::models::SubnetsSubnetPoolStaticRoute>) {
    self.static_routes = static_routes;
  }

  pub fn with_static_routes(mut self, static_routes: Vec<::models::SubnetsSubnetPoolStaticRoute>) -> SubnetsSubnetPoolsPool {
    self.static_routes = static_routes;
    self
  }

  pub fn static_routes(&self) -> &Vec<::models::SubnetsSubnetPoolStaticRoute> {
    &self.static_routes
  }


  pub fn set_subnet(&mut self, subnet: String) {
    self.subnet = subnet;
  }

  pub fn with_subnet(mut self, subnet: String) -> SubnetsSubnetPoolsPool {
    self.subnet = subnet;
    self
  }

  pub fn subnet(&self) -> &String {
    &self.subnet
  }


}



