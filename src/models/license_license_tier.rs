/* 
 * Isilon SDK
 *
 * Isilon SDK - Language bindings for the OneFS API
 *
 * OpenAPI spec version: 5
 * Contact: sdk@isilon.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */


#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct LicenseLicenseTier {
  /// List of alerts about exceeded entitlements: The following alerts appear when usage of a resource such as a node, an encryption node, or storage capacity exceeds the quantity licensed for that resource.
  #[serde(rename = "entitlements_exceeded_alerts")]
  entitlements_exceeded_alerts: Option<Vec<::models::LicenseLicenseTierEntitlementsExceededAlert>>,
  /// Licensed terabyte (TB, 10^12 bytes) drive capacity allocated as storage associated with tier. Included if tier is not NONINF and license is not a base only license.
  #[serde(rename = "licensed_drive_capacity")]
  licensed_drive_capacity: Option<i32>,
  /// Licensed number of nodes in this tier.
  #[serde(rename = "licensed_node_count")]
  licensed_node_count: Option<i32>,
  /// Licensed number of nodes of this tier that contain self-encrypting drives. Included only if license is ONEFS and tier is not NONINF.
  #[serde(rename = "licensed_nodes_with_seds_count")]
  licensed_nodes_with_seds_count: Option<i32>,
  /// OneFS hardware tier. Tier is a number, NONINF, or NO_TIER. NONINF indicates a non infinity tier. NO_TIER indicates a license that is not tier based.
  #[serde(rename = "tier")]
  tier: Option<String>,
  /// Actual terabyte (TB, 10^12 bytes) drive capacity allocated as storage space associated with tier. Included if tier is not NONINF and license is not a base only license.
  #[serde(rename = "used_drive_capacity")]
  used_drive_capacity: Option<i32>,
  /// Actual number of nodes in this tier.
  #[serde(rename = "used_node_count")]
  used_node_count: Option<i32>,
  /// Actual number of nodes of this tier that contain self-encrypting drives. Included only if license is ONEFS and if tier is not NONINF.
  #[serde(rename = "used_nodes_with_seds_count")]
  used_nodes_with_seds_count: Option<i32>
}

impl LicenseLicenseTier {
  pub fn new() -> LicenseLicenseTier {
    LicenseLicenseTier {
      entitlements_exceeded_alerts: None,
      licensed_drive_capacity: None,
      licensed_node_count: None,
      licensed_nodes_with_seds_count: None,
      tier: None,
      used_drive_capacity: None,
      used_node_count: None,
      used_nodes_with_seds_count: None
    }
  }

  pub fn set_entitlements_exceeded_alerts(&mut self, entitlements_exceeded_alerts: Vec<::models::LicenseLicenseTierEntitlementsExceededAlert>) {
    self.entitlements_exceeded_alerts = Some(entitlements_exceeded_alerts);
  }

  pub fn with_entitlements_exceeded_alerts(mut self, entitlements_exceeded_alerts: Vec<::models::LicenseLicenseTierEntitlementsExceededAlert>) -> LicenseLicenseTier {
    self.entitlements_exceeded_alerts = Some(entitlements_exceeded_alerts);
    self
  }

  pub fn entitlements_exceeded_alerts(&self) -> Option<&Vec<::models::LicenseLicenseTierEntitlementsExceededAlert>> {
    self.entitlements_exceeded_alerts.as_ref()
  }

  pub fn reset_entitlements_exceeded_alerts(&mut self) {
    self.entitlements_exceeded_alerts = None;
  }

  pub fn set_licensed_drive_capacity(&mut self, licensed_drive_capacity: i32) {
    self.licensed_drive_capacity = Some(licensed_drive_capacity);
  }

  pub fn with_licensed_drive_capacity(mut self, licensed_drive_capacity: i32) -> LicenseLicenseTier {
    self.licensed_drive_capacity = Some(licensed_drive_capacity);
    self
  }

  pub fn licensed_drive_capacity(&self) -> Option<&i32> {
    self.licensed_drive_capacity.as_ref()
  }

  pub fn reset_licensed_drive_capacity(&mut self) {
    self.licensed_drive_capacity = None;
  }

  pub fn set_licensed_node_count(&mut self, licensed_node_count: i32) {
    self.licensed_node_count = Some(licensed_node_count);
  }

  pub fn with_licensed_node_count(mut self, licensed_node_count: i32) -> LicenseLicenseTier {
    self.licensed_node_count = Some(licensed_node_count);
    self
  }

  pub fn licensed_node_count(&self) -> Option<&i32> {
    self.licensed_node_count.as_ref()
  }

  pub fn reset_licensed_node_count(&mut self) {
    self.licensed_node_count = None;
  }

  pub fn set_licensed_nodes_with_seds_count(&mut self, licensed_nodes_with_seds_count: i32) {
    self.licensed_nodes_with_seds_count = Some(licensed_nodes_with_seds_count);
  }

  pub fn with_licensed_nodes_with_seds_count(mut self, licensed_nodes_with_seds_count: i32) -> LicenseLicenseTier {
    self.licensed_nodes_with_seds_count = Some(licensed_nodes_with_seds_count);
    self
  }

  pub fn licensed_nodes_with_seds_count(&self) -> Option<&i32> {
    self.licensed_nodes_with_seds_count.as_ref()
  }

  pub fn reset_licensed_nodes_with_seds_count(&mut self) {
    self.licensed_nodes_with_seds_count = None;
  }

  pub fn set_tier(&mut self, tier: String) {
    self.tier = Some(tier);
  }

  pub fn with_tier(mut self, tier: String) -> LicenseLicenseTier {
    self.tier = Some(tier);
    self
  }

  pub fn tier(&self) -> Option<&String> {
    self.tier.as_ref()
  }

  pub fn reset_tier(&mut self) {
    self.tier = None;
  }

  pub fn set_used_drive_capacity(&mut self, used_drive_capacity: i32) {
    self.used_drive_capacity = Some(used_drive_capacity);
  }

  pub fn with_used_drive_capacity(mut self, used_drive_capacity: i32) -> LicenseLicenseTier {
    self.used_drive_capacity = Some(used_drive_capacity);
    self
  }

  pub fn used_drive_capacity(&self) -> Option<&i32> {
    self.used_drive_capacity.as_ref()
  }

  pub fn reset_used_drive_capacity(&mut self) {
    self.used_drive_capacity = None;
  }

  pub fn set_used_node_count(&mut self, used_node_count: i32) {
    self.used_node_count = Some(used_node_count);
  }

  pub fn with_used_node_count(mut self, used_node_count: i32) -> LicenseLicenseTier {
    self.used_node_count = Some(used_node_count);
    self
  }

  pub fn used_node_count(&self) -> Option<&i32> {
    self.used_node_count.as_ref()
  }

  pub fn reset_used_node_count(&mut self) {
    self.used_node_count = None;
  }

  pub fn set_used_nodes_with_seds_count(&mut self, used_nodes_with_seds_count: i32) {
    self.used_nodes_with_seds_count = Some(used_nodes_with_seds_count);
  }

  pub fn with_used_nodes_with_seds_count(mut self, used_nodes_with_seds_count: i32) -> LicenseLicenseTier {
    self.used_nodes_with_seds_count = Some(used_nodes_with_seds_count);
    self
  }

  pub fn used_nodes_with_seds_count(&self) -> Option<&i32> {
    self.used_nodes_with_seds_count.as_ref()
  }

  pub fn reset_used_nodes_with_seds_count(&mut self) {
    self.used_nodes_with_seds_count = None;
  }

}



