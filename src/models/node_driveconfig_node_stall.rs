/* 
 * Isilon SDK
 *
 * Isilon SDK - Language bindings for the OneFS API
 *
 * OpenAPI spec version: 5
 * Contact: sdk@isilon.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */


#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct NodeDriveconfigNodeStall {
  /// The amount of time in seconds with no stalls before ignoring previous stalls.
  #[serde(rename = "clear_time")]
  clear_time: Option<i32>,
  /// Number of stripes to read during a diskscrub.
  #[serde(rename = "diskscrub_stripes")]
  diskscrub_stripes: Option<i32>,
  /// The number of errors during stalled drive disk exercises to cause the drive to be softfailed.
  #[serde(rename = "max_error_frequency")]
  max_error_frequency: Option<i32>,
  /// The number of slow accesses during stalled drive disk exercises to cause the drive to be softfailed.
  #[serde(rename = "max_slow_access")]
  max_slow_access: Option<i32>,
  /// The number of slow frequency triggers during stalled drive disk exercises to cause the drive to be softfailed.
  #[serde(rename = "max_slow_frequency")]
  max_slow_frequency: Option<i32>,
  /// The maximum amount of time, in seconds, to remain stalled before softfailing the drive.
  #[serde(rename = "max_total_stall_time")]
  max_total_stall_time: Option<i32>,
  /// Maximum delay in seconds after an ECC correction during a scan.
  #[serde(rename = "scan_max_ecc_delay")]
  scan_max_ecc_delay: Option<i32>,
  /// Total bytes of error-free reads to complete a scan.
  #[serde(rename = "scan_size")]
  scan_size: Option<i32>,
  /// Delay in seconds between evaluations.
  #[serde(rename = "sleep")]
  sleep: Option<i32>
}

impl NodeDriveconfigNodeStall {
  pub fn new() -> NodeDriveconfigNodeStall {
    NodeDriveconfigNodeStall {
      clear_time: None,
      diskscrub_stripes: None,
      max_error_frequency: None,
      max_slow_access: None,
      max_slow_frequency: None,
      max_total_stall_time: None,
      scan_max_ecc_delay: None,
      scan_size: None,
      sleep: None
    }
  }

  pub fn set_clear_time(&mut self, clear_time: i32) {
    self.clear_time = Some(clear_time);
  }

  pub fn with_clear_time(mut self, clear_time: i32) -> NodeDriveconfigNodeStall {
    self.clear_time = Some(clear_time);
    self
  }

  pub fn clear_time(&self) -> Option<&i32> {
    self.clear_time.as_ref()
  }

  pub fn reset_clear_time(&mut self) {
    self.clear_time = None;
  }

  pub fn set_diskscrub_stripes(&mut self, diskscrub_stripes: i32) {
    self.diskscrub_stripes = Some(diskscrub_stripes);
  }

  pub fn with_diskscrub_stripes(mut self, diskscrub_stripes: i32) -> NodeDriveconfigNodeStall {
    self.diskscrub_stripes = Some(diskscrub_stripes);
    self
  }

  pub fn diskscrub_stripes(&self) -> Option<&i32> {
    self.diskscrub_stripes.as_ref()
  }

  pub fn reset_diskscrub_stripes(&mut self) {
    self.diskscrub_stripes = None;
  }

  pub fn set_max_error_frequency(&mut self, max_error_frequency: i32) {
    self.max_error_frequency = Some(max_error_frequency);
  }

  pub fn with_max_error_frequency(mut self, max_error_frequency: i32) -> NodeDriveconfigNodeStall {
    self.max_error_frequency = Some(max_error_frequency);
    self
  }

  pub fn max_error_frequency(&self) -> Option<&i32> {
    self.max_error_frequency.as_ref()
  }

  pub fn reset_max_error_frequency(&mut self) {
    self.max_error_frequency = None;
  }

  pub fn set_max_slow_access(&mut self, max_slow_access: i32) {
    self.max_slow_access = Some(max_slow_access);
  }

  pub fn with_max_slow_access(mut self, max_slow_access: i32) -> NodeDriveconfigNodeStall {
    self.max_slow_access = Some(max_slow_access);
    self
  }

  pub fn max_slow_access(&self) -> Option<&i32> {
    self.max_slow_access.as_ref()
  }

  pub fn reset_max_slow_access(&mut self) {
    self.max_slow_access = None;
  }

  pub fn set_max_slow_frequency(&mut self, max_slow_frequency: i32) {
    self.max_slow_frequency = Some(max_slow_frequency);
  }

  pub fn with_max_slow_frequency(mut self, max_slow_frequency: i32) -> NodeDriveconfigNodeStall {
    self.max_slow_frequency = Some(max_slow_frequency);
    self
  }

  pub fn max_slow_frequency(&self) -> Option<&i32> {
    self.max_slow_frequency.as_ref()
  }

  pub fn reset_max_slow_frequency(&mut self) {
    self.max_slow_frequency = None;
  }

  pub fn set_max_total_stall_time(&mut self, max_total_stall_time: i32) {
    self.max_total_stall_time = Some(max_total_stall_time);
  }

  pub fn with_max_total_stall_time(mut self, max_total_stall_time: i32) -> NodeDriveconfigNodeStall {
    self.max_total_stall_time = Some(max_total_stall_time);
    self
  }

  pub fn max_total_stall_time(&self) -> Option<&i32> {
    self.max_total_stall_time.as_ref()
  }

  pub fn reset_max_total_stall_time(&mut self) {
    self.max_total_stall_time = None;
  }

  pub fn set_scan_max_ecc_delay(&mut self, scan_max_ecc_delay: i32) {
    self.scan_max_ecc_delay = Some(scan_max_ecc_delay);
  }

  pub fn with_scan_max_ecc_delay(mut self, scan_max_ecc_delay: i32) -> NodeDriveconfigNodeStall {
    self.scan_max_ecc_delay = Some(scan_max_ecc_delay);
    self
  }

  pub fn scan_max_ecc_delay(&self) -> Option<&i32> {
    self.scan_max_ecc_delay.as_ref()
  }

  pub fn reset_scan_max_ecc_delay(&mut self) {
    self.scan_max_ecc_delay = None;
  }

  pub fn set_scan_size(&mut self, scan_size: i32) {
    self.scan_size = Some(scan_size);
  }

  pub fn with_scan_size(mut self, scan_size: i32) -> NodeDriveconfigNodeStall {
    self.scan_size = Some(scan_size);
    self
  }

  pub fn scan_size(&self) -> Option<&i32> {
    self.scan_size.as_ref()
  }

  pub fn reset_scan_size(&mut self) {
    self.scan_size = None;
  }

  pub fn set_sleep(&mut self, sleep: i32) {
    self.sleep = Some(sleep);
  }

  pub fn with_sleep(mut self, sleep: i32) -> NodeDriveconfigNodeStall {
    self.sleep = Some(sleep);
    self
  }

  pub fn sleep(&self) -> Option<&i32> {
    self.sleep.as_ref()
  }

  pub fn reset_sleep(&mut self) {
    self.sleep = None;
  }

}



