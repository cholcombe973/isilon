/* 
 * Isilon SDK
 *
 * Isilon SDK - Language bindings for the OneFS API
 *
 * OpenAPI spec version: 5
 * Contact: sdk@isilon.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

/// ClusterConfig : General cluster information.

#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct ClusterConfig {
  /// Customer configurable description.
  #[serde(rename = "description")]
  description: String,
  #[serde(rename = "devices")]
  devices: Vec<::models::ClusterConfigDevice>,
  /// Default encoding.
  #[serde(rename = "encoding")]
  encoding: String,
  /// Cluster GUID.
  #[serde(rename = "guid")]
  guid: String,
  /// If true, the local node is in a group with quorum: It is communicating, storing, and protecting data normally with other nodes in its group.  Under normal circumstances, every node in the cluster is part of one group.
  #[serde(rename = "has_quorum")]
  has_quorum: bool,
  /// If true, the cluster is in compliance mode.  Compliance mode clusters do not allow root access and have stricter WORM (Write Once Read Many) features for retaining data in compliance with U.S. Securities and Exchange Commission rule 17a-4.
  #[serde(rename = "is_compliance")]
  is_compliance: bool,
  /// true if the cluster is deployed on a desktop VMWorkstation
  #[serde(rename = "is_virtual")]
  is_virtual: bool,
  /// true if this is a vOneFS cluster on an ESXi
  #[serde(rename = "is_vonefs")]
  is_vonefs: bool,
  /// Node join mode: 'manual' or 'secure'.
  #[serde(rename = "join_mode")]
  join_mode: String,
  /// Device ID of the queried node.
  #[serde(rename = "local_devid")]
  local_devid: i32,
  /// Device logical node number of the queried node.
  #[serde(rename = "local_lnn")]
  local_lnn: i32,
  /// Device serial number of the queried node.
  #[serde(rename = "local_serial")]
  local_serial: String,
  /// Cluster name.
  #[serde(rename = "name")]
  name: String,
  /// 
  #[serde(rename = "onefs_version")]
  onefs_version: Option<::models::ClusterConfigOnefsVersion>,
  /// The cluster timezone settings.
  #[serde(rename = "timezone")]
  timezone: Option<::models::ClusterConfigTimezone>,
  #[serde(rename = "upgrade_type")]
  upgrade_type: Option<String>
}

impl ClusterConfig {
  /// General cluster information.
  pub fn new(description: String, devices: Vec<::models::ClusterConfigDevice>, encoding: String, guid: String, has_quorum: bool, is_compliance: bool, is_virtual: bool, is_vonefs: bool, join_mode: String, local_devid: i32, local_lnn: i32, local_serial: String, name: String) -> ClusterConfig {
    ClusterConfig {
      description: description,
      devices: devices,
      encoding: encoding,
      guid: guid,
      has_quorum: has_quorum,
      is_compliance: is_compliance,
      is_virtual: is_virtual,
      is_vonefs: is_vonefs,
      join_mode: join_mode,
      local_devid: local_devid,
      local_lnn: local_lnn,
      local_serial: local_serial,
      name: name,
      onefs_version: None,
      timezone: None,
      upgrade_type: None
    }
  }

  pub fn set_description(&mut self, description: String) {
    self.description = description;
  }

  pub fn with_description(mut self, description: String) -> ClusterConfig {
    self.description = description;
    self
  }

  pub fn description(&self) -> &String {
    &self.description
  }


  pub fn set_devices(&mut self, devices: Vec<::models::ClusterConfigDevice>) {
    self.devices = devices;
  }

  pub fn with_devices(mut self, devices: Vec<::models::ClusterConfigDevice>) -> ClusterConfig {
    self.devices = devices;
    self
  }

  pub fn devices(&self) -> &Vec<::models::ClusterConfigDevice> {
    &self.devices
  }


  pub fn set_encoding(&mut self, encoding: String) {
    self.encoding = encoding;
  }

  pub fn with_encoding(mut self, encoding: String) -> ClusterConfig {
    self.encoding = encoding;
    self
  }

  pub fn encoding(&self) -> &String {
    &self.encoding
  }


  pub fn set_guid(&mut self, guid: String) {
    self.guid = guid;
  }

  pub fn with_guid(mut self, guid: String) -> ClusterConfig {
    self.guid = guid;
    self
  }

  pub fn guid(&self) -> &String {
    &self.guid
  }


  pub fn set_has_quorum(&mut self, has_quorum: bool) {
    self.has_quorum = has_quorum;
  }

  pub fn with_has_quorum(mut self, has_quorum: bool) -> ClusterConfig {
    self.has_quorum = has_quorum;
    self
  }

  pub fn has_quorum(&self) -> &bool {
    &self.has_quorum
  }


  pub fn set_is_compliance(&mut self, is_compliance: bool) {
    self.is_compliance = is_compliance;
  }

  pub fn with_is_compliance(mut self, is_compliance: bool) -> ClusterConfig {
    self.is_compliance = is_compliance;
    self
  }

  pub fn is_compliance(&self) -> &bool {
    &self.is_compliance
  }


  pub fn set_is_virtual(&mut self, is_virtual: bool) {
    self.is_virtual = is_virtual;
  }

  pub fn with_is_virtual(mut self, is_virtual: bool) -> ClusterConfig {
    self.is_virtual = is_virtual;
    self
  }

  pub fn is_virtual(&self) -> &bool {
    &self.is_virtual
  }


  pub fn set_is_vonefs(&mut self, is_vonefs: bool) {
    self.is_vonefs = is_vonefs;
  }

  pub fn with_is_vonefs(mut self, is_vonefs: bool) -> ClusterConfig {
    self.is_vonefs = is_vonefs;
    self
  }

  pub fn is_vonefs(&self) -> &bool {
    &self.is_vonefs
  }


  pub fn set_join_mode(&mut self, join_mode: String) {
    self.join_mode = join_mode;
  }

  pub fn with_join_mode(mut self, join_mode: String) -> ClusterConfig {
    self.join_mode = join_mode;
    self
  }

  pub fn join_mode(&self) -> &String {
    &self.join_mode
  }


  pub fn set_local_devid(&mut self, local_devid: i32) {
    self.local_devid = local_devid;
  }

  pub fn with_local_devid(mut self, local_devid: i32) -> ClusterConfig {
    self.local_devid = local_devid;
    self
  }

  pub fn local_devid(&self) -> &i32 {
    &self.local_devid
  }


  pub fn set_local_lnn(&mut self, local_lnn: i32) {
    self.local_lnn = local_lnn;
  }

  pub fn with_local_lnn(mut self, local_lnn: i32) -> ClusterConfig {
    self.local_lnn = local_lnn;
    self
  }

  pub fn local_lnn(&self) -> &i32 {
    &self.local_lnn
  }


  pub fn set_local_serial(&mut self, local_serial: String) {
    self.local_serial = local_serial;
  }

  pub fn with_local_serial(mut self, local_serial: String) -> ClusterConfig {
    self.local_serial = local_serial;
    self
  }

  pub fn local_serial(&self) -> &String {
    &self.local_serial
  }


  pub fn set_name(&mut self, name: String) {
    self.name = name;
  }

  pub fn with_name(mut self, name: String) -> ClusterConfig {
    self.name = name;
    self
  }

  pub fn name(&self) -> &String {
    &self.name
  }


  pub fn set_onefs_version(&mut self, onefs_version: ::models::ClusterConfigOnefsVersion) {
    self.onefs_version = Some(onefs_version);
  }

  pub fn with_onefs_version(mut self, onefs_version: ::models::ClusterConfigOnefsVersion) -> ClusterConfig {
    self.onefs_version = Some(onefs_version);
    self
  }

  pub fn onefs_version(&self) -> Option<&::models::ClusterConfigOnefsVersion> {
    self.onefs_version.as_ref()
  }

  pub fn reset_onefs_version(&mut self) {
    self.onefs_version = None;
  }

  pub fn set_timezone(&mut self, timezone: ::models::ClusterConfigTimezone) {
    self.timezone = Some(timezone);
  }

  pub fn with_timezone(mut self, timezone: ::models::ClusterConfigTimezone) -> ClusterConfig {
    self.timezone = Some(timezone);
    self
  }

  pub fn timezone(&self) -> Option<&::models::ClusterConfigTimezone> {
    self.timezone.as_ref()
  }

  pub fn reset_timezone(&mut self) {
    self.timezone = None;
  }

  pub fn set_upgrade_type(&mut self, upgrade_type: String) {
    self.upgrade_type = Some(upgrade_type);
  }

  pub fn with_upgrade_type(mut self, upgrade_type: String) -> ClusterConfig {
    self.upgrade_type = Some(upgrade_type);
    self
  }

  pub fn upgrade_type(&self) -> Option<&String> {
    self.upgrade_type.as_ref()
  }

  pub fn reset_upgrade_type(&mut self) {
    self.upgrade_type = None;
  }

}



