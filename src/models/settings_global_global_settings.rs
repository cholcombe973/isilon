/* 
 * Isilon SDK
 *
 * Isilon SDK - Language bindings for the OneFS API
 *
 * OpenAPI spec version: 5
 * Contact: sdk@isilon.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */


#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct SettingsGlobalGlobalSettings {
  /// Specifies the number of times to retry an ID allocation before failing.
  #[serde(rename = "alloc_retries")]
  alloc_retries: Option<i32>,
  /// If true, allocates GIDs from a fixed range.
  #[serde(rename = "gid_range_enabled")]
  gid_range_enabled: Option<bool>,
  /// Specifies the ending number for a fixed range from which GIDs are allocated.
  #[serde(rename = "gid_range_max")]
  gid_range_max: Option<i32>,
  /// Specifies the starting number for a fixed range from which GIDs are allocated.
  #[serde(rename = "gid_range_min")]
  gid_range_min: Option<i32>,
  /// Specifies the next GID to allocate.
  #[serde(rename = "gid_range_next")]
  gid_range_next: Option<i32>,
  /// Specifies the user iD for a group when requested by the kernel.
  #[serde(rename = "group_uid")]
  group_uid: Option<i32>,
  /// Specifies which providers are loaded by the authentication daemon (lsassd).
  #[serde(rename = "load_providers")]
  load_providers: Option<Vec<String>>,
  /// Starts the RID in the local domain to map a UID and a GID.
  #[serde(rename = "min_mapped_rid")]
  min_mapped_rid: Option<i32>,
  /// Specifies an alternative GID when the kernel is unable to retrieve a GID for a persona.
  #[serde(rename = "null_gid")]
  null_gid: Option<i32>,
  /// Specifies an alternative UID when the kernel is unable to retrieve a UID for a persona.
  #[serde(rename = "null_uid")]
  null_uid: Option<i32>,
  /// Specifies the type of identity that is stored on disk.
  #[serde(rename = "on_disk_identity")]
  on_disk_identity: Option<String>,
  /// Specifies the minimum amount of time in milliseconds to wait before performing an oprestart.
  #[serde(rename = "rpc_block_time")]
  rpc_block_time: Option<i32>,
  /// Specifies the maximum number of outstanding RPC requests.
  #[serde(rename = "rpc_max_requests")]
  rpc_max_requests: Option<i32>,
  /// Specifies the maximum amount of time in seconds to wait for an idmap response.
  #[serde(rename = "rpc_timeout")]
  rpc_timeout: Option<i32>,
  /// If true, sends NTLMv2 responses.
  #[serde(rename = "send_ntlmv2")]
  send_ntlmv2: Option<bool>,
  /// Specifies the space replacement character.
  #[serde(rename = "space_replacement")]
  space_replacement: Option<String>,
  /// Specifies the minimum GID to attempt to look up in the idmap database.
  #[serde(rename = "system_gid_threshold")]
  system_gid_threshold: Option<i32>,
  /// Specifies the minimum UID to attempt to look up in the idmap database.
  #[serde(rename = "system_uid_threshold")]
  system_uid_threshold: Option<i32>,
  /// If true, allocates UIDs from a fixed range.
  #[serde(rename = "uid_range_enabled")]
  uid_range_enabled: Option<bool>,
  /// Specifies the ending number for a fixed range from which UIDs are allocated.
  #[serde(rename = "uid_range_max")]
  uid_range_max: Option<i32>,
  /// Specifies the starting number for a fixed range from which UIDs are allocated.
  #[serde(rename = "uid_range_min")]
  uid_range_min: Option<i32>,
  /// Specifies the next UID to allocate.
  #[serde(rename = "uid_range_next")]
  uid_range_next: Option<i32>,
  /// Specifies the GID for the unknown (anonymous) group.
  #[serde(rename = "unknown_gid")]
  unknown_gid: Option<i32>,
  /// Specifies the UID for the unknown (anonymous) user.
  #[serde(rename = "unknown_uid")]
  unknown_uid: Option<i32>,
  /// Specifies the maximum size (in bytes) of the security object cache in the authentication daemon.
  #[serde(rename = "user_object_cache_size")]
  user_object_cache_size: Option<i32>,
  /// Specifies the NetBIOS workgroup or domain.
  #[serde(rename = "workgroup")]
  workgroup: Option<String>
}

impl SettingsGlobalGlobalSettings {
  pub fn new() -> SettingsGlobalGlobalSettings {
    SettingsGlobalGlobalSettings {
      alloc_retries: None,
      gid_range_enabled: None,
      gid_range_max: None,
      gid_range_min: None,
      gid_range_next: None,
      group_uid: None,
      load_providers: None,
      min_mapped_rid: None,
      null_gid: None,
      null_uid: None,
      on_disk_identity: None,
      rpc_block_time: None,
      rpc_max_requests: None,
      rpc_timeout: None,
      send_ntlmv2: None,
      space_replacement: None,
      system_gid_threshold: None,
      system_uid_threshold: None,
      uid_range_enabled: None,
      uid_range_max: None,
      uid_range_min: None,
      uid_range_next: None,
      unknown_gid: None,
      unknown_uid: None,
      user_object_cache_size: None,
      workgroup: None
    }
  }

  pub fn set_alloc_retries(&mut self, alloc_retries: i32) {
    self.alloc_retries = Some(alloc_retries);
  }

  pub fn with_alloc_retries(mut self, alloc_retries: i32) -> SettingsGlobalGlobalSettings {
    self.alloc_retries = Some(alloc_retries);
    self
  }

  pub fn alloc_retries(&self) -> Option<&i32> {
    self.alloc_retries.as_ref()
  }

  pub fn reset_alloc_retries(&mut self) {
    self.alloc_retries = None;
  }

  pub fn set_gid_range_enabled(&mut self, gid_range_enabled: bool) {
    self.gid_range_enabled = Some(gid_range_enabled);
  }

  pub fn with_gid_range_enabled(mut self, gid_range_enabled: bool) -> SettingsGlobalGlobalSettings {
    self.gid_range_enabled = Some(gid_range_enabled);
    self
  }

  pub fn gid_range_enabled(&self) -> Option<&bool> {
    self.gid_range_enabled.as_ref()
  }

  pub fn reset_gid_range_enabled(&mut self) {
    self.gid_range_enabled = None;
  }

  pub fn set_gid_range_max(&mut self, gid_range_max: i32) {
    self.gid_range_max = Some(gid_range_max);
  }

  pub fn with_gid_range_max(mut self, gid_range_max: i32) -> SettingsGlobalGlobalSettings {
    self.gid_range_max = Some(gid_range_max);
    self
  }

  pub fn gid_range_max(&self) -> Option<&i32> {
    self.gid_range_max.as_ref()
  }

  pub fn reset_gid_range_max(&mut self) {
    self.gid_range_max = None;
  }

  pub fn set_gid_range_min(&mut self, gid_range_min: i32) {
    self.gid_range_min = Some(gid_range_min);
  }

  pub fn with_gid_range_min(mut self, gid_range_min: i32) -> SettingsGlobalGlobalSettings {
    self.gid_range_min = Some(gid_range_min);
    self
  }

  pub fn gid_range_min(&self) -> Option<&i32> {
    self.gid_range_min.as_ref()
  }

  pub fn reset_gid_range_min(&mut self) {
    self.gid_range_min = None;
  }

  pub fn set_gid_range_next(&mut self, gid_range_next: i32) {
    self.gid_range_next = Some(gid_range_next);
  }

  pub fn with_gid_range_next(mut self, gid_range_next: i32) -> SettingsGlobalGlobalSettings {
    self.gid_range_next = Some(gid_range_next);
    self
  }

  pub fn gid_range_next(&self) -> Option<&i32> {
    self.gid_range_next.as_ref()
  }

  pub fn reset_gid_range_next(&mut self) {
    self.gid_range_next = None;
  }

  pub fn set_group_uid(&mut self, group_uid: i32) {
    self.group_uid = Some(group_uid);
  }

  pub fn with_group_uid(mut self, group_uid: i32) -> SettingsGlobalGlobalSettings {
    self.group_uid = Some(group_uid);
    self
  }

  pub fn group_uid(&self) -> Option<&i32> {
    self.group_uid.as_ref()
  }

  pub fn reset_group_uid(&mut self) {
    self.group_uid = None;
  }

  pub fn set_load_providers(&mut self, load_providers: Vec<String>) {
    self.load_providers = Some(load_providers);
  }

  pub fn with_load_providers(mut self, load_providers: Vec<String>) -> SettingsGlobalGlobalSettings {
    self.load_providers = Some(load_providers);
    self
  }

  pub fn load_providers(&self) -> Option<&Vec<String>> {
    self.load_providers.as_ref()
  }

  pub fn reset_load_providers(&mut self) {
    self.load_providers = None;
  }

  pub fn set_min_mapped_rid(&mut self, min_mapped_rid: i32) {
    self.min_mapped_rid = Some(min_mapped_rid);
  }

  pub fn with_min_mapped_rid(mut self, min_mapped_rid: i32) -> SettingsGlobalGlobalSettings {
    self.min_mapped_rid = Some(min_mapped_rid);
    self
  }

  pub fn min_mapped_rid(&self) -> Option<&i32> {
    self.min_mapped_rid.as_ref()
  }

  pub fn reset_min_mapped_rid(&mut self) {
    self.min_mapped_rid = None;
  }

  pub fn set_null_gid(&mut self, null_gid: i32) {
    self.null_gid = Some(null_gid);
  }

  pub fn with_null_gid(mut self, null_gid: i32) -> SettingsGlobalGlobalSettings {
    self.null_gid = Some(null_gid);
    self
  }

  pub fn null_gid(&self) -> Option<&i32> {
    self.null_gid.as_ref()
  }

  pub fn reset_null_gid(&mut self) {
    self.null_gid = None;
  }

  pub fn set_null_uid(&mut self, null_uid: i32) {
    self.null_uid = Some(null_uid);
  }

  pub fn with_null_uid(mut self, null_uid: i32) -> SettingsGlobalGlobalSettings {
    self.null_uid = Some(null_uid);
    self
  }

  pub fn null_uid(&self) -> Option<&i32> {
    self.null_uid.as_ref()
  }

  pub fn reset_null_uid(&mut self) {
    self.null_uid = None;
  }

  pub fn set_on_disk_identity(&mut self, on_disk_identity: String) {
    self.on_disk_identity = Some(on_disk_identity);
  }

  pub fn with_on_disk_identity(mut self, on_disk_identity: String) -> SettingsGlobalGlobalSettings {
    self.on_disk_identity = Some(on_disk_identity);
    self
  }

  pub fn on_disk_identity(&self) -> Option<&String> {
    self.on_disk_identity.as_ref()
  }

  pub fn reset_on_disk_identity(&mut self) {
    self.on_disk_identity = None;
  }

  pub fn set_rpc_block_time(&mut self, rpc_block_time: i32) {
    self.rpc_block_time = Some(rpc_block_time);
  }

  pub fn with_rpc_block_time(mut self, rpc_block_time: i32) -> SettingsGlobalGlobalSettings {
    self.rpc_block_time = Some(rpc_block_time);
    self
  }

  pub fn rpc_block_time(&self) -> Option<&i32> {
    self.rpc_block_time.as_ref()
  }

  pub fn reset_rpc_block_time(&mut self) {
    self.rpc_block_time = None;
  }

  pub fn set_rpc_max_requests(&mut self, rpc_max_requests: i32) {
    self.rpc_max_requests = Some(rpc_max_requests);
  }

  pub fn with_rpc_max_requests(mut self, rpc_max_requests: i32) -> SettingsGlobalGlobalSettings {
    self.rpc_max_requests = Some(rpc_max_requests);
    self
  }

  pub fn rpc_max_requests(&self) -> Option<&i32> {
    self.rpc_max_requests.as_ref()
  }

  pub fn reset_rpc_max_requests(&mut self) {
    self.rpc_max_requests = None;
  }

  pub fn set_rpc_timeout(&mut self, rpc_timeout: i32) {
    self.rpc_timeout = Some(rpc_timeout);
  }

  pub fn with_rpc_timeout(mut self, rpc_timeout: i32) -> SettingsGlobalGlobalSettings {
    self.rpc_timeout = Some(rpc_timeout);
    self
  }

  pub fn rpc_timeout(&self) -> Option<&i32> {
    self.rpc_timeout.as_ref()
  }

  pub fn reset_rpc_timeout(&mut self) {
    self.rpc_timeout = None;
  }

  pub fn set_send_ntlmv2(&mut self, send_ntlmv2: bool) {
    self.send_ntlmv2 = Some(send_ntlmv2);
  }

  pub fn with_send_ntlmv2(mut self, send_ntlmv2: bool) -> SettingsGlobalGlobalSettings {
    self.send_ntlmv2 = Some(send_ntlmv2);
    self
  }

  pub fn send_ntlmv2(&self) -> Option<&bool> {
    self.send_ntlmv2.as_ref()
  }

  pub fn reset_send_ntlmv2(&mut self) {
    self.send_ntlmv2 = None;
  }

  pub fn set_space_replacement(&mut self, space_replacement: String) {
    self.space_replacement = Some(space_replacement);
  }

  pub fn with_space_replacement(mut self, space_replacement: String) -> SettingsGlobalGlobalSettings {
    self.space_replacement = Some(space_replacement);
    self
  }

  pub fn space_replacement(&self) -> Option<&String> {
    self.space_replacement.as_ref()
  }

  pub fn reset_space_replacement(&mut self) {
    self.space_replacement = None;
  }

  pub fn set_system_gid_threshold(&mut self, system_gid_threshold: i32) {
    self.system_gid_threshold = Some(system_gid_threshold);
  }

  pub fn with_system_gid_threshold(mut self, system_gid_threshold: i32) -> SettingsGlobalGlobalSettings {
    self.system_gid_threshold = Some(system_gid_threshold);
    self
  }

  pub fn system_gid_threshold(&self) -> Option<&i32> {
    self.system_gid_threshold.as_ref()
  }

  pub fn reset_system_gid_threshold(&mut self) {
    self.system_gid_threshold = None;
  }

  pub fn set_system_uid_threshold(&mut self, system_uid_threshold: i32) {
    self.system_uid_threshold = Some(system_uid_threshold);
  }

  pub fn with_system_uid_threshold(mut self, system_uid_threshold: i32) -> SettingsGlobalGlobalSettings {
    self.system_uid_threshold = Some(system_uid_threshold);
    self
  }

  pub fn system_uid_threshold(&self) -> Option<&i32> {
    self.system_uid_threshold.as_ref()
  }

  pub fn reset_system_uid_threshold(&mut self) {
    self.system_uid_threshold = None;
  }

  pub fn set_uid_range_enabled(&mut self, uid_range_enabled: bool) {
    self.uid_range_enabled = Some(uid_range_enabled);
  }

  pub fn with_uid_range_enabled(mut self, uid_range_enabled: bool) -> SettingsGlobalGlobalSettings {
    self.uid_range_enabled = Some(uid_range_enabled);
    self
  }

  pub fn uid_range_enabled(&self) -> Option<&bool> {
    self.uid_range_enabled.as_ref()
  }

  pub fn reset_uid_range_enabled(&mut self) {
    self.uid_range_enabled = None;
  }

  pub fn set_uid_range_max(&mut self, uid_range_max: i32) {
    self.uid_range_max = Some(uid_range_max);
  }

  pub fn with_uid_range_max(mut self, uid_range_max: i32) -> SettingsGlobalGlobalSettings {
    self.uid_range_max = Some(uid_range_max);
    self
  }

  pub fn uid_range_max(&self) -> Option<&i32> {
    self.uid_range_max.as_ref()
  }

  pub fn reset_uid_range_max(&mut self) {
    self.uid_range_max = None;
  }

  pub fn set_uid_range_min(&mut self, uid_range_min: i32) {
    self.uid_range_min = Some(uid_range_min);
  }

  pub fn with_uid_range_min(mut self, uid_range_min: i32) -> SettingsGlobalGlobalSettings {
    self.uid_range_min = Some(uid_range_min);
    self
  }

  pub fn uid_range_min(&self) -> Option<&i32> {
    self.uid_range_min.as_ref()
  }

  pub fn reset_uid_range_min(&mut self) {
    self.uid_range_min = None;
  }

  pub fn set_uid_range_next(&mut self, uid_range_next: i32) {
    self.uid_range_next = Some(uid_range_next);
  }

  pub fn with_uid_range_next(mut self, uid_range_next: i32) -> SettingsGlobalGlobalSettings {
    self.uid_range_next = Some(uid_range_next);
    self
  }

  pub fn uid_range_next(&self) -> Option<&i32> {
    self.uid_range_next.as_ref()
  }

  pub fn reset_uid_range_next(&mut self) {
    self.uid_range_next = None;
  }

  pub fn set_unknown_gid(&mut self, unknown_gid: i32) {
    self.unknown_gid = Some(unknown_gid);
  }

  pub fn with_unknown_gid(mut self, unknown_gid: i32) -> SettingsGlobalGlobalSettings {
    self.unknown_gid = Some(unknown_gid);
    self
  }

  pub fn unknown_gid(&self) -> Option<&i32> {
    self.unknown_gid.as_ref()
  }

  pub fn reset_unknown_gid(&mut self) {
    self.unknown_gid = None;
  }

  pub fn set_unknown_uid(&mut self, unknown_uid: i32) {
    self.unknown_uid = Some(unknown_uid);
  }

  pub fn with_unknown_uid(mut self, unknown_uid: i32) -> SettingsGlobalGlobalSettings {
    self.unknown_uid = Some(unknown_uid);
    self
  }

  pub fn unknown_uid(&self) -> Option<&i32> {
    self.unknown_uid.as_ref()
  }

  pub fn reset_unknown_uid(&mut self) {
    self.unknown_uid = None;
  }

  pub fn set_user_object_cache_size(&mut self, user_object_cache_size: i32) {
    self.user_object_cache_size = Some(user_object_cache_size);
  }

  pub fn with_user_object_cache_size(mut self, user_object_cache_size: i32) -> SettingsGlobalGlobalSettings {
    self.user_object_cache_size = Some(user_object_cache_size);
    self
  }

  pub fn user_object_cache_size(&self) -> Option<&i32> {
    self.user_object_cache_size.as_ref()
  }

  pub fn reset_user_object_cache_size(&mut self) {
    self.user_object_cache_size = None;
  }

  pub fn set_workgroup(&mut self, workgroup: String) {
    self.workgroup = Some(workgroup);
  }

  pub fn with_workgroup(mut self, workgroup: String) -> SettingsGlobalGlobalSettings {
    self.workgroup = Some(workgroup);
    self
  }

  pub fn workgroup(&self) -> Option<&String> {
    self.workgroup.as_ref()
  }

  pub fn reset_workgroup(&mut self) {
    self.workgroup = None;
  }

}



