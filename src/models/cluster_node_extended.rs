/* 
 * Isilon SDK
 *
 * Isilon SDK - Language bindings for the OneFS API
 *
 * OpenAPI spec version: 5
 * Contact: sdk@isilon.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */


#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct ClusterNodeExtended {
  /// An object containing a node's drive subsystem XML configuration file.
  #[serde(rename = "drive_d_config")]
  drive_d_config: Option<::models::ClusterNodeDriveDConfig>,
  /// List of the drives in this node.
  #[serde(rename = "drives")]
  drives: Option<Vec<::models::NodeDrivesNodeDrive>>,
  /// Node hardware identifying information (static).
  #[serde(rename = "hardware")]
  hardware: Option<::models::ClusterNodeHardware>,
  /// Node ID (Device Number) of this node.
  #[serde(rename = "id")]
  id: Option<i32>,
  /// Logical Node Number (LNN) of this node.
  #[serde(rename = "lnn")]
  lnn: Option<i32>,
  /// Node partition information.
  #[serde(rename = "partitions")]
  partitions: Option<::models::ClusterNodePartitions>,
  /// Node sensor information (hardware reported).
  #[serde(rename = "sensors")]
  sensors: Option<::models::ClusterNodeSensors>,
  /// List of the sleds in this node.
  #[serde(rename = "sleds")]
  sleds: Option<Vec<::models::NodeSledsNodeSled>>,
  /// Node state information (reported and modifiable).
  #[serde(rename = "state")]
  state: Option<::models::ClusterNodeStateExtended>,
  /// Node status information (hardware reported).
  #[serde(rename = "status")]
  status: Option<::models::ClusterNodeStatus>
}

impl ClusterNodeExtended {
  pub fn new() -> ClusterNodeExtended {
    ClusterNodeExtended {
      drive_d_config: None,
      drives: None,
      hardware: None,
      id: None,
      lnn: None,
      partitions: None,
      sensors: None,
      sleds: None,
      state: None,
      status: None
    }
  }

  pub fn set_drive_d_config(&mut self, drive_d_config: ::models::ClusterNodeDriveDConfig) {
    self.drive_d_config = Some(drive_d_config);
  }

  pub fn with_drive_d_config(mut self, drive_d_config: ::models::ClusterNodeDriveDConfig) -> ClusterNodeExtended {
    self.drive_d_config = Some(drive_d_config);
    self
  }

  pub fn drive_d_config(&self) -> Option<&::models::ClusterNodeDriveDConfig> {
    self.drive_d_config.as_ref()
  }

  pub fn reset_drive_d_config(&mut self) {
    self.drive_d_config = None;
  }

  pub fn set_drives(&mut self, drives: Vec<::models::NodeDrivesNodeDrive>) {
    self.drives = Some(drives);
  }

  pub fn with_drives(mut self, drives: Vec<::models::NodeDrivesNodeDrive>) -> ClusterNodeExtended {
    self.drives = Some(drives);
    self
  }

  pub fn drives(&self) -> Option<&Vec<::models::NodeDrivesNodeDrive>> {
    self.drives.as_ref()
  }

  pub fn reset_drives(&mut self) {
    self.drives = None;
  }

  pub fn set_hardware(&mut self, hardware: ::models::ClusterNodeHardware) {
    self.hardware = Some(hardware);
  }

  pub fn with_hardware(mut self, hardware: ::models::ClusterNodeHardware) -> ClusterNodeExtended {
    self.hardware = Some(hardware);
    self
  }

  pub fn hardware(&self) -> Option<&::models::ClusterNodeHardware> {
    self.hardware.as_ref()
  }

  pub fn reset_hardware(&mut self) {
    self.hardware = None;
  }

  pub fn set_id(&mut self, id: i32) {
    self.id = Some(id);
  }

  pub fn with_id(mut self, id: i32) -> ClusterNodeExtended {
    self.id = Some(id);
    self
  }

  pub fn id(&self) -> Option<&i32> {
    self.id.as_ref()
  }

  pub fn reset_id(&mut self) {
    self.id = None;
  }

  pub fn set_lnn(&mut self, lnn: i32) {
    self.lnn = Some(lnn);
  }

  pub fn with_lnn(mut self, lnn: i32) -> ClusterNodeExtended {
    self.lnn = Some(lnn);
    self
  }

  pub fn lnn(&self) -> Option<&i32> {
    self.lnn.as_ref()
  }

  pub fn reset_lnn(&mut self) {
    self.lnn = None;
  }

  pub fn set_partitions(&mut self, partitions: ::models::ClusterNodePartitions) {
    self.partitions = Some(partitions);
  }

  pub fn with_partitions(mut self, partitions: ::models::ClusterNodePartitions) -> ClusterNodeExtended {
    self.partitions = Some(partitions);
    self
  }

  pub fn partitions(&self) -> Option<&::models::ClusterNodePartitions> {
    self.partitions.as_ref()
  }

  pub fn reset_partitions(&mut self) {
    self.partitions = None;
  }

  pub fn set_sensors(&mut self, sensors: ::models::ClusterNodeSensors) {
    self.sensors = Some(sensors);
  }

  pub fn with_sensors(mut self, sensors: ::models::ClusterNodeSensors) -> ClusterNodeExtended {
    self.sensors = Some(sensors);
    self
  }

  pub fn sensors(&self) -> Option<&::models::ClusterNodeSensors> {
    self.sensors.as_ref()
  }

  pub fn reset_sensors(&mut self) {
    self.sensors = None;
  }

  pub fn set_sleds(&mut self, sleds: Vec<::models::NodeSledsNodeSled>) {
    self.sleds = Some(sleds);
  }

  pub fn with_sleds(mut self, sleds: Vec<::models::NodeSledsNodeSled>) -> ClusterNodeExtended {
    self.sleds = Some(sleds);
    self
  }

  pub fn sleds(&self) -> Option<&Vec<::models::NodeSledsNodeSled>> {
    self.sleds.as_ref()
  }

  pub fn reset_sleds(&mut self) {
    self.sleds = None;
  }

  pub fn set_state(&mut self, state: ::models::ClusterNodeStateExtended) {
    self.state = Some(state);
  }

  pub fn with_state(mut self, state: ::models::ClusterNodeStateExtended) -> ClusterNodeExtended {
    self.state = Some(state);
    self
  }

  pub fn state(&self) -> Option<&::models::ClusterNodeStateExtended> {
    self.state.as_ref()
  }

  pub fn reset_state(&mut self) {
    self.state = None;
  }

  pub fn set_status(&mut self, status: ::models::ClusterNodeStatus) {
    self.status = Some(status);
  }

  pub fn with_status(mut self, status: ::models::ClusterNodeStatus) -> ClusterNodeExtended {
    self.status = Some(status);
    self
  }

  pub fn status(&self) -> Option<&::models::ClusterNodeStatus> {
    self.status.as_ref()
  }

  pub fn reset_status(&mut self) {
    self.status = None;
  }

}



