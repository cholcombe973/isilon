/* 
 * Isilon SDK
 *
 * Isilon SDK - Language bindings for the OneFS API
 *
 * OpenAPI spec version: 5
 * Contact: sdk@isilon.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */


#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct SyncSettingsSettings {
  /// The per-worker burst socket memory constraint, in bytes.
  #[serde(rename = "burst_memory_constraint")]
  burst_memory_constraint: Option<i32>,
  /// The per-worker burst socket buffer coalesced data, in bytes.
  #[serde(rename = "burst_socket_buffer_size")]
  burst_socket_buffer_size: Option<i32>,
  /// NOTE: This field should not be changed without the help of Isilon support.  Default for the \"force_interface\" property that will be applied to each new sync policy unless otherwise specified at the time of policy creation.  Determines whether data is sent only through the subnet and pool specified in the \"source_network\" field. This option can be useful if there are multiple interfaces for the given source subnet.
  #[serde(rename = "force_interface")]
  force_interface: Option<bool>,
  /// The max concurrent jobs that SyncIQ can support. This number is based on the size of the current cluster and the current SyncIQ worker throttle rule.
  #[serde(rename = "max_concurrent_jobs")]
  max_concurrent_jobs: Option<i32>,
  /// Email sync reports to these addresses.
  #[serde(rename = "report_email")]
  report_email: Option<Vec<String>>,
  /// The default length of time (in seconds) a policy report will be stored.
  #[serde(rename = "report_max_age")]
  report_max_age: Option<i32>,
  /// The default maximum number of reports to retain for a policy.
  #[serde(rename = "report_max_count")]
  report_max_count: Option<i32>,
  /// Default for the \"restrict_target_network\" property that will be applied to each new sync policy unless otherwise specified at the time of policy creation.  If you specify true, and you specify a SmartConnect zone in the \"target_host\" field, replication policies will connect only to nodes in the specified SmartConnect zone.  If you specify false, replication policies are not restricted to specific nodes on the target cluster.
  #[serde(rename = "restrict_target_network")]
  restrict_target_network: Option<bool>,
  /// If disabled, no RPO alerts will be generated.
  #[serde(rename = "rpo_alerts")]
  rpo_alerts: Option<bool>,
  /// Specifies if the SyncIQ service currently on, paused, or off.  If paused, all sync jobs will be paused.  If turned off, all jobs will be canceled.
  #[serde(rename = "service")]
  service: Option<String>,
  /// Restricts replication policies on the local cluster to running on the specified subnet and pool.
  #[serde(rename = "source_network")]
  source_network: Option<::models::SyncPolicySourceNetwork>,
  /// The interval (in seconds) in which treewalk syncs are forced to checkpoint.
  #[serde(rename = "tw_chkpt_interval")]
  tw_chkpt_interval: Option<i32>
}

impl SyncSettingsSettings {
  pub fn new() -> SyncSettingsSettings {
    SyncSettingsSettings {
      burst_memory_constraint: None,
      burst_socket_buffer_size: None,
      force_interface: None,
      max_concurrent_jobs: None,
      report_email: None,
      report_max_age: None,
      report_max_count: None,
      restrict_target_network: None,
      rpo_alerts: None,
      service: None,
      source_network: None,
      tw_chkpt_interval: None
    }
  }

  pub fn set_burst_memory_constraint(&mut self, burst_memory_constraint: i32) {
    self.burst_memory_constraint = Some(burst_memory_constraint);
  }

  pub fn with_burst_memory_constraint(mut self, burst_memory_constraint: i32) -> SyncSettingsSettings {
    self.burst_memory_constraint = Some(burst_memory_constraint);
    self
  }

  pub fn burst_memory_constraint(&self) -> Option<&i32> {
    self.burst_memory_constraint.as_ref()
  }

  pub fn reset_burst_memory_constraint(&mut self) {
    self.burst_memory_constraint = None;
  }

  pub fn set_burst_socket_buffer_size(&mut self, burst_socket_buffer_size: i32) {
    self.burst_socket_buffer_size = Some(burst_socket_buffer_size);
  }

  pub fn with_burst_socket_buffer_size(mut self, burst_socket_buffer_size: i32) -> SyncSettingsSettings {
    self.burst_socket_buffer_size = Some(burst_socket_buffer_size);
    self
  }

  pub fn burst_socket_buffer_size(&self) -> Option<&i32> {
    self.burst_socket_buffer_size.as_ref()
  }

  pub fn reset_burst_socket_buffer_size(&mut self) {
    self.burst_socket_buffer_size = None;
  }

  pub fn set_force_interface(&mut self, force_interface: bool) {
    self.force_interface = Some(force_interface);
  }

  pub fn with_force_interface(mut self, force_interface: bool) -> SyncSettingsSettings {
    self.force_interface = Some(force_interface);
    self
  }

  pub fn force_interface(&self) -> Option<&bool> {
    self.force_interface.as_ref()
  }

  pub fn reset_force_interface(&mut self) {
    self.force_interface = None;
  }

  pub fn set_max_concurrent_jobs(&mut self, max_concurrent_jobs: i32) {
    self.max_concurrent_jobs = Some(max_concurrent_jobs);
  }

  pub fn with_max_concurrent_jobs(mut self, max_concurrent_jobs: i32) -> SyncSettingsSettings {
    self.max_concurrent_jobs = Some(max_concurrent_jobs);
    self
  }

  pub fn max_concurrent_jobs(&self) -> Option<&i32> {
    self.max_concurrent_jobs.as_ref()
  }

  pub fn reset_max_concurrent_jobs(&mut self) {
    self.max_concurrent_jobs = None;
  }

  pub fn set_report_email(&mut self, report_email: Vec<String>) {
    self.report_email = Some(report_email);
  }

  pub fn with_report_email(mut self, report_email: Vec<String>) -> SyncSettingsSettings {
    self.report_email = Some(report_email);
    self
  }

  pub fn report_email(&self) -> Option<&Vec<String>> {
    self.report_email.as_ref()
  }

  pub fn reset_report_email(&mut self) {
    self.report_email = None;
  }

  pub fn set_report_max_age(&mut self, report_max_age: i32) {
    self.report_max_age = Some(report_max_age);
  }

  pub fn with_report_max_age(mut self, report_max_age: i32) -> SyncSettingsSettings {
    self.report_max_age = Some(report_max_age);
    self
  }

  pub fn report_max_age(&self) -> Option<&i32> {
    self.report_max_age.as_ref()
  }

  pub fn reset_report_max_age(&mut self) {
    self.report_max_age = None;
  }

  pub fn set_report_max_count(&mut self, report_max_count: i32) {
    self.report_max_count = Some(report_max_count);
  }

  pub fn with_report_max_count(mut self, report_max_count: i32) -> SyncSettingsSettings {
    self.report_max_count = Some(report_max_count);
    self
  }

  pub fn report_max_count(&self) -> Option<&i32> {
    self.report_max_count.as_ref()
  }

  pub fn reset_report_max_count(&mut self) {
    self.report_max_count = None;
  }

  pub fn set_restrict_target_network(&mut self, restrict_target_network: bool) {
    self.restrict_target_network = Some(restrict_target_network);
  }

  pub fn with_restrict_target_network(mut self, restrict_target_network: bool) -> SyncSettingsSettings {
    self.restrict_target_network = Some(restrict_target_network);
    self
  }

  pub fn restrict_target_network(&self) -> Option<&bool> {
    self.restrict_target_network.as_ref()
  }

  pub fn reset_restrict_target_network(&mut self) {
    self.restrict_target_network = None;
  }

  pub fn set_rpo_alerts(&mut self, rpo_alerts: bool) {
    self.rpo_alerts = Some(rpo_alerts);
  }

  pub fn with_rpo_alerts(mut self, rpo_alerts: bool) -> SyncSettingsSettings {
    self.rpo_alerts = Some(rpo_alerts);
    self
  }

  pub fn rpo_alerts(&self) -> Option<&bool> {
    self.rpo_alerts.as_ref()
  }

  pub fn reset_rpo_alerts(&mut self) {
    self.rpo_alerts = None;
  }

  pub fn set_service(&mut self, service: String) {
    self.service = Some(service);
  }

  pub fn with_service(mut self, service: String) -> SyncSettingsSettings {
    self.service = Some(service);
    self
  }

  pub fn service(&self) -> Option<&String> {
    self.service.as_ref()
  }

  pub fn reset_service(&mut self) {
    self.service = None;
  }

  pub fn set_source_network(&mut self, source_network: ::models::SyncPolicySourceNetwork) {
    self.source_network = Some(source_network);
  }

  pub fn with_source_network(mut self, source_network: ::models::SyncPolicySourceNetwork) -> SyncSettingsSettings {
    self.source_network = Some(source_network);
    self
  }

  pub fn source_network(&self) -> Option<&::models::SyncPolicySourceNetwork> {
    self.source_network.as_ref()
  }

  pub fn reset_source_network(&mut self) {
    self.source_network = None;
  }

  pub fn set_tw_chkpt_interval(&mut self, tw_chkpt_interval: i32) {
    self.tw_chkpt_interval = Some(tw_chkpt_interval);
  }

  pub fn with_tw_chkpt_interval(mut self, tw_chkpt_interval: i32) -> SyncSettingsSettings {
    self.tw_chkpt_interval = Some(tw_chkpt_interval);
    self
  }

  pub fn tw_chkpt_interval(&self) -> Option<&i32> {
    self.tw_chkpt_interval.as_ref()
  }

  pub fn reset_tw_chkpt_interval(&mut self) {
    self.tw_chkpt_interval = None;
  }

}



