/* 
 * Isilon SDK
 *
 * Isilon SDK - Language bindings for the OneFS API
 *
 * OpenAPI spec version: 5
 * Contact: sdk@isilon.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

/// ClusterFirmwareUpgradeItem : The settings necessary to start a firmware upgrade.

#[allow(unused_imports)]
use serde_json::Value;

#[derive(Debug, Serialize, Deserialize)]
pub struct ClusterFirmwareUpgradeItem {
  /// Exclude the specified devices in the firmware upgrade.
  #[serde(rename = "exclude_device")]
  exclude_device: Option<String>,
  /// Exclude the specified device type in the firmware upgrade.
  #[serde(rename = "exclude_type")]
  exclude_type: Option<String>,
  /// Include the specified devices in the firmware upgrade.
  #[serde(rename = "include_device")]
  include_device: Option<String>,
  /// Include the specified device type in the firmware upgrade.
  #[serde(rename = "include_type")]
  include_type: Option<String>,
  /// Do not burn the firmware.
  #[serde(rename = "no_burn")]
  no_burn: Option<bool>,
  /// Do not reboot the node after an upgrade
  #[serde(rename = "no_reboot")]
  no_reboot: Option<bool>,
  /// Do not verify the firmware upgrade after an upgrade.
  #[serde(rename = "no_verify")]
  no_verify: Option<bool>,
  /// The nodes scheduled for upgrade. Order in array determines queue position number. 'All' and null option will upgrade all nodes in <lnn> order.
  #[serde(rename = "nodes_to_upgrade")]
  nodes_to_upgrade: Option<Vec<i32>>
}

impl ClusterFirmwareUpgradeItem {
  /// The settings necessary to start a firmware upgrade.
  pub fn new() -> ClusterFirmwareUpgradeItem {
    ClusterFirmwareUpgradeItem {
      exclude_device: None,
      exclude_type: None,
      include_device: None,
      include_type: None,
      no_burn: None,
      no_reboot: None,
      no_verify: None,
      nodes_to_upgrade: None
    }
  }

  pub fn set_exclude_device(&mut self, exclude_device: String) {
    self.exclude_device = Some(exclude_device);
  }

  pub fn with_exclude_device(mut self, exclude_device: String) -> ClusterFirmwareUpgradeItem {
    self.exclude_device = Some(exclude_device);
    self
  }

  pub fn exclude_device(&self) -> Option<&String> {
    self.exclude_device.as_ref()
  }

  pub fn reset_exclude_device(&mut self) {
    self.exclude_device = None;
  }

  pub fn set_exclude_type(&mut self, exclude_type: String) {
    self.exclude_type = Some(exclude_type);
  }

  pub fn with_exclude_type(mut self, exclude_type: String) -> ClusterFirmwareUpgradeItem {
    self.exclude_type = Some(exclude_type);
    self
  }

  pub fn exclude_type(&self) -> Option<&String> {
    self.exclude_type.as_ref()
  }

  pub fn reset_exclude_type(&mut self) {
    self.exclude_type = None;
  }

  pub fn set_include_device(&mut self, include_device: String) {
    self.include_device = Some(include_device);
  }

  pub fn with_include_device(mut self, include_device: String) -> ClusterFirmwareUpgradeItem {
    self.include_device = Some(include_device);
    self
  }

  pub fn include_device(&self) -> Option<&String> {
    self.include_device.as_ref()
  }

  pub fn reset_include_device(&mut self) {
    self.include_device = None;
  }

  pub fn set_include_type(&mut self, include_type: String) {
    self.include_type = Some(include_type);
  }

  pub fn with_include_type(mut self, include_type: String) -> ClusterFirmwareUpgradeItem {
    self.include_type = Some(include_type);
    self
  }

  pub fn include_type(&self) -> Option<&String> {
    self.include_type.as_ref()
  }

  pub fn reset_include_type(&mut self) {
    self.include_type = None;
  }

  pub fn set_no_burn(&mut self, no_burn: bool) {
    self.no_burn = Some(no_burn);
  }

  pub fn with_no_burn(mut self, no_burn: bool) -> ClusterFirmwareUpgradeItem {
    self.no_burn = Some(no_burn);
    self
  }

  pub fn no_burn(&self) -> Option<&bool> {
    self.no_burn.as_ref()
  }

  pub fn reset_no_burn(&mut self) {
    self.no_burn = None;
  }

  pub fn set_no_reboot(&mut self, no_reboot: bool) {
    self.no_reboot = Some(no_reboot);
  }

  pub fn with_no_reboot(mut self, no_reboot: bool) -> ClusterFirmwareUpgradeItem {
    self.no_reboot = Some(no_reboot);
    self
  }

  pub fn no_reboot(&self) -> Option<&bool> {
    self.no_reboot.as_ref()
  }

  pub fn reset_no_reboot(&mut self) {
    self.no_reboot = None;
  }

  pub fn set_no_verify(&mut self, no_verify: bool) {
    self.no_verify = Some(no_verify);
  }

  pub fn with_no_verify(mut self, no_verify: bool) -> ClusterFirmwareUpgradeItem {
    self.no_verify = Some(no_verify);
    self
  }

  pub fn no_verify(&self) -> Option<&bool> {
    self.no_verify.as_ref()
  }

  pub fn reset_no_verify(&mut self) {
    self.no_verify = None;
  }

  pub fn set_nodes_to_upgrade(&mut self, nodes_to_upgrade: Vec<i32>) {
    self.nodes_to_upgrade = Some(nodes_to_upgrade);
  }

  pub fn with_nodes_to_upgrade(mut self, nodes_to_upgrade: Vec<i32>) -> ClusterFirmwareUpgradeItem {
    self.nodes_to_upgrade = Some(nodes_to_upgrade);
    self
  }

  pub fn nodes_to_upgrade(&self) -> Option<&Vec<i32>> {
    self.nodes_to_upgrade.as_ref()
  }

  pub fn reset_nodes_to_upgrade(&mut self) {
    self.nodes_to_upgrade = None;
  }

}



